# 이벤트 루프: 마이크로태스크와 매크로태스크

브라우저 측 자바스크립트 실행 흐름은 Node.js와 마찬가지로 **이벤트 루프**에 기반한다.

이 챕터에서 사용하는 용어의 동의어는 다음과 같다. 다른 자료를 볼 때 참고하면 된다.
- 마이크로태스크 큐 == 잡 큐
- 매크로태스크 큐 == 이벤트 큐 == 콜백 큐

## 이벤트 루프

이벤트 루프(event loop)는 태스크(task)가 들어오길 기다렸다가 태스크가 들어오면 이를 처리하고, 처리할 태스크가 없는 경우에는 잠드는, 끊임없이 돌아가는 자바스크립트 내 루프이다.

자바스크립트 엔진이 돌아가는 알고리즘을 일반화하면 다음과 같다.
1. 처리해야 할 태스크가 있는 경우:
    - 먼저 들어온 태스크부터 순차적으로 처리한다.
2. 처리해야 할 태스크가 없는 경우:
    - 잠들어 있다가 새로운 태스크가 추가되면 다시 1로 돌아간다.

바로 이 알고리즘이 우리가 브라우저를 사용해 인터넷을 서핑할 때 돌아가는 알고리즘이다. 이렇게 자바스크립트 엔진은 대부분의 시간 동안 아무런 일도 하지 않고 쉬고 있다가 스크립트나 핸들러, 이벤트가 활성화될 때만 돌아간다.

자바스크립트 엔진을 활성화하는 대표적인 태스크는 다음과 같다.
- 외부 스크립트 `<script src="...">`가 로드될 때, 이 스크립트를 실행하는 태스크
- 사용자가 마우스를 움직일 때 `mousemove` 이벤트와 이벤트 핸들러를 실행하는 태스크
- `setTimeout`에서 설정한 시간이 다 됐을 때, 콜백 함수를 실행하는 태스크

새로운 태스크는 엔진이 바쁠 때도 추가될 수 있다. 이때 이 태스크는 큐에 추가된다.

이렇게 태스크가 추가되는 큐를 V8 용어로 '매크로태스크 큐(macrotask queue)'라고 부른다.

매크로태스크는 다음의 상황에서 활용할 수 있다.
- CPU 소모가 많은 태스크 쪼개기
- 프로그레스 바 만들기
- 이벤트 처리가 끝난 이후에 작업하기

자세한 내용은 [원문](https://ko.javascript.info/event-loop)을 확인한다.

## 매크로태스크와 마이크로태스크

태스크는 이번 챕터에서 설명한 매크로태스크(macrotask)와 [마이크로태스크](https://github.com/autroshot/studyroom/blob/main/01-javascript/01-%EC%BD%94%EC%96%B4%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/11-%ED%94%84%EB%9D%BC%EB%AF%B8%EC%8A%A4%EC%99%80%20async%2C%20await/07-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%83%9C%EC%8A%A4%ED%81%AC.md#%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%ED%83%9C%EC%8A%A4%ED%81%AC) 챕터에서 다룬 마이크로태스크(microtask)로 나뉜다.

마이크로태스크는 코드로만 만들 수 있는데, 보통 프라미스를 사용해 만든다. 프라미스와 함께 쓰이는 `.then/catch/finally` 핸들러를 실행하면 마이크로태스크가 된다. 여기에 더하여 마이크로태스크는 프라미스를 핸들링하는 또 다른 문법인 `await`를 사용해 만들수 있다.

이 외에도 특별한 함수 `queueMicrotask(func)`를 사용하면 `func`를 마이크로태스크 큐에 넣을 수 있다.

** 엔진은 각 매크로태스크가 끝날 때마다 마이크로태스크 큐의 모든 테스크를 처리하고 다른 매크로태스크나 렌더링으로 넘어간다.**

예시:
```js
setTimeout(() => alert('timeout'));

Promise.resolve()
  .then(() => alert('promise'));

alert('code');
```
얼럿 창에는 다음 순서대로 문자열이 출력된다.
1. `code` -- 일반적인 동기 호출이므로 가장 먼저 매크로태스크 큐에 들어간 후 실행된다.
2. `promise` -- `.then`은 마이크로태스크 큐에 들어가 처리되기 때문에, 현재 코드(`alert("code")`) 이후에 실행된다.
3. `timeout` -- `setTimeout`에서 설정한 시간이 끝난 후 콜백 함수를 실행하는 것은 매크로태스크이기 때문에 가장 마지막에 출력된다.

매크로태스크(script, mousemove, setTimeout 등) 하나가 처리되고 나면 모든 마이크로태스크가 처리되고 렌더링이 진행된다.

![eventLoop-full](https://user-images.githubusercontent.com/95019875/169977920-73cb4428-5fec-4147-9d75-6e44add8b215.svg)

이처럼 마이크로태스크는 다른 이벤트 핸들러나 렌더링 작업, 혹은 다른 매크로태스크가 실행되기 전에 처리된다.

이런 처리 순서 덕분에 마이크로태스크 간에는 프로그램 환경이 변하지 않게 된다. 즉 마우스 좌표 변경이나 새 네트워크 데이터가 없다는 것을 보장해준다.

함수를 비동기적으로(현재 코드 다음에) 실행하고 싶지만, 새 이벤트가 처리되기 전이나 변경 사항이 렌더링되기 전에 실행하고 싶을 때는 `queueMicrotask`를 사용하면 된다.

## 요약

이벤트 루프 알고리즘을 요약하면 다음과 같다.
1. 매크로태스크 큐에서 가장 오래된 태스크를 꺼내 실행한다.
2. 모든 마이크로태스크를 실행한다.
3. 렌더링할 것이 있으면 처리한다.
4. 매크로태스크 큐가 비어있으면 새로운 매크로태스크가 나타날 때까지 기다린다.
5. 1번으로 돌아간다.

새로운 매크로태스크를 스케줄링하는 방법은 다음과 같다.
- 지연시간이 `0`인 `setTimeout(f)` 사용하기

이 방법을 사용하면 계산이 복잡한 큰 태스크 하나를 여러 개로 나눌 수 있다. 태스크를 여러 개로 쪼개면 태스크 중간중간 사용자 이벤트에 반응할 수 있고, 작업 진척 상태를 화면에 표시할 수도 있다.

지연시간이 `0`인 `setTimeout`은 이벤트가 완전히 처리되고 난 후(버블링이 끝난 후)에 특정 작업을 수행하도록 스케줄링할 때도 사용된다.

새로운 마이크로태스크를 스케줄링하는 방법은 다음과 같다.
- `queueMicrotask(f)` 사용하기
- 프라미스 사용하기

마이크로태스크 전체가 처리되는 동안에는 UI 변화나 네트워크 이벤트 핸들링이 일어나지 않는다. 렌더링이나 네트워크 요청 등의 작업은은 마이크로태스크가 모두 끝나고 처리된다.

이런 처리 순서 덕분에 `queueMicrotask`를 사용해 함수를 비동기적으로 처리할 때 애플리케이션 상태의 일관성이 보장된다.

---
:information_source: **웹 워커**

이벤트 루프를 막을 우려가 있는 무거운 연산은 [웹 워커(Web Worker)](https://html.spec.whatwg.org/multipage/workers.html)를 사용해 처리할 수 있다.

웹 워커를 사용하면 별도의 백그라운드 스레드에서 코드를 병렬적으로 실행할 수 있다.

메인 스레드와 메시지를 교환할 수 있긴 하지만 웹 워커에는 메인 스레드와 연관 없는 고유한 변수들과 자체 이벤트 루프가 있다.

웹 워커는 DOM에 접근할 수 없기 때문에 여러 CPU 코어를 동시에 사용해야 하는 연산에서 주로 사용한다.

---
