# [05] 자료구조와 자료형
자료형에 대해 좀 더 자세히 알아보고, 자바스크립트에서 제공해주는 다양한 자료구조에 대해 배워본다.

# 01. 원시값의 메서드
## 원시값을 객체처럼 사용하기
원시값이 메서드나 프로퍼티에 접근하려 하면 추가 기능을 제공해주는 특수한 객체, <strong>원시 래퍼 객체(object wrapper)</strong>를 만들어준다. 이 객체는 사용이 끝나면 바로 삭제된다.

자바스크립트 엔진은 원시 래퍼 객체를 만들지 않고도 마치 원시 래퍼 객체를 생성한 것처럼 동작하게 해준다.

---
:information_source: `String/Number/Boolean`를 생성자로 사용해서는 안 된다.

Java 등의 몇몇 언어에선 `new Number(1)` 또는 `new Boolean(false)`와 같은 문법을 사용해 원하는 타입의 "래퍼 객체"를 직접 만들 수 있다. 자바스크립트에서는 이런 식으로 `new`를 이용해 래퍼 객체를 만드는 것을 **추천하지 않는다**.

---
:warning: `null/undefined`는 메서드가 없다.

특수 자료형인 `null`과 `undefined`와 연관되는 "래퍼 객체"도 없고 메서드도 제공하지 않는다.

---

# 02. 숫자형
## 숫자를 입력하는 다양한 방법
큰 숫자나 작은 숫자를 나타낼 때는 과학적 표기법을 이용한다. 자바스크립트에서는 숫자 옆에 `e`를 붙이고 원하는 0의 개수를 그 옆에 붙여주면 된다.
```js
let billion = 1e9;  // 10억, 1과 9개의 0
alert(7.3e9);  // 73억(7,300,000,000)

let ms =  1e-6;  // 0이 6개인 소수이다.
```

### 16진수, 2진수, 8진수
16진수는 `0x`를 사용해 표현할 수 있다.
```js
alert(0xff); // 255
alert(0xFF); // 255(대·소문자를 가리지 않으므로 둘 다 같은 값을 나타낸다)
```
2진수와 `0b`를, 8진수는 `0o`를 사용해 나타낼 수 있다.
```js
let a = 0b11111111; // 255의 2진수
let b = 0o377; // 255의 8진수

alert(a == b); // true, a와 b는 같은 수이다.
```
자바스크립트에서 지원하는 진법은 앞의 3개이다. 이 외의 진법을 사용하려면 함수 `parseInt`를 사용해야 한다.

## toString(base)
`num.toString(base)` 메서드는 `base`진법으로 `num`을 표현한 후, 이를 문자형으로 변환해 반환한다.
```js
let num = 255;

alert(num.toString(16));  // ff
alert(num.toString(2));   // 11111111
```
`base`는 기본값이 `10`이며,  `2`부터  `36`까지 넣을 수 있다. `base`별 유스 케이스는 다음과 같다.

-   **base=16**
16진수 색, 문자 인코딩 등을 표현할 때 사용한다. 숫자는  `0`부터  `9`, 10 이상의 수는  `A`부터  `F`를 사용하여 나타낸다.

-   **base=2** 
비트 연산 디버깅에 주로 쓰인다. 숫자는  `0`  또는  `1`이 될 수 있습니다.

-   **base=36**
사용할 수 있는  `base`  중 최댓값으로,  `0..9`와  `A..Z`를 사용해 숫자를 표현한다. 알파벳 전체가 숫자를 나타내는 데 사용된다.  `36`  베이스는 url을 줄이는 것과 같이 숫자로 된 긴 식별자를 짧게 줄일 때 유용하다.
	```js run
	alert(123456..toString(36)); // 2n9c
	```
---
:warning: 점 두 개와 메서드 호출

위 예시처럼 숫자를 대상으로 메서드  `toString`을 직접 호출하고 싶다면 숫자 다음에 점 두 개  `..`를 붙여야 한다.

`123456.toString(36)`처럼 점을 한 개만 사용하면, 첫 번째 점 이후는 소수부로 인식되어 에러가 발생할 수 있다. 점을 하나 더 추가하면 자바스크립트는 소수부가 없다고 판단하고 함수를 호출한다.

`(123456).toString(36)`도 가능하다.

---

## 어림수 구하기
<strong>어림수(rounding)</strong>와 관련된 내장 함수 중에서 많이 사용되는 것은 다음과 같다.

- `Math.floor`: 내림
- `Math.ceil`: 올림
- `Math.round`: 반올림
- `Math.trunc`: 소수부를 무시한다. **Internet Explorer**에서는 지원하지 않는 기능이다.

각 내장 함수의 결과를 표로 정리하면 다음과 같다.
|      |`Math.floor`|`Math.ceil`|`Math.round`|`Math.trunc`|
|------|------------|-----------|------------|------------|
|`3.1` |`3`         |`4`        |`3`         |`3`         |
|`3.6` |`3`         |`4`        |`4`         |`3`         |
|`-1.1`|`-2`        |`-1`       |`-1`        |`-1`        |
|`-1.6`|`-2`        |`-1`       |`-2`        |`-1`        |

소수점 `n`번째 수를 기준으로 어림수를 구하고 싶을 때 사용할 수 있는 방법은 두 가지가 있다.
1. 곱하기와 나누기
	```js run
	let num = 1.23456;

	alert(Math.floor(num * 100) / 100); // 1.23456 -> 123.456 -> 123 -> 1.23
	```
2. 소수점 `n` 번째 수까지의 **반올림**을 구한 후 이를 **문자형**으로 반환해주는 메서드인 [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)를 사용한다.
	```js
	let num = 12.36;
	alert(num.toFixed(1)); // '12.4'
	```
	`toFixed`를 사용할 때 주의할 점은 이 메서드의 반환 값이 문자열이라는 것이다. 소수부의 길이가 인수보다 작으면 끝에 0이 추가된다.
	```js
	let num = 12.34;
	alert(num.toFixed(5)); // '12.34000', 소수부의 길이가 5이기 때문에 남은 공간에는 0이 추가되었다.
	```
	참고로, `+num.toFixed(5)`처럼 단항 덧셈 연산자를 앞에 붙이거나 `Number()`를 이용하면 문자형의 숫자를 숫자형으로 변환할 수 있다.

## 부정확한 계산
숫자는 내부적으로 64비트 형식 IEEE-754으로 표현되기 때문에 숫자를 저장하려면 정확히 64비트가 필요하다. 64비트 중 52비트는 숫자를 저장하는 데 사용되고, 11비트는 소수점 위치를(정수는 0), 1비트는 부호를 저장하는 데 사용된다.

꽤 자주 발생하는 현상인 정밀도 손실(loss of precision)이라는 것이 있다.
```js
alert(0.1 + 0.2 == 0.3); // false
alert(0.1 + 0.2); // 0.30000000000000004
```
10진법에서 1/3을 정확히 나타낼 수 없듯이, 2진법을 사용하는 컴퓨터에서는 0.1 또는 0.2를 **정확하게** 저장할 수 없다. IEEE-754에서는 가능한 가장 가까운 숫자로 반올림하는 방법을 사용해 이런 문제를 해결한다. 그런데 반올림 규칙을 적용하면 발생하는 '작은 정밀도 손실’을 우리가 볼 수는 없지만 실제로 손실은 발생한다.
```js run
alert(0.1.toFixed(20)); // 0.10000000000000000555
```
이 문제를 해결하는 가장 신뢰할만한 방법은 toFixed(n) 메서드를 사용해 어림수를 만드는 것이다.
```js
let sum = 0.1 + 0.2;
alert(sum.toFixed(2)); // 0.30
alert(+sum.toFixed(2)); // 0.3
```
숫자에 임시로 10의 거듭제곱을 곱하여 정수로 바꾸고, 원하는 연산을 한 후 다시 곱했던 수로 나누는 것도 하나의 방법이 될 수 있다. 정수를 대상으로 하는 수학 연산은 소수를 대상으로 하는 연산보다 에러가 적기 때문이다. 그런데 어쨌든 마지막에 나눗셈이 들어가기 때문에 소수가 다시 등장할 수 있다는 단점이 있다.
```js
alert((0.1 * 10 + 0.2 * 10) / 10); // 0.3
alert((0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
```
무한소수를 방지하는 완벽한 방법은 사실 없다. 필요할 때마다 '꼬리’를 잘라 어림수를 만드는 방법뿐이다.

---
:information_source: 정밀도 손실로 생기는 흥미로운 현상
```js
// 숫자가 스스로 증가했다.
alert(9999999999999999); // 10000000000000000이 출력된다.
```
문제의 원인은 정밀도 손실 때문이다. 실제 숫자를 저장하는 데에 사용되는 52비트에 위 숫자를 저장하기에는 공간이 모자라다. 따라서 최소 유효 숫자(the least significant digit)가 손실되어 버렸다.

---
:information_source: 두 종류의 0

자바스크립트 내부에서 숫자를 표현하는 방식 때문에 발생하는 또 다른 흥미로운 현상은  `0`과  `-0`이라는 두 종류의 0이 존재한다는 사실이다.

자바스크립트에선 숫자의 부호가 단일 비트에 저장되는데 0을 포함한 모든 숫자에 부호를 설정할 수도, 설정하지 않을 수도 있기 때문이다.

대부분의 연산은  `0`과  `-0`을 동일하게 취급하기 때문에 두 0의 차이는 두드러지지 않는다.

---

## isNaN과 isFinite
숫자형의 특수 숫자 값은 두 가지가 있다.
-   `Infinity`와  `-Infinity`
-   `NaN`: 에러를 나타내는 값이다.

특수 숫자와 관련된 특별한 함수가 존재한다.
- `isNaN(value)`: 인수를 숫자로 변환한 다음 `NaN`인지 테스트한다.
	```js
	alert(isNaN(NaN)); // true
	alert(isNaN('str')); // true
	```
	`NaN`은 `NaN` 자기 자신을 포함하여 그 어떤 값과도 같지 않다는 점에서 독특하다. 자기 자신에 대한 `===`도 `false`를 반환한다. 따라서 `NaN`을 판별할 때는 `isNaN` 함수를 사용해야 한다.
	```js
    alert(NaN === NaN); // false
    ```

- `isFinite(value)`: 인수를 숫자로 변환하고, 변환한 숫자가 `NaN/Infinity/-Infinity`가 아닌 일반 숫자인 경우 `true`를 반환한다.
	```js
    alert(isFinite('15')); // true
    alert(isFinite('str')); // false, NaN이기 때문이다.
    alert(isFinite(Infinity)); // false, Infinity이기 때문이다.
    ```
    `isFinite`는 문자열이 일반 숫자인지 검증하는 데 사용되곤 한다.
    ```js
	let num = +prompt('숫자를 입력하세요.', '');

	// 숫자가 아닌 값을 입력하거나 Infinity, -Infinity를 입력하면 false가 출력된다.
	alert(isFinite(num));
	```
빈 문자열이나 공백만 있는 문자열은 `isFinite`를 포함한 모든 숫자 관련 내장 함수에서 `0`으로 취급된다는 점을 주의해야 한다.

---
:information_source: `Object.is`와 비교하기

[`Object.is`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/is)는  `===`처럼 값을 비교할 때 사용되는 특별한 내장 메서드이다. 아래와 같은 두 가지 에지 케이스에선  `===`보다 좀 더 신뢰할 만한 결과를 보여준다.

1.  `NaN`을 대상으로 비교할 때:  `Object.is(NaN, NaN) === true`
2.  `0`과  `-0`이 다르게 취급되어야 할 때:  `Object.is(0, -0) === false`이다. 숫자를 나타내는 비트가 모두 0이더라도 부호를 나타내는 비트가 다르므로  `0`과  `-0`은 사실 다른 값이긴 하다.

앞의 두 에지 케이스를 제외하면 `Object.is(a, b)`와  `a === b`의 결과는 같다.

이런 식의 비교는 자바스크립트 명세서에서 종종 찾아볼 수 있다. 내부 알고리즘에서 두 값을 비교해야 하는데, 비교 결과가 정확해야 하는 경우  `Object.is`를 사용한다. `Object.is`에서 사용되는 비교방식은 명세서에서  SameValue라고 부른다.

---

## parseInt와 parseFloat
단항 덧셈 연산자 `+` 또는 `Number()`를 사용하여 숫자형으로 변형할 때는 피연산자가 숫자가 아니면 형 변환이 실패한다.
```js
alert(+'100px'); // NaN
```

내장 함수 `parseInt`와 `parseFloat`은 불가능할 때까지 문자열에서 숫자를 ‘읽는다'. 숫자를 읽는 도중 오류가 발생하면 이미 수집된 숫자를 반환한다. `parseInt`는 정수, `parseFloat`는 부동 소수점 숫자를 반환한다. 두 함수는 '약한' 형 변환을 해준다.
```js
alert(parseInt('100px')); // 100
alert(parseFloat('12.5em')); // 12.5

alert(parseInt('12.3')); // 12, 정수 부분만 반환된다.
alert(parseFloat('12.3.4')); // 12.3, 두 번째 점에서 숫자 읽기를 멈춘다.
```
```js
alert(parseInt('a123')); // NaN, a는 숫자가 아니므로 숫자를 읽기가 바로 중단된다.
```

---
:information_source: `parseInt(str, radix)`의 두 번째 인수

`parseInt()`의 두 번째 매개 변수는 선택적으로 사용할 수 있다. `radix`는 원하는 16진수, 2진수 등의 진수를 지정해 줄 때 사용한다.
```js
alert(parseInt('0xff', 16)); // 255
alert(parseInt('ff', 16)); // 255, 0x가 없어도 동작한다.

alert(parseInt('2n9c', 36)); // 123456
```
---

## 기타 수학 메서드
자바스크립트에서 제공하는 내장 객체 Math에는 다양한 수학 관련 메서드와 상수들이 들어있다.

`Math.random()`
0 이상 1 미만의 난수를 반환한다.
```js
alert(Math.random()); // 0.1234567894322
alert(Math.random()); // 0.5435252343232
alert(Math.random()); // ... (무작위 수)
```

`Math.max(a, b, c...)`  /  `Math.min(a, b, c...)`
인수 중 최댓값/최솟값을 반환한다.
```js
alert(Math.max(3, 5, -10, 0, 1)); // 5
alert(Math.min(1, 2)); // 1
```

`Math.pow(n, power)`
`n`을 `power`번 거듭제곱한 값을 반환한다.
```js
alert(Math.pow(2, 10)); // 2의 10제곱 = 1024
```

이 외의 다양한 함수와 상수는 [MDN 문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Math)를 참고한다.
<br></br>
# 03. 문자열
자바스크립트에서 문자열은 페이지 인코딩 방식과 상관없이 항상 UTF-16(16-bit Unicode Transformation Format) 형식을 따른다.

## 따옴표
문자열은 작은따옴표나 큰따옴표, 백틱으로 감쌀 수 있다.
```js
let single = '작은따옴표';
let double = "큰따옴표";

let backticks = `백틱`;
```

작은따옴표와 큰따옴표는 기능상 차이가 없다. 그런데 백틱에는 특별한 기능이 있다. 표현식을 `${…}`로 감싸고 이를 백틱으로 감싼 문자열 중간에 넣어줄 수 있다. 이런 방식을 <strong>템플릿 리터럴(template literal)</strong>이라고 부른다.
```js
function sum(a, b) {
  return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}`); // 1 + 2 = 3
```
백틱을 사용하면 문자열을 여러 줄에 걸쳐 작성할 수 있다.
```js
let guestList = `손님:
 * John
 * Pete
 * Mary
`;

alert(guestList); // 손님 리스트를 여러 줄에 걸쳐 출력한다.
```
작은따옴표나 큰따옴표를 이용해 위와 같은 코드를 작성하면 에러가 발생한다.

백틱은 '템플릿 함수(template function)'에서도 사용된다. ``func`string` `` 같이 첫 번째 백틱 바로 앞에 함수 이름(`func`)을 써주면, 이 함수는 백틱 안의 문자열 조각이나 표현식 평가 결과를 인수로 받아 자동으로 호출된다. 이런 기능을 '태그드 템플릿(tagged template)'이라 부르는데, 태그드 템플릿을 사용하면 사용자 지정 템플릿에 맞는 문자열을 쉽게 만들 수 있다. 태그드 템플릿과 템플릿 함수에 대한 자세한 내용은 [MDN 문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates)에서 확인할 수 있다. 참고로 이 기능은 자주 사용되진 않는다.

## 특수 기호
'줄 바꿈 문자(newline character)'라 불리는 특수기호 `\n`을 사용하면 작은따옴표나 큰따옴표로도 여러 줄 문자열을 만들 수 있다.
```js
let guestList = '손님:\n * John\n * Pete\n * Mary';

alert(guestList); // 손님 리스트를 여러 줄에 걸쳐 출력한다.
```
따옴표를 이용해 만든 여러 줄 문자열과 백틱을 이용해 만든 여러 줄 문자열은 표현 방식만 다를 뿐 차이가 없다.
```js
let str1 = 'Hello\nWorld'; // '줄 바꿈 기호'를 사용해 두 줄짜리 문자열을 만들었다.

// 백틱과 일반적인 줄 바꿈 방법(엔터)을 사용해 두 줄짜리 문자열을 만들었다.
let str2 = `Hello
World`;

alert(str1 === str2); // true
```

자바스크립트에는 다양한 특수 문자들이 있다.
|특수 문자|설명|
|---|---|
|`\n`|줄 바꿈|
|`\r`|캐리지 리턴(carriage return). 맨 앞으로 이동하라는 뜻이다. Windows에서는 캐리지 리턴과 줄 바꿈 특수 문자를 조합(`\r\n`)해 줄을 바꾼다. 캐리지 리턴을 단독으로 사용하는 경우는 없다.|
|`\'`, `\"`|따옴표|
|`\\`|역슬래시|
|`\t`|탭|
|`\b`, `\f`, `\v`|각각 백스페이스(Backspace), 폼 피드(Form Feed), 세로 탭(Vertical Tab)을 나타낸다. 호환성 유지를 위해 남아있는 기호로 요즘에는 사용하지 않는다.|
|`\xXX`|16진수 유니코드 `XX`로 표현한 유니코드 글자이다(예시: 알파벳 `'z'`는 `'\x7A'`와 동일하다).|
|`\uXXXX`|UTF-16 인코딩 규칙을 사용하는 16진수 코드 `XXXX`로 표현한 유니코드 기호이다. `XXXX`는 반드시 네 개의 16진수로 구성되야 한다(예시: `\u00A9`는 저작권 기호 `©`의 유니코드이다).|
|`\u{X…XXXXXX}`(한 개에서 여섯 개 사이의 16진수 글자)|UTF-32로 표현한 유니코드 기호이다. 몇몇 특수한 글자는 두 개의 유니코드 기호를 사용해 인코딩되므로 4바이트를 차지한다. 이 방법을 사용하면 긴 코드를 삽입할 수 있다.|

모든 특수 문자는 '이스케이프 문자(escape character)'라고도 불리는 역슬래시 (backslash character)  `\`로 시작한다. 역슬래시는 문자열 내에 따옴표를 넣을 때도 사용할 수 있다.
```js
alert('I\'m the Walrus!'); // I'm the Walrus!
```
다음과 같이 `\`를 안 쓰고 큰따옴표와 작은따옴표를 교차로 사용하는 방법도 있다.
```js
alert("I'm the Walrus!"); // I'm the Walrus!
```
문자열 내에서 따옴표를 자유롭게 사용하려면 아래와 같이 따옴표 대신 백틱으로 문자열을 감싸주면 된다.
```js
alert(`I'm the Walrus!`); // I'm the Walrus!
```

## 문자열의 길이
문자열의 길이는 `length` 프로퍼티에서 확인할 수 있다.
```js
alert(`My\n`.length); // 3
```
`\n`은 ‘특수 문자’ 하나로 취급되기 때문에 `My\n`의 길이는 `3`이다.

---
:warning: `length`는 프로퍼티이다.

`length`는 함수가 아니고, 숫자가 저장되는 프로퍼티라는 점에 주의해야 한다. `length()`는 에러가 발생한다.

---

## 특정 글자에 접근하기
문자열 내 특정 위치인 `pos`에 있는 글자에 접근하려면 `[pos]`같이 대괄호를 이용하거나 [str.charAt(pos)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/charAt) 메서드를 사용하면 된다. 위치는 `0`부터 시작한다.
```js
let str = `Hello`;

// 첫 번째 글자
alert(str[0]); // H
alert(str.charAt(0)); // H

// 마지막 글자
alert(str[str.length - 1]); // o
```
요즘에는 대괄호 방식을 주로 사용한다.  `charAt`은 하위 호환성을 위해 남아있는 메서드이다.

두 접근 방식의 차이는 반환할 글자가 없을 때 드러난다. 접근하려는 위치에 글자가 없는 경우  대괄호 방식은  `undefined`를,  `charAt`은 빈 문자열을 반환한다.
```js
let str = `Hello`;

alert(str[1000]); // undefined
alert(str.charAt(1000)); // ''(빈 문자열)
```
`for..of`를 사용하면 문자열을 구성하는 글자를 대상으로 반복 작업을 할 수 있다.
```js
for (let char of 'Hello') {
  alert(char); // H,e,l,l,o(char는 순차적으로 H, e, l, l, o가 된다)
}
```

## 문자열의 불변성
문자열은 수정할 수 없으며 문자열의 일부를 수정하려고 하면 에러가 발생한다. 완전히 새로운 문자열을 만들어 할당하는 것은 가능하다.
```js
let str = 'Hi';

str = 'h' + str[1]; // 문자열 전체를 교체한다.

alert(str); // hi
```

## 대·소문자 변경하기
메서드  [toUpperCase()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase)는 소문자를 대문자로, 메서드  [toLowerCase()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase)는 대문자를 소문자로 바꿔준다.
```js
alert('Interface'.toUpperCase()); // INTERFACE
alert('Interface'.toLowerCase()); // interface
```
글자 하나의 케이스만 변경하는 것도 가능하다.
```js
alert('Interface'[0].toLowerCase()); // 'i'
```

## 부분 문자열 찾기
문자열에서 부분 문자열(substring)을 찾는 방법은 여러 가지가 있다.
### str.indexOf
첫 번째 방법은  [str.indexOf(substr[, pos])](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf)  메서드를 이용하는 것이다.

이 메서드는 문자열  `str`의  `pos`에서부터 시작해, 부분 문자열  `substr`의 위치를 찾아준다. 부분 문자열을 찾지 못하면  `-1`을 반환한다.
```js
let str = 'Widget with id';

alert(str.indexOf('Widget')); // 0, str은 'Widget'으로 시작한다.
alert(str.indexOf('widget')); // -1, indexOf는 대·소문자를 구분하므로 원하는 문자열을 찾지 못한다.

alert(str.indexOf('id')); // 1, 'id'는 첫 번째 위치에서 발견된다(Widget의 id).
```
`str.indexOf(substr, pos)`의 두 번째 매개변수 `pos`는 선택적으로 사용할 수 있는데, 이를 명시하면 검색이 해당 위치부터 시작된다.
```js
let str = 'Widget with id';

alert( str.indexOf('id', 2) ) // 12
```
문자열 전체에서 부분 문자열을 모두 찾고 싶다면 다음과 같이 반복문 안에서 `indexOf`를 사용하면 된다.
```js
let str = 'As sly as a fox, as strong as an ox';

let target = 'as';

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `위치: ${foundPos}` );
  pos = foundPos + 1; // 다음 위치를 기준으로 검색을 이어간다.
}
```

---
:information_source: **`str.lastIndexOf(substr, position)`**

[str.lastIndexOf(substr[, position])](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf)는 문자열의 끝에서부터 부분 문자열을 찾는다.

---

#### 비트 NOT 연산자를 사용한 기법
[비트(bitwise) NOT 연산자](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators)  `~`를 사용한 오래된 기법이 있다. 비트 NOT 연산자는 피연산자를 32비트 정수로 바꾼 후(소수부는 모두 버려짐) 모든 비트를 반전한다. 따라서 `n`이 32비트 정수일 때 `~n`은 `-(n+1)`이 된다.
```js
alert( ~2 ); // -3, -(2+1)과 같다.
alert( ~1 ); // -2, -(1+1)과 같다.
alert( ~0 ); // -1, -(0+1)과 같다.

alert( ~-1 ); // 0, -(-1+1)과 같다.
```
부호가 있는 32비트 정수 `n` 중, `~n`을 `0`으로 만드는 경우는 `n == -1`일 때가 유일하다. 이를 이용해서 `indexOf`가 `-1`을 반환하지 않는 경우를 `~str.indexOf("...")`로 검사할 수 있다.
```js
let str = 'Widget';

if (~str.indexOf('Widget')) {
  alert('찾았다!');
}
```
이렇게 언어 특유의 기능을 사용해 직관적이지 않은 코드를 작성하는 것은 추천하지 않는다. 그렇지만 위와 같은 기법은 오래된 스크립트에서 쉽게 만날 수 있기 때문에 알아두어야 한다.

`if (~str.indexOf(...))`  패턴의 코드를 만나면 부분 문자열이 존재하는지 확인하는 코드인 것을 기억해 둘 필요가 있다.

모던 자바스크립트에서는 `.includes` 메서드를 사용해서 부분 문자열 포함 여부를 검사한다.

### includes, startsWith, endsWith
비교적 근래에 나온 메서드인  [str.includes(substr[, pos])](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/includes)는  `str`에 부분 문자열  `substr`이 있는지에 따라  `true`나  `false`를 반환한다.

부분 문자열의 위치 정보는 필요하지 않고 포함 여부만 알고 싶을 때 적합한 메서드이다.
```js
alert('Widget with id'.includes('Widget')); // true
alert('Hello'.includes('Bye')); // false
```
`str.includes`에도 `str.indexOf`처럼 두 번째 인수를 넣으면 해당 위치부터 부분 문자열을 검색한다.
```js
alert('Widget'.includes('id')); // true
alert('Widget'.includes('id', 3)); // false, 세 번째 위치 이후에는 'id'가 없다.
```
메서드 [str.startsWith](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith)와 [str.endsWith](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith)는 문자열 `str`이 특정 문자열로 시작하는지(start with) 여부와 특정 문자열로 끝나는지(end with) 여부를 확인할 때 사용할 수 있다.
```js
alert('Widget'.startsWith('Wid')); // true, 'Widget'은 'Wid'로 시작한다.
alert('Widget'.endsWith('get')); // true, 'Widget'은 'get'으로 끝난다.
```

## 부분 문자열 추출하기
자바스크립트에는 부분 문자열 추출과 관련된 메서드가 세 가지 있다.

### str.slice(start [, end])
문자열의  `start`부터  `end` 이전까지를 반환한다.
```js
let str = 'stringify';
alert(str.slice(0, 5)); // 'strin', 0번째부터 5번째 위치까지(5번째 위치의 글자는 미포함)
alert(str.slice(0, 1)); // 's', 0번째부터 1번째 위치까지(1번째 위치의 글자는 미포함)
```
```js
let str = 'stringify';
alert(str.slice(2)); // ringify, 2번째부터 끝까지
```
`start`와 `end`는 음수가 될 수도 있다. 음수를 넣으면 문자열 끝에서부터 카운팅을 시작한다.
```js
let str = 'stringify';

// 끝에서 4번째부터 시작해 끝에서 1번째 위치까지
alert(str.slice(-4, -1)); // gif
```

### str.substring(start [, end])
`substring`은  `slice`와 아주 유사하지만  `start`가  `end`보다 커도 된다는 차이가 있다.
```js
let str = 'stringify';

// 동일한 부분 문자열을 반환한다.
alert(str.substring(2, 6)); // 'ring'
alert(str.substring(6, 2)); // 'ring'

alert(str.slice(2, 6)); // 'ring'(같다)
alert(str.slice(6, 2)); // ''(빈 문자열), 다른 결과가 나온다.
```
`substring`은 음수 인수를 허용하지 않는다. 음수는 `0`으로 처리된다.

### str.substr(start [, length])
`start`에서부터 시작해  `length`개의 글자를 반환한다.

`substr`은 끝 위치 대신에 길이를 기준으로 문자열을 추출한다는 점에서  `substring`과  `slice`와 차이가 있다.
```js
let str = 'stringify';
alert(str.substr(2, 4)); // 'ring', 두 번째부터 글자 네 개
```
첫 번째 인수가 음수면 뒤에서부터 개수를 센다.
```js
let str = 'stringify';
alert(str.substr(-4, 2)); // 'gi', 끝에서 네 번째 위치부터 글자 두 개
```
부분 문자열 추출과 관련된 메서드들을 정리하면 다음과 같다.
|메서드                  |추출할 부분 문자열                   |음수 허용 여부(인수) |
|-----------------------|---------------------------|------------------|
|`slice(start, end)`    |`start`부터 `end` 이전까지   |음수 허용          |
|`substring(start, end)`|`start`부터 `end` 이전까지   |음수는 `0`으로 취급함|
|`substr(start, length)`|`start`부터 `length`개의 글자|음수 허용          |

---
:information_source: **어떤 메서드를 사용해야 할까?**

`substr`는 코어 자바스크립트 명세서가 아닌, 구식 스크립트에 대응하기 위해 남겨 둔 브라우저 전용 기능들을 명시해 놓은 부록 B(Annex B)에 정의되어있다. 거의 모든 곳에서 이 메서드가 동작하긴 하지만 브라우저 이외의 호스트 환경에서는 제대로 동작하지 않을 수 있다.

남은 두 메서드 중 `slice`는 음수 인수를 허용한다는 측면에서 `substring`보다 유연하며 메서드 이름도 더 짧다. 따라서 <strong>`slice`</strong>만 외워놓고 사용해도 충분할 것이다.

---

## 문자열 비교하기
[비교 연산자](https://github.com/autroshot/studyroom/blob/main/01-javascript/01-%EC%BD%94%EC%96%B4%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/02-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EA%B8%B0%EB%B3%B8.md#09-%EB%B9%84%EA%B5%90-%EC%97%B0%EC%82%B0%EC%9E%90)  챕터에서 알아봤듯이 문자열을 비교할 때는 알파벳 순서를 기준으로 비교가 이뤄진다.

그런데 다음과 같이 몇 가지 이상한 점들이 있다.
1. 소문자는 대문자보다 항상 크다.
	```js
    alert('a' > 'Z'); // true
    ```
2. 발음 구별 기호(diacritical mark)가 붙은 문자는 알파벳 순서 기준을 따르지 않는다.
	```js
	// Österreich는 오스트리아를 독일어로 표기한 것이다.
    alert('Österreich' > 'Zealand'); // true
    ```
모든 문자열은 UTF-16을 사용해서 인코딩되는데, UTF-16에서는 모든 글자가 숫자 형식의 코드와 매칭된다. 코드로 글자를 얻거나 글자에서 연관 코드를 알아낼 수 있는 메서드는 다음과 같다.

`str.codePointAt(pos)`
`pos`에 위치한 글자의 코드를 반환한다.
```js
// 글자는 같지만 케이스가 다르므로 반환되는 코드가 다르다.
alert('z'.codePointAt(0)); // 122
alert('Z'.codePointAt(0)); // 90
```
`String.fromCodePoint(code)`
숫자 형식의  `code`에 대응하는 글자를 반환한다.
```js
alert(String.fromCodePoint(90)); // Z
```
글자는 글자에 대응하는 **숫자 형식의 코드**를 기준으로 비교된다. 알파벳 소문자의 코드는 대문자의 코드보다 크다. `Ö`  같은 글자의 코드는 일반 알파벳의 코드보다 훨씬 크다.

### 문자열 제대로 비교하기
모던 브라우저 대부분이 국제화 관련 표준인 [ECMA-402](http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf)를 지원한다(IE10는 [Intl.js](https://github.com/andyearnshaw/Intl.js/) 라이브러리를 사용해야 한다). ECMA-402에는 언어가 다를 때 적용할 수 있는 문자열 비교 규칙과 이를 준수하는 메서드가 정의되어있다.

[str1.localeCompare(str2)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)를 사용하면 ECMA-402에서 정의한 규칙에 따라 `str1`이 `str2`보다 작은지, 같은지, 큰지를 알려주는 정수가 반환된다. 작으면 음수, 크면 양수, 같으면 `0`을 반환한다.
```js
alert('z'.localeCompare('Z')); // -1, 음수
alert('Österreich'.localeCompare('Zealand')); // -1, 음수
```
`localeCompare`에 선택 인수 두 개를 더 전달할 수 있다. 기준이 되는 언어를 지정(아무것도 지정하지 않았으면 호스트 환경의 언어가 기준 언어가 된다)해주는 인수와 대·소문자를 구분 여부나 `"a"`와 `"á"`를 다르게 취급할지 여부를 설정해주는 인수가 있다. 자세한 사항은 관련 [MDN 문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)에서 확인할 수 있다.

## 기타 문자열 메서드
-   `str.trim()`: 문자열 앞과 끝의 공백 문자를 제거한다.
-   `str.repeat(n)`: 문자열을  `n`번 반복한다.
-   이 외의 메서드는  [MDN 문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String)에서 확인할 수 있다.

## 문자열 심화
---
:warning: **심화학습**

이모티콘이나 일부 수학 기호, 상형 문자를 비롯한 희귀 기호 등을 다뤄야 한다면 앞으로 배울 내용이 유용하게 사용될 것이다.

---

### 서로게이트 쌍
유럽권 언어에서 사용되는 글자, 숫자, 상형 문자 대다수는 2바이트 표현 체계를 사용한다. 하지만 2바이트는 현존하는 기호를 모두 표현하기에 충분하지 않았다. 이를 극복하기 위해 사용 빈도가 낮은 기호는 <strong>서로게이트 쌍(surrogate pair)</strong>이라 불리는 2바이트 글자들의 쌍을 사용해 인코딩한다.

서로게이트 쌍을 사용해 인코딩한 기호의 길이는 `2`이다.
```js
alert( '𝒳'.length ); // 2, 그리스 문자 카이
alert( '😂'.length ); // 2, 이모티콘
alert( '𩷶'.length ); // 2, 사용 빈도가 낮은 중국어 상형문자
```
`String.fromCodePoint`와 `str.codePointAt`은 명세서에 추가된 지 얼마 안 된 메서드로, 서로게이트 쌍을 제대로 처리할 수 있는 몇 안 되는 메서드이다.

서로게이트 쌍은 두 글자로 취급되기 때문에 기호를 가져오는 게 꽤 까다롭다.
```js run
alert( '𝒳'[0] ); // 이상한 기호가 출력된다.
alert( '𝒳'[1] ); // 서로게이트 쌍의 일부가 출력된다.
```
서로게이트 쌍을 구성하는 글자들은 서로 붙어있을 때만 의미가 있기 때문에 위 예시를 실행하면 얼럿창에는 의미 없는 기호가 출력된다.

기술적으로 서로게이트 쌍은 서로게이트 쌍에 대응하는 코드를 사용해 감지할 수 있다. 서로게이트 쌍을 구성하는 첫 번째 글자는 `0xd800..0xdbff`에, 두 번째 글자의 코드는 `0xdc00..0xdfff`에 존재한다.

서로게이트 쌍을 다루는 다양한 방법에 대해선 [iterable 객체]() 챕터에서 살펴볼 것이다.

### 발음 구별 기호와 유니코드 정규화
일부 언어에서는 글자 위나 아래에 발음 구별 기호를 붙여 글자를 만든다. `a`를 베이스 글자로, `àáâäãåā`를 만드는 것이 그 예이다. 그런데 모든 합성 글자에 코드가 부여되지는 않는다. 조합 가능한 글자의 수가 너무 많기 때문이다.

베이스 글자 뒤에 하나 혹은 여러 개의 유니코드 문자를 붙여 베이스 글자를 꾸밀 수 있다.
```js
alert('S\u0307'); // Ṡ
alert('S\u0307\u0323'); // Ṩ
```
이런 방식은 엄청난 유연성을 제공하지만 단점도 있다. 눈으로 봤을 때는 같은 글자인데 유니코드 조합이 다른 경우가 생긴다.
```js
let s1 = 'S\u0307\u0323'; // Ṩ, S + 윗 점 + 아랫 점
let s2 = 'S\u0323\u0307'; // Ṩ, S + 아랫 점 + 윗 점

alert(`s1: ${s1}, s2: ${s2}`);

alert(s1 == s2); // 눈으로 보기엔 같은 글자이지만 동등 비교 시 false가 반환된다.
```
이런 문제를 해결하려면 '유니코드 정규화(unicode normalization)'라 불리는 알고리즘을 사용해 각 문자열을 동일한 형태로 정규화해야 한다. 유니코드 정규화 알고리즘은  [str.normalize()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)에 구현되어 있다.
```js
alert('S\u0307\u0323'.normalize() == 'S\u0323\u0307'.normalize()); // true
```
```js
alert('S\u0307\u0323'.normalize().length ); // 1

alert('S\u0307\u0323'.normalize() == '\u1e68'); // true
```
정규화 규칙과 변형에 대해 더 알고 싶다면 유니코드 표준 부록의 [Unicode Normalization Forms](http://www.unicode.org/reports/tr15/)에서 확인할 수 있다.
<br></br>
# 04. 배열
**순서가 있는 컬렉션**을 저장할 때는 **배열**을 사용하면 편리하다.

## 배열 선언
빈 배열을 만드는 방법은 아래 두 가지가 있다.
```js
let arr = new Array();
let arr = [];
```
대부분 두 번째 방법으로 배열을 선언하는데, 이때 대괄호 안에 초기 요소를 넣어주는 것도 가능하다.
```js
let fruits = ['사과', '오렌지', '자두'];
```
각 배열 요소엔 0부터 시작하는 숫자(**인덱스**)가 매겨져 있다. 이 숫자들은 배열 내 순서를 나타낸다.

배열 내 특정 요소를 얻고 싶다면 대괄호 안에 인덱스를 넣어주면 된다.
```js
let fruits = ['사과', '오렌지', '자두'];

alert(fruits[0]); // 사과
alert(fruits[1]); // 오렌지
alert(fruits[2]); // 자두
```
같은 방법으로 요소를 수정할 수 있다.
```js
fruits[2] = '배'; // 배열이 ['사과', '오렌지', '배']로 바뀐다.
```

새로운 요소를 배열에 추가하는 것도 가능하다.

```js
fruits[3] = '레몬'; // 배열이 ['사과', '오렌지', '배', '레몬']으로 바뀐다.
```

`length`를 사용하면 배열에 담긴 요소가 몇 개인지 알 수 있다.

```js
let fruits = ['사과', '오렌지', '자두'];

alert(fruits.length); // 3
```
`alert`를 사용해 요소 전체를 출력하는 것도 가능하다.
```js
let fruits = ['사과', '오렌지', '자두'];

alert(fruits); // 사과,오렌지,자두
```
배열 요소의 자료형에는 제약이 없다.
```js run no-beautify
// 요소에 여러 가지 자료형이 섞여 있다.
let arr = ['사과', {name: '이보라'}, true, function() {alert('안녕하세요.');}];

// 인덱스가 1인 요소(객체)의 name 프로퍼티를 출력한다.
alert(arr[1].name); // 이보라

// 인덱스가 3인 요소(함수)를 실행한다.
arr[3](); // 안녕하세요.
```

---
:information_source: **trailing 쉼표**
배열의 마지막 요소는 객체와 마찬가지로 쉼표로 끝날 수 있다.
```js
let fruits = [
  '사과',
  '오렌지',
  '자두',
];
```
trailing(길게 늘어지는) 쉼표를 사용하면 모든 줄의 생김새가 유사해지기 때문에 요소를 넣거나 빼기가 쉬워진다.

---

## pop/push와 shift/unshift
<strong>큐(queue)</strong>는 배열을 사용해 만들 수 있는 대표적인 자료구조로, 배열과 마찬가지로 순서가 있는 컬렉션을 저장하는 데 사용한다. 큐에서 사용하는 주요 연산은 아래와 같다.
-   `push`: 맨 끝에 요소를 추가한다.
-   `shift`: 제일 앞 요소를 꺼내 제거한 후 남아있는 요소들을 앞으로 밀어준다. 이렇게 하면 두 번째 요소가 첫 번째 요소가 된다.

![queue](https://user-images.githubusercontent.com/95019875/156590982-ba8e25d8-a017-4768-aa98-94e3f02289af.svg)

배열은 큐 이외에  <strong>스택(stack)</strong>이라 불리는 자료구조를 구현할 때도 쓰입니다. 스택에서 사용하는 연산은 아래와 같습니다.
-   `push`: 요소를 스택의 끝에 집어넣는다.
-   `pop`: 스택의 끝 요소를 추출한다.

![stack](https://user-images.githubusercontent.com/95019875/156591014-ddddc6be-30f2-48b3-a11c-b38580880a06.svg)

큐는 먼저 집어넣은 요소가 먼저 나오기 때문에 큐는 선입선출(First-In-First-Out, FIFO) 자료구조라고 부른다. 반면 스택은 가장 나중에 집어넣은 요소가 먼저 나오기 때문에 후입선출(Last-In-First-Out, LIFO) 자료구조라고 부른다.

자바스크립트 배열을 사용하면 큐나 스택을 모두 만들 수 있다. 이 자료구조들은 배열의 처음이나 끝에 요소를 더하거나 뺄 때 사용한다. 이렇게 처음이나 끝에 요소를 더하거나 빼주는 연산을 제공하는 자료구조를 컴퓨터 과학 분야에서는 <strong>데큐(deque, Double Ended Queue)</strong>라고 부른다.

**`pop`과 `push`는 배열의 끝에 무언가를 해주는 메서드이다.**

`pop`: 배열의 끝 요소를 제거하고, 제거한 요소를 반환한다.
```js
let fruits = ['사과', '오렌지', '배'];

alert(fruits.pop()); // 배열에서 '배'를 제거하고 제거된 요소를 얼럿창에 띄운다.

alert(fruits); // 사과, 오렌지
```
`push`: 배열의 끝에 요소를 추가한다. 여러 개도 가능하다.
```js
let fruits = ['사과', '오렌지'];

fruits.push('배');

alert(fruits); // 사과, 오렌지, 배
```
`fruits.push(...)`를 사용하는 것은 `fruits[fruits.length] = ...` 코드와 동일할 기능을 한다.
<br></br>

**`shift`와 `unshift`는 배열의 앞에 무언가를 해주는 메서드이다.**

`shift`: 배열의 앞 요소를 제거하고, 제거한 요소를 반환한다.
```js
let fruits = ['사과', '오렌지', '배'];

alert(fruits.shift()); // 배열에서 '사과'를 제거하고 제거된 요소를 얼럿창에 띄운다.

alert(fruits); // 오렌지, 배
```
`unshift`: 배열의 앞에 요소를 추가한다. 여러 개도 가능하다.
```js run
let fruits = ['오렌지', '배'];

fruits.unshift('사과');

alert(fruits); // 사과, 오렌지, 배
```

## 배열의 내부 동작 원리
배열은 **특별한 종류의 객체**이며 객체처럼 동작한다.

배열은 객체와 마찬가지로 참조를 통해 복사된다.
```js
let fruits = ['바나나']
let arr = fruits; // 참조를 복사한다(두 변수가 같은 객체를 참조한다).

alert( arr === fruits ); // true
arr.push("배"); // 참조를 이용해 배열을 수정한다.
alert( fruits ); // 바나나, 배 - 요소가 두 개가 되었다.
```

배열에서 객체와 동일하게 `this`를 사용할 수 있다.
```js
let arr = ['a', 'b'];

arr.push(function() {
  alert(this);
})

arr[2](); // a,b,function(){...}
```

배열을 '순서가 있는 자료의 컬렉션’처럼 다루지 않고 '일반 객체'처럼 다루면 자바스크립트의 최적화 기법이 동작하지 않아 배열 특유의 이점이 사라진다. 잘못된 배열 사용법은 다음과 같다.
-   `arr.test = 5`  같이 숫자가 아닌 값을 프로퍼티 키로 사용하는 경우
-   `arr[0]`과  `arr[1000]`만 추가하고 그사이에 아무런 요소도 없는 경우
-   `arr[1000]`,  `arr[999]`같이 요소를 역순으로 채우는 경우

임의의 키를 사용해야 한다면 배열보다는 일반 객체 `{}`가 적합한 자료구조일 확률이 높다.

## 성능
`push`와 `pop`은 빠르지만 `shift`와 `unshift`는 느리다. `shift`와 `unshift`는 요소 전체를 이동시켜야 되기 때문이다.

## 반복문
`for`문은 배열을 순회할 때 쓰는 가장 오래된 방법이다. 순회할 때 인덱스를 사용한다. 가장 빠른 방법이며 오래된 브라우저와도 호환된다.
```js
let arr = ['사과', '오렌지', '배'];

for (let i = 0; i < arr.length; i++) {
  alert(arr[i]);
}
```
배열에 적용할 수 있는 또 다른 순회 문법으로는 `for..of`가 있다.
```js run
let fruits = ['사과', '오렌지', '자두'];

// 배열 요소를 대상으로 반복 작업을 수행한다.
for (let fruit of fruits) {
  alert(fruit);
}
```
`for..of`를 사용하면 현재 요소의 인덱스는 얻을 수 없고 값만 얻을 수 있다.`for..of`가 문법도 짧고 사용이 간편하기 때문에, 인덱스가 필요한 상황이 아니면 **`for..of`를 사용**하는 것을 권장한다.

배열은 객체형에 속하므로 `for..in`을 사용하는 것도 가능하다.
```js
let arr = ['사과', '오렌지', '배'];

for (let key in arr) {
  alert(arr[key]); // 사과, 오렌지, 배
}
```
그런데 `for..in`은 다음과 같은 특징을 지니기 때문에 **배열에 `for..in`을 사용해서는 안 된다.**
1. `for..in` 반복문은 '모든 프로퍼티'를 대상으로 순회합니다. 키가 숫자가 아닌 프로퍼티도 순회 대상에 포함된다.
	객체 중에는 배열과 유사한 형태를 보이는 ‘유사 배열(array-like)’ 객체가 존재한다. 유사 배열 객체에는 배열과 달리 키가 숫자형이 아닌 프로퍼티와 메서드가 있을 수 있다. `for..in`을 유사 배열 객체에 사용하면 이 모든 것을 대상으로 순회가 이뤄져서 ‘필요 없는’ 프로퍼티들이 문제를 일으킬 가능성이 생긴다.

2. `for..in`  반복문은 객체에 사용하는 것에 최적화되어 있어서 배열에 사용하면 객체 대비 10~100배 정도 느리다.

## length 프로퍼티
배열에 무언가 조작을 가하면 `length` 프로퍼티가 자동으로 갱신된다. 

`length` 프로퍼티는 배열 내 요소의 개수가 아니라 **가장 큰 인덱스에 1을 더한 값**이다. 따라서 배열에 요소가 하나만 있는데, 이 요소의 인덱스가 아주 큰 수라면 배열의 `length` 프로퍼티도 아주 커진다.
```js
let fruits = [];
fruits[123] = '사과';

alert(fruits.length); // 124
```
물론 배열을 이렇게 사용해서는 안 된다.

`length`  프로퍼티의 또 다른 독특한 특징은 **쓰기가 가능하다**는 것이다.

`length`의 값을 수동으로 증가시키면 아무 일도 일어나지 않는 반면, 값을 감소시키면 배열이 잘리는 것을 확인할 수 있다. 짧아진 배열은 다시 되돌릴 수 없다.
```js
let arr = [1, 2, 3, 4, 5];

arr.length = 2; // 요소를 2개만 남긴다.
alert(arr); // [1, 2]

arr.length = 5; // 원래 길이로 되돌린다.
alert(arr[3]); // undefined, 삭제된 기존 요소들이 복구되지 않는다.
```
이런 특징을 활용해 `arr.length = 0;`을 사용하면 아주 간단하게 배열을 비울 수 있다.

## new Array()
`new Array()` 문법을 사용해도 배열을 만들 수 있다.
```js
let arr = new Array('사과', '배', '기타');
```
대괄호 `[]`를 사용하면 더 짧은 문법으로 배열을 만들 수 있기 때문에 `new Array()`는 잘 사용되지 않는다.

숫자형 인수 하나를 넣어서 `new Array`를 호출하면 배열이 만들어지는데, 이 배열에는 요소가 없는 반면 길이는 인수와 같아진다.
```js
let arr = new Array(2);

alert( arr[0] ); // undefined가 출력된다. 요소가 하나도 없는 배열이 만들어졌다.
alert( arr.length ); // 길이는 2이다.
```
이런 뜻밖의 상황을 마주치지 않기 위해 `new Array`의 기능을 잘 알지 않는 한 대부분의 개발자는 대괄호를 써서 배열을 만든다.

## 다차원 배열
배열 역시 배열의 요소가 될 수 있다. 이런 배열을 가리켜 다차원 배열(multidimensional array)이라 부른다. 다차원 배열은 행렬을 저장하는 용도로 쓰인다.
```js
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert(matrix[1][1]); // 5
```

## toString
배열에는 `toString` 메서드가 구현되어 있어서 이를 사용하면 요소를 쉼표로 구분한 문자열이 반환된다. 쉼표 뒤에 빈 칸이 없는 것을 주의해야 한다.
```js run
let arr = [1, 2, 3];

alert(arr); // 1,2,3
alert(String(arr) === '1,2,3'); // true
```
배열에는 `Symbol.toPrimitive`나 `valueOf` 메서드가 없다. 따라서 아래 예시에서는 문자열로의 형 변환이 일어나 `[]`는 빈 문자열, `[1]`은 문자열 `'1'`, `[1,2]`는 문자열 `'1,2'`로 변환된다.
```js
alert([] + 1); // '1'
alert([1] + 1); // '11'
alert([1,2] + 1); // '1,21'
```
<br></br>
# 05. 배열과 메서드
##  요소 추가·제거 메서드
###  splice
배열에 연산자 `delete`를 사용하면 빈 공간이 생긴다.
```js
let arr = ['I', 'go', 'home'];

delete arr[1]; // 'go'를 삭제한다.

alert(arr[1]); // undefined

// delete를 써서 요소를 지우고 난 후의 배열 -> arr = ['I', , 'home'];
alert(arr.length); // 3
```

빈 공간 없이 요소를 지우려면 [arr.splice(start)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)를 사용한다. 이 메서드를 사용하면 요소의 추가, 삭제, 교체가 모두 가능하다.
```js
arr.splice(index, [deleteCount], [elem1, ..., elemN])
```
첫 번째 매개변수는 조작을 가할 첫 번째 요소를 가리키는 `인덱스(index)`이다. 두 번째 매개변수는 `deleteCount`로, 제거하고자 하는 요소의 개수를 나타낸다. `elem1, ..., elemN`은 배열에 추가할 요소를 나타낸다.

`splice`는 삭제된 요소로 구성된 배열을 반환한다.

다음은 `splice` 메서드를 사용한 예시들이다.
```js
let arr = ['I', 'study', 'JavaScript'];

arr.splice(1, 1); // 인덱스 1부터 요소 한 개를 제거한다.

alert(arr); // ['I', 'JavaScript']
```
```js
let arr = ['I', 'study', 'JavaScript', 'right', 'now'];

// 처음(0) 세 개(3)의 요소를 지우고, 이 자리를 다른 요소로 대체한다.
arr.splice(0, 3, "Let's", 'dance');

alert(arr) // now ["Let's", 'dance', 'right', 'now']
```
```js
let arr = ['I', 'study', 'JavaScript', 'right', 'now'];

// 처음 두 개의 요소를 삭제한다.
let removed = arr.splice(0, 2);

alert(removed); // "I", "study" <- 삭제된 요소로 구성된 배열이다.
```
인자 `deleteCount`를 `0`으로 설정하면 요소를 제거하지 않으면서 새로운 요소를 추가할 수 있다.
```js
let arr = ['I', 'study', 'JavaScript'];

// 인덱스 2부터 0개의 요소를 삭제한다.
// 그 후, "complex"와 "language"를 추가한다.
arr.splice(2, 0, 'complex', 'language');

alert(arr); // 'I', 'study', 'complex', 'language', 'JavaScript'
```

---
:information_source: **음수 인덱스도 사용할 수 있다.**

배열 관련 메소드에는 음수 인덱스를 사용할 수 있다. 음수 인덱스는 배열 끝에서부터의 위치를 가리킨다.
```js run
let arr = [1, 2, 5];

// 인덱스 -1부터 0개의 요소를 삭제하고, 3과 4를 추가한다.
arr.splice(-1, 0, 3, 4);

alert(arr); // 1,2,3,4,5
```
---

### slice
[arr.slice](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)는 `arr.splice`와 유사하지만 훨씬 간단하다.
```js
arr.slice([start], [end])
```
이 메서드는 `"start"` 인덱스부터 `"end"`인덱스 전까지의 요소를 복사한 새로운 배열을 반환합니다. `start`와 `end`는 둘 다 음수가 가능하다.
```js
let arr = ['t', 'e', 's', 't'];

alert(arr.slice(1, 3)); // e,s
alert(arr.slice(-2)); // s,t
```
`arr.slice()`와 같이 인수를 하나도 넣지 않으면 `arr`의 복사본을 만들 수 있다. `arr.slice()`는 기존의 배열을 건드리지 않으면서, 추가 변환을 위한 복사본을 얻기 위해 자주 사용된다.

### concat
[arr.concat](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)은 **기존 배열의 요소를 사용해 새로운 배열을 만들거나 기존 배열에 요소를 추가**할 때 사용할 수 있다.
```js
arr.concat(arg1, arg2...)
```
인수에는 배열이나 값이 올 수 있으며 인수 개수에는 제한이 없다.

메서드를 호출하면  `arr`에 속한 모든 요소와  `arg1`,  `arg2`  등에 속한 모든 요소를 한데 모은 새로운 배열이 반환된다.
```js
let arr = [1, 2];

alert(arr.concat([3, 4])); // 1,2,3,4
alert(arr.concat([3, 4], [5, 6])); // 1,2,3,4,5,6
alert(arr.concat([3, 4], 5, 6)); // 1,2,3,4,5,6
```
인자로 객체를 넣으면 객체가 그대로 복사된다.
```js
let arr = [1, 2];

let arrayLike = {
  0: 'something',
  length: 1
};

alert(arr.concat(arrayLike)); // 1,2,[object Object]
```
그런데 인자로 받은 유사 배열 객체에 특수한 프로퍼티 `Symbol.isConcatSpreadable`이 있으면 `concat`은 이 객체를 배열처럼 취급한다.
```js
let arr = [1, 2];

let arrayLike = {
  0: 'something',
  1: 'else',
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert(arr.concat(arrayLike)); // 1,2,something,else
```

## forEach로 반복작업 하기
[arr.forEach](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)는 **주어진 함수를 배열의 각 요소에서 호출한다.**
```js
arr.forEach(function(item, [index], [array]) {
  // 요소에 무언가를 할 수 있다.
});
```
```js
// 각 요소마다 얼럿을 호출한다.
['Bilbo', 'Gandalf', 'Nazgul'].forEach(alert);
```
```js
['Bilbo', 'Gandalf', 'Nazgul'].forEach((item, index, array) => {
  alert(`${item} is at index ${index} in ${array}`);
});
```
인수로 넣은 함수의 반환값은 무시된다.

## 배열 탐색하기
### indexOf/lastIndexOf, includes
[arr.indexOf](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)/[arr.lastIndexOf](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf), [arr.includes](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)는 같은 이름을 가진 문자열 메서드와 사용법이 동일하다. 연산 대상이 문자열이 아닌 배열의 요소라는 점만 다르다.
-   `arr.indexOf(item, from)`는 인덱스  `from`부터 시작해서  `item(요소)`을 찾는다. `item`를 찾으면 해당 요소의 인덱스를 반환하고, 찾지 못하면  `-1`을 반환한다.
-   `arr.lastIndexOf(item, from)`는 배열의 끝에서부터 찾는다.
-   `arr.includes(item, from)`는 인덱스  `from`부터 시작해  `item`이 있는지를 찾고, `item`를 찾으면  `true`를 반환한다.
```js
let arr = [1, 0, false];

alert(arr.indexOf(0)); // 1
alert(arr.indexOf(false)); // 2, '==='을 사용하기 때문에 요소 0은 지나가고 2가 출력된다.
alert(arr.indexOf(null)); // -1

alert(arr.includes(1)); // true
```
위 메서드들은 요소를 찾을 때 완전 항등 연산자 `===` 을 사용한다는 점을 주의해야 한다.

요소가 배열 내에 존재하는지만 확인하고 싶다면 `arr.includes`를 사용하는 것이 좋다. `includes`는 `NaN`도 제대로 찾는다는 점에서 `indexOf/lastIndexOf`와 약간의 차이가 있다.
```js
const arr = [NaN];
alert(arr.indexOf(NaN)); // -1, '==='는 NaN에 동작하지 않으므로 -1이 출력된다.
alert( arr.includes(NaN) );// true, NaN을 찾았다.
```

### find와 findIndex
[arr.find(fn)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/find)는 배열 내에서 **특정 조건에 부합하는 객체를 찾을 때** 사용한다. 실무에서 객체로 구성된 배열을 자주 다룬다.
```js
let result = arr.find(function(item, [index], [array]]) {
  // 함수의 결과가 true이면 반복을 멈추고 해당 요소를 반환한다.
  // 조건에 해당하는 요소가 없으면 undefined를 반환한다.
});
```
요소 전체를 대상으로 함수가 순차적으로 호출된다.
-   `item`  – 함수를 호출할 요소
-   `index`  – 요소의 인덱스
-   `array`  – 배열 자기 자신
```js
let users = [
  {id: 1, name: 'John'},
  {id: 2, name: 'Pete'},
  {id: 3, name: 'Mary'}
];

let user = users.find(item => item.id == 1);

alert(user.name); // John
```
위 예시와 같이 `find` 안의 함수에 인자가 하나만 있는 패턴을 가장 많이 사용한다. 다른 인자들(`index`, `array`)은 잘 사용되지 않는다.

[arr.findIndex](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex)는 조건에 맞는 요소를 반환하는 대신 **해당 요소의 인덱스를 반환한다.** 조건에 맞는 요소가 없으면 `-1`을 반환한다.

### filter
[arr.filter(fn)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)는 **조건을 충족하는 요소를 여러 개 찾고 싶을 때** 사용한다.
```js
let results = arr.filter(function(item, index, array) {
  // 조건을 충족하는 요소들이 들어있는 배열을 반환한다.
  // 조건을 충족하는 요소가 하나도 없으면 빈 배열을 반환한다.
});
```
```js
let users = [
  {id: 1, name: 'John'},
  {id: 2, name: 'Pete'},
  {id: 3, name: 'Mary'}
];

// id가 1, 2인 객체가 들어있는 배열을 반환한다.
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
```

## 배열을 변형하는 메서드
### map
[arr.map](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/map)은 **배열의 각 요소를 대상으로 함수를 호출하고, 그 결과들을 배열로 반환한다.** `map`은 유용성과 사용 빈도가 아주 높은 메서드 중 하나이다.
```js
let result = arr.map(function(item, index, array) {
  // 요소를 변환한 값들이 들어있는 배열을 반환한다.
});
```
```js
let lengths = ['Bilbo', 'Gandalf', 'Nazgul'].map(item => item.length);
alert(lengths); // 5,7,6
```

### sort(fn)
[arr.sort()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)는 **배열의 요소를 정렬해준다.**

메서드는 정렬된 배열을 반환하는데, 이미  `arr`  자체가 수정되었기 때문에 반환 값은 잘 사용하지 않는다.
```js
let arr = [1, 2, 15];

// arr 내부가 재정렬된다.
arr.sort();

alert( arr );  // 1, 15, 2
```
위 예시를 보면 **요소가 문자형으로 변환된 후 정렬**된 것을 알 수 있다.

기본 정렬 기준 대신에 새로운 정렬 기준을 적용하려면 `arr.sort()`에 인수로 새로운 함수를 넣어줘야 한다. 인수로 넣어주는 함수는 반드시 값 두 개를 비교해야 하고 반환 값도 있어야 한다.
```js
function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [1, 2, 15];

arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15
```

---
:information_source: **정렬 함수는 어떤 숫자든 반환할 수 있다.**

정렬 함수의 반환 값에는 제약이 없다. 첫 번째 인수가 두 번째 인수보다 크면 양수를 반환하고, 첫 번째 인수가 두 번째 인수보다 작으면 음수를 반환하면 된다.

이 점을 이용하면 다음과 같이 정렬 함수를 더 간결하게 만들 수 있다.
```js
let arr = [1, 2, 15];

arr.sort(function(a, b) {return a - b;});

alert(arr);  // 1, 2, 15
```
---
:information_source: **화살표 함수를 사용하면 정렬 함수가 더 깔끔해진다.**

```js
arr.sort((a, b) => a - b);
```
---
:information_source: **문자열에는 `localeCompare`를 사용한다.**

`localeCompare`는 유니코드를 기준으로 글자를 비교한다. `Ö` 같은 문자가 있는 언어에도 대응할 수 있다.
```js
let countries = ['Österreich', 'Andorra', 'Vietnam'];

alert(countries.sort((a, b) => a > b ? 1 : -1)); // Andorra, Vietnam, Österreich -> 제대로 정렬되지 않았다.
alert(countries.sort((a, b) => a.localeCompare(b))); // Andorra,Österreich,Vietnam -> 제대로 정렬되었다.
```
### reverse
[arr.reverse](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)는 `arr`의 요소를 **역순으로 정렬한다.** 반환 값은 역순으로 정렬된 배열이다.
```js
let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert(arr); // 5,4,3,2,1
```
### split과 join
[str.split(delim)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/split)은 구분자(delimiter) `delim`을 기준으로 문자열을 나눠서 배열에 저장한다.
```js
let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(', ');

for (let name of arr) {
  alert(`${name}에게 보내는 메시지`); // Bilbo에게 보내는 메시지
}
```
`split` 메서드는 두 번째 인수로 숫자를 받을 수 있다. 이 숫자는 배열의 길이를 제한해주며 길이를 넘어서는 요소를 무시할 수 있다. 실무에서 자주 사용하는 기능은 아니다.
```js
let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);

alert(arr); // Bilbo, Gandalf
```
---
:information_source: **문자열을 글자 단위로 분리하기**

`split(delim)`의 `delim`을 빈 문자열로 지정하면 문자열을 글자 단위로 분리할 수 있다.
```js
let str = 'test';

alert(str.split('')); // t,e,s,t
```
---

[arr.join(glue)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/join)은 `split`과 반대 역할을 하는 메서드이다. 인수 `glue`를 접착제처럼 사용해서 배열 요소를 모두 합친 하나의 문자열을 만들어준다.
```js
let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';'); // 배열 요소들을 ;를 사용해 하나의 문자열로 합친다.

alert(str); // Bilbo;Gandalf;Nazgul
```

### reduce/reduceRight
`reduce`와 `reduceRight`는 **배열을 기반으로 값 하나를 도출**할 때 사용된다.
```js
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
```
인수로 넘겨주는 함수는 배열의 모든 요소를 대상으로 차례로 적용되는데, 적용 결과는 다음 함수 호출 시 사용된다.

함수의 인수는 다음과 같다.
-   `accumulator`: 이전 함수 호출 결과이다.  `initial`은 함수 최초 호출 시 사용되는 초깃값을 나타내며 생략할 수 있다.
-   `item`: 현재 배열 요소
-   `index`: 요소의 위치
-   `array`: 배열

이전 함수 호출 결과는 다음 함수를 호출할 때 첫 번째 인수(`previousValue`)로 사용된다. 첫 번째 인수는 앞서 호출했던 함수들의 결과가 누적되어 저장되는 '누산기(accumulator)' 역할을 한다. 마지막 함수까지 호출되면 이 값은 `reduce` 메서드의 반환 값이 된다.

```js
let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
```
보통은 이렇게 인수를 두 개만 사용한다.

초깃값을 생략할 경우, 배열이 비어있는 상태면 에러가 발생한다.
```js
let arr = [];

// TypeError: Reduce of empty array with no initial value
// 초깃값을 설정해 주었다면 초깃값이 반환되었을 것이다.
arr.reduce((sum, current) => sum + current);
```
이런 예외상황 때문에 **항상 초깃값을 명시**해 줄 것을 권장한다.

[arr.reduceRight](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight)는  `reduce`와 동일한 기능을 하지만 배열의 오른쪽부터 연산을 수행한다.

## Array.isArray로 배열 여부 알아내기
자바스크립트에서 배열은 독립된 자료형으로 취급되지 않고 객체형에 속한다. 따라서  `typeof`로는 일반 객체와 배열을 구분할 수 없다.
```js
alert(typeof {}); // object
alert(typeof []); // object
```

[Array.isArray(value)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)를 사용하면 구별이 가능하다. `value`가 배열이면 `true`를, 배열이 아니면 `false`를 반환한다.
```js
alert(Array.isArray({})); // false
alert(Array.isArray([])); // true
```

## 배열 메서드와 'thisArg'
함수를 호출하는 대부분의 배열 메서드(`sort` 제외)는 `thisArg`라는 매개변수를 옵션으로 받을 수 있다.
```js
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg는 선택적으로 사용할 수 있는 마지막 인수이다.
```
**`thisArg`는 `func`의 `this`가 된다.**
```js run
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// army.canJoin 호출 시 참을 반환해주는 user를 찾는다.
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
```
`thisArgs`에  `army`를 지정하지 않고 단순히  `users.filter(army.canJoin)`를 사용했다면  `army.canJoin`은 단독 함수처럼 취급되고, 함수 본문 내  `this`는  `undefined`가 되어 에러가 발생했을 것이다.

`users.filter(user => army.canJoin(user))`를 사용해도 같은 결과가 나오지만  `thisArg`를 사용하는 방식이 이해하기 쉬우므로 더 많이 사용된다.

## 기타 배열 메서드
-   [arr.some(fn)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/some)과  [arr.every(fn)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/every)는 배열의 요소들에 대해 검사를 실시한다.
    
    두 메서드는  `map`과 유사하게 모든 요소를 대상으로 함수를 호출한다.  `some`은 함수의 반환 값을  `true`로 만드는 요소가 하나라도 있는지 여부를 확인하고,  `every`는 모든 요소가 함수의 반환 값을  `true`로 만드는지 여부를 확인한다. 두 메서드 모두 조건을 충족하면  `true`를, 그렇지 않으면  `false`를 반환한다.

-   [arr.fill(value, start, end)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)은  `start`부터  `end`까지  `value`를 채워 넣는다.
    
-   [arr.copyWithin(target, start, end)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)은  `start`부터  `end`까지 요소를 복사하고, 복사한 요소를  `target`에 붙여 넣는다. 기존 요소가 있다면 덮어씌운다.

배열에 관한 모든 메서드는 [MDN 문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array)에서 찾아볼 수 있다.

## 요약
-   요소를 더하거나 지우기
    
    -   `push(...items)`: 맨 끝에 요소 추가하기
    -   `pop()`: 맨 끝 요소 추출하기
    -   `shift()`: 첫 요소 추출하기
    -   `unshift(...items)`: 맨 앞에 요소 추가하기
    -   `splice(pos, deleteCount, ...items)`: `pos`부터  `deleteCount`개의 요소를 지우고,  `items`  추가하기
    -   `slice(start, end)`: `start`부터  `end`  바로 앞까지의 요소를 복사해 새로운 배열을 만듦
    -   `concat(...items)`: 배열의 모든 요소를 복사하고  `items`를 추가해 새로운 배열을 만든 후 이를 반환함.  `items`가 배열이면 이 배열의 인수를 기존 배열에 더해줌
-   원하는 요소 찾기
    
    -   `indexOf/lastIndexOf(item, pos)`: `pos`부터 원하는  `item`을 찾음. 찾게 되면 해당 요소의 인덱스를, 아니면  `-1`을 반환함
    -   `includes(value)`: 배열에  `value`가 있으면  `true`를, 그렇지 않으면  `false`를 반환함
    -   `find/filter(func)`: `func`의 반환 값을  `true`로 만드는 첫 번째/전체 요소를 반환함
    -   `findIndex`는  `find`와 유사함. 다만 요소 대신 인덱스를 반환함
-   배열 전체 순회하기
    
    -   `forEach(func)`: 모든 요소에  `func`을 호출함. 결과는 반환되지 않음
-   배열 변형하기
    
    -   `map(func)`: 모든 요소에  `func`을 호출하고, 반환된 결과를 가지고 새로운 배열을 만듦
    -   `sort(func)`: 배열을 정렬하고 정렬된 배열을 반환함
    -   `reverse()`: 배열을 뒤집어 반환함
    -   `split/join`: 문자열을 배열로, 배열을 문자열로 변환함
    -   `reduce(func, initial)`: 요소를 차례로 돌면서  `func`을 호출함. 반환값은 다음 함수 호출에 전달함. 최종적으로 하나의 값이 도출됨
-   기타
    
    -   `Array.isArray(arr)`  –  `arr`이 배열인지 여부를 판단함

`sort`,  `reverse`,  `splice`는 기존 배열을 변형시킨다는 점을 주의해야 한다.
<br></br>
