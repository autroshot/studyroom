# 01. 원시값의 메서드
## 원시값을 객체처럼 사용하기
원시값이 메서드나 프로퍼티에 접근하려 하면 추가 기능을 제공해주는 특수한 객체, <strong>원시 래퍼 객체(object wrapper)</strong>를 만들어준다. 이 객체는 사용이 끝나면 바로 삭제된다.

자바스크립트 엔진은 원시 래퍼 객체를 만들지 않고도 마치 원시 래퍼 객체를 생성한 것처럼 동작하게 해준다.

---
:information_source: `String/Number/Boolean`를 생성자로 사용해서는 안 된다.

Java 등의 몇몇 언어에선 `new Number(1)` 또는 `new Boolean(false)`와 같은 문법을 사용해 원하는 타입의 "래퍼 객체"를 직접 만들 수 있다. 자바스크립트에서는 이런 식으로 `new`를 이용해 래퍼 객체를 만드는 것을 **추천하지 않는다**.

---
:warning: `null/undefined`는 메서드가 없다.

특수 자료형인 `null`과 `undefined`와 연관되는 "래퍼 객체"도 없고 메서드도 제공하지 않는다.

---

# 02. 숫자형
## 숫자를 입력하는 다양한 방법
큰 숫자나 작은 숫자를 나타낼 때는 과학적 표기법을 이용한다. 자바스크립트에서는 숫자 옆에 `e`를 붙이고 원하는 0의 개수를 그 옆에 붙여주면 된다.
```js
let billion = 1e9;  // 10억, 1과 9개의 0
alert(7.3e9);  // 73억(7,300,000,000)

let ms =  1e-6;  // 0이 6개인 소수이다.
```

### 16진수, 2진수, 8진수
16진수는 `0x`를 사용해 표현할 수 있다.
```js
alert(0xff); // 255
alert(0xFF); // 255(대·소문자를 가리지 않으므로 둘 다 같은 값을 나타낸다)
```
2진수와 `0b`를, 8진수는 `0o`를 사용해 나타낼 수 있다.
```js
let a = 0b11111111; // 255의 2진수
let b = 0o377; // 255의 8진수

alert(a == b); // true, a와 b는 같은 수이다.
```
자바스크립트에서 지원하는 진법은 앞의 3개이다. 이 외의 진법을 사용하려면 함수 `parseInt`를 사용해야 한다.

## toString(base)
`num.toString(base)` 메서드는 `base`진법으로 `num`을 표현한 후, 이를 문자형으로 변환해 반환한다.
```js
let num = 255;

alert(num.toString(16));  // ff
alert(num.toString(2));   // 11111111
```
`base`는 기본값이 `10`이며, `2`부터 `36`까지 넣을 수 있다. `base`별 유스 케이스는 다음과 같다.

### base=16
16진수 색, 문자 인코딩 등을 표현할 때 사용한다. 숫자는 `0`부터 `9`, 10 이상의 수는 `A`부터 `F`를 사용하여 나타낸다.

### base=2
비트 연산 디버깅에 주로 쓰인다. 숫자는  `0` 또는 `1`이 될 수 있습니다.

### base=36
사용할 수 있는 `base` 중 최댓값으로, `0..9`와 `A..Z`를 사용해 숫자를 표현한다. 알파벳 전체가 숫자를 나타내는 데 사용된다.  `36` 베이스는 url을 줄이는 것과 같이 숫자로 된 긴 식별자를 짧게 줄일 때 유용하다.
```js run
alert(123456..toString(36)); // 2n9c
```

---
:warning: 점 두 개와 메서드 호출

위 예시처럼 숫자를 대상으로 메서드  `toString`을 직접 호출하고 싶다면 숫자 다음에 점 두 개  `..`를 붙여야 한다.

`123456.toString(36)`처럼 점을 한 개만 사용하면, 첫 번째 점 이후는 소수부로 인식되어 에러가 발생할 수 있다. 점을 하나 더 추가하면 자바스크립트는 소수부가 없다고 판단하고 함수를 호출한다.

`(123456).toString(36)`도 가능하다.

---

## 어림수 구하기
<strong>어림수(rounding)</strong>와 관련된 내장 함수 중에서 많이 사용되는 것은 다음과 같다.
- `Math.ceil`: 올림
- `Math.floor`: 내림
- `Math.round`: 반올림
- `Math.trunc`: 소수부를 무시한다. **Internet Explorer**에서는 지원하지 않는 기능이다.

각 내장 함수의 결과를 표로 정리하면 다음과 같다.
|      |`Math.ceil`|`Math.floor`|`Math.round`|`Math.trunc`|
|------|------------|-----------|------------|------------|
|`3.1` |`4`         |`3`        |`3`         |`3`         |
|`3.6` |`4`         |`3`        |`4`         |`3`         |
|`-1.1`|`-1`        |`-2`       |`-1`        |`-1`        |
|`-1.6`|`-1`        |`-2`       |`-2`        |`-1`        |

소수점 `n`번째 수를 기준으로 어림수를 구하고 싶을 때 사용할 수 있는 방법은 두 가지가 있다.
### 1. 곱하기와 나누기
```js run
let num = 1.23456;

alert(Math.floor(num * 100) / 100); // 1.23456 -> 123.456 -> 123 -> 1.23
```

### 2. 소수점 `n` 번째 수까지의 **반올림**을 구한 후 이를 **문자형**으로 반환해주는 메서드인 [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)를 사용한다.
```js
let num = 12.36;
alert(num.toFixed(1)); // '12.4'
```
`toFixed`를 사용할 때 주의할 점은 이 메서드의 반환 값이 문자열이라는 것이다. 소수부의 길이가 인수보다 작으면 끝에 0이 추가된다.
```js
let num = 12.34;
alert(num.toFixed(5)); // '12.34000', 소수부의 길이가 5이기 때문에 남은 공간에는 0이 추가되었다.
```
참고로, `+num.toFixed(5)`처럼 단항 덧셈 연산자를 앞에 붙이거나 `Number()`를 이용하면 문자형의 숫자를 숫자형으로 변환할 수 있다.

## 부정확한 계산
숫자는 내부적으로 64비트 형식 IEEE-754으로 표현되기 때문에 숫자를 저장하려면 정확히 64비트가 필요하다. 64비트 중 52비트는 숫자를 저장하는 데 사용되고, 11비트는 소수점 위치를(정수는 0), 1비트는 부호를 저장하는 데 사용된다.

꽤 자주 발생하는 현상인 정밀도 손실(loss of precision)이라는 것이 있다.
```js
alert(0.1 + 0.2 == 0.3); // false
alert(0.1 + 0.2); // 0.30000000000000004
```
10진법에서 1/3을 정확히 나타낼 수 없듯이, 2진법을 사용하는 컴퓨터에서는 0.1 또는 0.2를 **정확하게** 저장할 수 없다. IEEE-754에서는 가능한 가장 가까운 숫자로 반올림하는 방법을 사용해 이런 문제를 해결한다. 그런데 반올림 규칙을 적용하면 발생하는 '작은 정밀도 손실’을 우리가 볼 수는 없지만 실제로 손실은 발생한다.
```js run
alert(0.1.toFixed(20)); // 0.10000000000000000555
```
이 문제를 해결하는 가장 신뢰할만한 방법은 toFixed(n) 메서드를 사용해 어림수를 만드는 것이다.
```js
let sum = 0.1 + 0.2;
alert(sum.toFixed(2)); // 0.30
alert(+sum.toFixed(2)); // 0.3
```
숫자에 임시로 10의 거듭제곱을 곱하여 정수로 바꾸고, 원하는 연산을 한 후 다시 곱했던 수로 나누는 것도 하나의 방법이 될 수 있다. 정수를 대상으로 하는 수학 연산은 소수를 대상으로 하는 연산보다 에러가 적기 때문이다. 그런데 어쨌든 마지막에 나눗셈이 들어가기 때문에 소수가 다시 등장할 수 있다는 단점이 있다.
```js
alert((0.1 * 10 + 0.2 * 10) / 10); // 0.3
alert((0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
```
무한소수를 방지하는 완벽한 방법은 사실 없다. 필요할 때마다 '꼬리’를 잘라 어림수를 만드는 방법뿐이다.

---
:information_source: 정밀도 손실로 생기는 흥미로운 현상
```js
// 숫자가 스스로 증가했다.
alert(9999999999999999); // 10000000000000000이 출력된다.
```
문제의 원인은 정밀도 손실 때문이다. 실제 숫자를 저장하는 데에 사용되는 52비트에 위 숫자를 저장하기에는 공간이 모자라다. 따라서 최소 유효 숫자(the least significant digit)가 손실되어 버렸다.

---
:information_source: 두 종류의 0

자바스크립트 내부에서 숫자를 표현하는 방식 때문에 발생하는 또 다른 흥미로운 현상은  `0`과  `-0`이라는 두 종류의 0이 존재한다는 사실이다.

자바스크립트에선 숫자의 부호가 단일 비트에 저장되는데 0을 포함한 모든 숫자에 부호를 설정할 수도, 설정하지 않을 수도 있기 때문이다.

대부분의 연산은  `0`과  `-0`을 동일하게 취급하기 때문에 두 0의 차이는 두드러지지 않는다.

---

## isNaN과 isFinite
숫자형의 특수 숫자 값은 두 가지가 있다.
-   `Infinity`와  `-Infinity`
-   `NaN`: 에러를 나타내는 값이다.

특수 숫자와 관련된 특별한 함수는 다음과 같다.

### isNaN(value)
인수를 숫자로 변환한 다음 `NaN`인지 테스트한다.
```js
alert(isNaN(NaN)); // true
alert(isNaN('str')); // true
```
`NaN`은 `NaN` 자기 자신을 포함하여 그 어떤 값과도 같지 않다는 점에서 독특하다. 자기 자신에 대한 `===`도 `false`를 반환한다. 따라서 `NaN`을 판별할 때는 `isNaN` 함수를 사용해야 한다.
```js
alert(NaN === NaN); // false
```

### isFinite(value)
인수를 숫자로 변환하고, 변환한 숫자가 `NaN/Infinity/-Infinity`가 아닌 일반 숫자인 경우 `true`를 반환한다.
```js
alert(isFinite('15')); // true
alert(isFinite('str')); // false, NaN이기 때문이다.
alert(isFinite(Infinity)); // false, Infinity이기 때문이다.
```
`isFinite`는 문자열이 일반 숫자인지 검증하는 데 사용되곤 한다.
```js
let num = +prompt('숫자를 입력하세요.', '');

// 숫자가 아닌 값을 입력하거나 Infinity, -Infinity를 입력하면 false가 출력된다.
alert(isFinite(num));
```
빈 문자열이나 공백만 있는 문자열은 `isFinite`를 포함한 모든 숫자 관련 내장 함수에서 `0`으로 취급된다는 점을 주의해야 한다.

---
:information_source: `Object.is`와 비교하기

[`Object.is`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/is)는  `===`처럼 값을 비교할 때 사용되는 특별한 내장 메서드이다. 아래와 같은 두 가지 에지 케이스에서는  `===`보다 좀 더 신뢰할 만한 결과를 보여준다.

1.  `NaN`을 대상으로 비교할 때:  `Object.is(NaN, NaN) === true`
2.  `0`과  `-0`이 다르게 취급되어야 할 때:  `Object.is(0, -0) === false`이다. 숫자를 나타내는 비트가 모두 0이더라도 부호를 나타내는 비트가 다르므로  `0`과  `-0`은 사실 다른 값이긴 하다.

앞의 두 에지 케이스를 제외하면 `Object.is(a, b)`와  `a === b`의 결과는 같다.

이런 식의 비교는 자바스크립트 명세서에서 종종 찾아볼 수 있다. 내부 알고리즘에서 두 값을 비교해야 하는데, 비교 결과가 정확해야 하는 경우  `Object.is`를 사용한다. `Object.is`에서 사용되는 비교방식은 명세서에서  SameValue라고 부른다.

---

## parseInt와 parseFloat
단항 덧셈 연산자 `+` 또는 `Number()`를 사용하여 숫자형으로 변형할 때는 피연산자가 숫자가 아니면 형 변환이 실패한다.
```js
alert(+'100px'); // NaN
```

내장 함수 `parseInt`와 `parseFloat`은 앞에서부터 불가능할 때까지 문자열에서 숫자를 ‘읽는다'. 숫자를 읽는 도중 오류가 발생하면 이미 수집된 숫자를 반환한다. `parseInt`는 정수, `parseFloat`는 부동 소수점 숫자를 반환한다. 두 함수는 '약한' 형 변환을 해준다.
```js
alert(parseInt('100px')); // 100
alert(parseFloat('12.5em')); // 12.5

alert(parseInt('12.3')); // 12, 정수 부분만 반환된다.
alert(parseFloat('12.3.4')); // 12.3, 두 번째 점에서 숫자 읽기를 멈춘다.
```
```js
alert(parseInt('a123')); // NaN, a는 숫자가 아니므로 숫자를 읽기가 바로 중단된다.
```

---
:information_source: `parseInt(str, radix)`의 두 번째 인수

`parseInt()`의 두 번째 매개 변수는 선택적으로 사용할 수 있다. `radix`는 원하는 16진수, 2진수 등의 진수를 지정해 줄 때 사용한다.
```js
alert(parseInt('0xff', 16)); // 255
alert(parseInt('ff', 16)); // 255, 0x가 없어도 동작한다.

alert(parseInt('2n9c', 36)); // 123456
```
---

## 기타 수학 메서드
자바스크립트에서 제공하는 내장 객체 Math에는 다양한 수학 관련 메서드와 상수들이 들어있다.

### Math.random()
0 이상 1 미만의 난수를 반환한다.
```js
alert(Math.random()); // 0.1234567894322
alert(Math.random()); // 0.5435252343232
alert(Math.random()); // ... (무작위 수)
```

### Math.max(a, b, c...), Math.min(a, b, c...)
인수 중 최댓값/최솟값을 반환한다.
```js
alert(Math.max(3, 5, -10, 0, 1)); // 5
alert(Math.min(1, 2)); // 1
```

### Math.pow(n, power)
`n`을 `power`번 거듭제곱한 값을 반환한다.
```js
alert(Math.pow(2, 10)); // 2의 10제곱 = 1024
```

이 외의 다양한 함수와 상수는 [MDN 문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Math)를 참고한다.
<br></br>
# 03. 문자열
자바스크립트에서 문자열은 페이지 인코딩 방식과 상관없이 항상 UTF-16(16-bit Unicode Transformation Format) 형식을 따른다.

## 따옴표
문자열은 작은따옴표나 큰따옴표, 백틱으로 감쌀 수 있다.
```js
let single = '작은따옴표';
let double = "큰따옴표";

let backticks = `백틱`;
```

작은따옴표와 큰따옴표는 기능상 차이가 없다. 그런데 백틱에는 특별한 기능이 있다. 표현식을 `${…}`로 감싸고 이를 백틱으로 감싼 문자열 중간에 넣어줄 수 있다. 이런 방식을 <strong>템플릿 리터럴(template literal)</strong>이라고 부른다.
```js
function sum(a, b) {
  return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}`); // 1 + 2 = 3
```
백틱을 사용하면 문자열을 여러 줄에 걸쳐 작성할 수 있다.
```js
let guestList = `손님:
 * John
 * Pete
 * Mary
`;

alert(guestList); // 손님 리스트를 여러 줄에 걸쳐 출력한다.
```
작은따옴표나 큰따옴표를 이용해 위와 같은 코드를 작성하면 에러가 발생한다.

백틱은 '템플릿 함수(template function)'에서도 사용된다. <code>func&#96;string&#96;</code> 같이 첫 번째 백틱 바로 앞에 함수 이름(`func`)을 써주면, 이 함수는 백틱 안의 문자열 조각이나 표현식 평가 결과를 인수로 받아 자동으로 호출된다. 이런 기능을 '태그드 템플릿(tagged template)'이라 부르는데, 태그드 템플릿을 사용하면 사용자 지정 템플릿에 맞는 문자열을 쉽게 만들 수 있다. 태그드 템플릿과 템플릿 함수에 대한 자세한 내용은 [MDN 문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Template_literals#Tagged_templates)에서 확인할 수 있다. 참고로 이 기능은 자주 사용되진 않는다.

## 특수 기호
'줄 바꿈 문자(newline character)'라 불리는 특수기호 `\n`을 사용하면 작은따옴표나 큰따옴표로도 여러 줄 문자열을 만들 수 있다.
```js
let guestList = '손님:\n * John\n * Pete\n * Mary';

alert(guestList); // 손님 리스트를 여러 줄에 걸쳐 출력한다.
```
따옴표를 이용해 만든 여러 줄 문자열과 백틱을 이용해 만든 여러 줄 문자열은 표현 방식만 다를 뿐 차이가 없다.
```js
let str1 = 'Hello\nWorld'; // '줄 바꿈 기호'를 사용해 두 줄짜리 문자열을 만들었다.

// 백틱과 일반적인 줄 바꿈 방법(엔터)을 사용해 두 줄짜리 문자열을 만들었다.
let str2 = `Hello
World`;

alert(str1 === str2); // true
```

자바스크립트에는 다양한 특수 문자들이 있다.
|특수 문자|설명|
|---|---|
|`\n`|줄 바꿈|
|`\r`|캐리지 리턴(carriage return). 맨 앞으로 이동하라는 뜻이다. Windows에서는 캐리지 리턴과 줄 바꿈 특수 문자를 조합(`\r\n`)해 줄을 바꾼다. 캐리지 리턴을 단독으로 사용하는 경우는 없다.|
|`\'`, `\"`|따옴표|
|`\\`|역슬래시|
|`\t`|탭|
|`\b`, `\f`, `\v`|각각 백스페이스(Backspace), 폼 피드(Form Feed), 세로 탭(Vertical Tab)을 나타낸다. 호환성 유지를 위해 남아있는 기호로 요즘에는 사용하지 않는다.|
|`\xXX`|16진수 유니코드 `XX`로 표현한 유니코드 글자이다(예시: 알파벳 `'z'`는 `'\x7A'`와 동일하다).|
|`\uXXXX`|UTF-16 인코딩 규칙을 사용하는 16진수 코드 `XXXX`로 표현한 유니코드 기호이다. `XXXX`는 반드시 네 개의 16진수로 구성되야 한다(예시: `\u00A9`는 저작권 기호 `©`의 유니코드이다).|
|`\u{X…XXXXXX}`(한 개에서 여섯 개 사이의 16진수 글자)|UTF-32로 표현한 유니코드 기호이다. 몇몇 특수한 글자는 두 개의 유니코드 기호를 사용해 인코딩되므로 4바이트를 차지한다. 이 방법을 사용하면 긴 코드를 삽입할 수 있다.|

모든 특수 문자는 '이스케이프 문자(escape character)'라고도 불리는 역슬래시 (backslash character)  `\`로 시작한다. 역슬래시는 문자열 내에 따옴표를 넣을 때도 사용할 수 있다.
```js
alert('I\'m the Walrus!'); // I'm the Walrus!
```
다음과 같이 `\`를 안 쓰고 큰따옴표와 작은따옴표를 교차로 사용하는 방법도 있다.
```js
alert("I'm the Walrus!"); // I'm the Walrus!
```
문자열 내에서 따옴표를 자유롭게 사용하려면 아래와 같이 따옴표 대신 백틱으로 문자열을 감싸주면 된다.
```js
alert(`I'm the Walrus!`); // I'm the Walrus!
```

## 문자열의 길이
문자열의 길이는 `length` 프로퍼티에서 확인할 수 있다.
```js
alert(`My\n`.length); // 3
```
`\n`은 ‘특수 문자’ 하나로 취급되기 때문에 `My\n`의 길이는 `3`이다.

---
:warning: `length`는 프로퍼티이다.

`length`는 함수가 아니고, 숫자가 저장되는 프로퍼티라는 점에 주의해야 한다. `length()`는 에러가 발생한다.

---

## 특정 글자에 접근하기
문자열 내 특정 위치인 `pos`에 있는 글자에 접근하려면 `[pos]`같이 대괄호를 이용하거나 [str.charAt(pos)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/charAt) 메서드를 사용하면 된다. 위치는 `0`부터 시작한다.
```js
let str = `Hello`;

// 첫 번째 글자
alert(str[0]); // H
alert(str.charAt(0)); // H

// 마지막 글자
alert(str[str.length - 1]); // o
```
요즘에는 대괄호 방식을 주로 사용한다.  `charAt`은 하위 호환성을 위해 남아있는 메서드이다.

두 접근 방식의 차이는 반환할 글자가 없을 때 드러난다. 접근하려는 위치에 글자가 없는 경우  대괄호 방식은  `undefined`를,  `charAt`은 빈 문자열을 반환한다.
```js
let str = `Hello`;

alert(str[1000]); // undefined
alert(str.charAt(1000)); // ''(빈 문자열)
```
`for...of`를 사용하면 문자열을 구성하는 글자를 대상으로 반복 작업을 할 수 있다.
```js
for (let char of 'Hello') {
  alert(char); // H,e,l,l,o(char는 순차적으로 H, e, l, l, o가 된다)
}
```

## 문자열의 불변성
문자열은 수정할 수 없으며 문자열의 일부를 수정하려고 하면 에러가 발생한다. 완전히 새로운 문자열을 만들어 할당하는 것은 가능하다.
```js
let str = 'Hi';

str = 'h' + str[1]; // 문자열 전체를 교체한다.

alert(str); // hi
```

## 대·소문자 변경하기
메서드  [toUpperCase()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase)는 소문자를 대문자로, 메서드  [toLowerCase()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase)는 대문자를 소문자로 바꿔준다.
```js
alert('Interface'.toUpperCase()); // INTERFACE
alert('Interface'.toLowerCase()); // interface
```
글자 하나의 케이스만 변경하는 것도 가능하다.
```js
alert('Interface'[0].toLowerCase()); // 'i'
```

## 부분 문자열 찾기
문자열에서 부분 문자열(substring)을 찾는 방법은 여러 가지가 있다.
### str.indexOf
첫 번째 방법은  [str.indexOf(substr[, pos])](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf)  메서드를 이용하는 것이다.

이 메서드는 문자열  `str`의  `pos`에서부터 시작해, 부분 문자열  `substr`의 위치를 찾아준다. 부분 문자열을 찾지 못하면  `-1`을 반환한다.
```js
let str = 'Widget with id';

alert(str.indexOf('Widget')); // 0, str은 'Widget'으로 시작한다.
alert(str.indexOf('widget')); // -1, indexOf는 대·소문자를 구분하므로 원하는 문자열을 찾지 못한다.

alert(str.indexOf('id')); // 1, 'id'는 첫 번째 위치에서 발견된다(Widget의 id).
```
`str.indexOf(substr, pos)`의 두 번째 매개변수 `pos`는 선택적으로 사용할 수 있는데, 이를 명시하면 검색이 해당 위치부터 시작된다.
```js
let str = 'Widget with id';

alert(str.indexOf('id', 2)) // 12
```
문자열 전체에서 부분 문자열을 모두 찾고 싶다면 다음과 같이 반복문 안에서 `indexOf`를 사용하면 된다.
```js
let str = 'As sly as a fox, as strong as an ox';

let target = 'as';

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert(`위치: ${foundPos}`);
  pos = foundPos + 1; // 다음 위치를 기준으로 검색을 이어간다.
}
```

---
:information_source: **`str.lastIndexOf(substr, position)`**

[str.lastIndexOf(substr[, position])](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf)는 문자열의 끝에서부터 부분 문자열을 찾는다.

---

#### 비트 NOT 연산자를 사용한 기법
[비트(bitwise) NOT 연산자](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators)  `~`를 사용한 오래된 기법이 있다. 비트 NOT 연산자는 피연산자를 32비트 정수로 바꾼 후(소수부는 모두 버려짐) 모든 비트를 반전한다. 따라서 `n`이 32비트 정수일 때 `~n`은 `-(n+1)`이 된다.
```js
alert(~2); // -3, -(2+1)과 같다.
alert(~1); // -2, -(1+1)과 같다.
alert(~0); // -1, -(0+1)과 같다.

alert(~-1); // 0, -(-1+1)과 같다.
```
부호가 있는 32비트 정수 `n` 중, `~n`을 `0`으로 만드는 경우는 `n == -1`일 때가 유일하다. 이를 이용해서 `indexOf`가 `-1`을 반환하지 않는 경우를 `~str.indexOf("...")`로 검사할 수 있다.
```js
let str = 'Widget';

if (~str.indexOf('Widget')) {
  alert('찾았다!');
}
```
이렇게 언어 특유의 기능을 사용해 직관적이지 않은 코드를 작성하는 것은 추천하지 않는다. 그렇지만 위와 같은 기법은 오래된 스크립트에서 쉽게 만날 수 있기 때문에 알아두어야 한다.

`if (~str.indexOf(...))`  패턴의 코드를 만나면 부분 문자열이 존재하는지 확인하는 코드인 것을 기억해 둘 필요가 있다.

모던 자바스크립트에서는 `.includes` 메서드를 사용해서 부분 문자열 포함 여부를 검사한다.

### includes, startsWith, endsWith
비교적 근래에 나온 메서드인  [str.includes(substr[, pos])](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/includes)는  `str`에 부분 문자열  `substr`이 있는지에 따라  `true`나  `false`를 반환한다.

부분 문자열의 위치 정보는 필요하지 않고 포함 여부만 알고 싶을 때 적합한 메서드이다.
```js
alert('Widget with id'.includes('Widget')); // true
alert('Hello'.includes('Bye')); // false
```
`str.includes`에도 `str.indexOf`처럼 두 번째 인수를 넣으면 해당 위치부터 부분 문자열을 검색한다.
```js
alert('Widget'.includes('id')); // true
alert('Widget'.includes('id', 3)); // false, 세 번째 위치 이후에는 'id'가 없다.
```
메서드 [str.startsWith](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith)와 [str.endsWith](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith)는 문자열 `str`이 특정 문자열로 시작하는지(start with) 여부와 특정 문자열로 끝나는지(end with) 여부를 확인할 때 사용할 수 있다.
```js
alert('Widget'.startsWith('Wid')); // true, 'Widget'은 'Wid'로 시작한다.
alert('Widget'.endsWith('get')); // true, 'Widget'은 'get'으로 끝난다.
```

## 부분 문자열 추출하기
자바스크립트에는 부분 문자열 추출과 관련된 메서드가 세 가지 있다.

### str.slice(start [, end])
문자열의  `start`부터  `end` 이전까지를 반환한다.
```js
let str = 'stringify';
alert(str.slice(0, 5)); // 'strin', 0번째부터 5번째 위치까지(5번째 위치의 글자는 미포함)
alert(str.slice(0, 1)); // 's', 0번째부터 1번째 위치까지(1번째 위치의 글자는 미포함)
```
```js
let str = 'stringify';
alert(str.slice(2)); // ringify, 2번째부터 끝까지
```
`start`와 `end`는 음수가 될 수도 있다. 음수를 넣으면 문자열 끝에서부터 카운팅을 시작한다.
```js
let str = 'stringify';

// 끝에서 4번째부터 시작해 끝에서 1번째 위치까지
alert(str.slice(-4, -1)); // gif
```

### str.substring(start [, end])
`substring`은  `slice`와 아주 유사하지만  `start`가  `end`보다 커도 된다는 차이가 있다.
```js
let str = 'stringify';

// 동일한 부분 문자열을 반환한다.
alert(str.substring(2, 6)); // 'ring'
alert(str.substring(6, 2)); // 'ring'

alert(str.slice(2, 6)); // 'ring'(같다)
alert(str.slice(6, 2)); // ''(빈 문자열), 다른 결과가 나온다.
```
`substring`은 음수 인수를 허용하지 않는다. 음수는 `0`으로 처리된다.

### str.substr(start [, length])
`start`에서부터 시작해  `length`개의 글자를 반환한다.

`substr`은 끝 위치 대신에 길이를 기준으로 문자열을 추출한다는 점에서  `substring`과  `slice`와 차이가 있다.
```js
let str = 'stringify';
alert(str.substr(2, 4)); // 'ring', 두 번째부터 글자 네 개
```
첫 번째 인수가 음수면 뒤에서부터 개수를 센다.
```js
let str = 'stringify';
alert(str.substr(-4, 2)); // 'gi', 끝에서 네 번째 위치부터 글자 두 개
```
부분 문자열 추출과 관련된 메서드들을 정리하면 다음과 같다.
|메서드                  |추출할 부분 문자열                   |음수 허용 여부(인수) |
|-----------------------|---------------------------|------------------|
|`slice(start, end)`    |`start`부터 `end` 이전까지   |음수 허용          |
|`substring(start, end)`|`start`부터 `end` 이전까지   |음수는 `0`으로 취급함|
|`substr(start, length)`|`start`부터 `length`개의 글자|음수 허용          |

---
:information_source: **어떤 메서드를 사용해야 할까?**

`substr`는 코어 자바스크립트 명세서가 아닌, 구식 스크립트에 대응하기 위해 남겨 둔 브라우저 전용 기능들을 명시해 놓은 부록 B(Annex B)에 정의되어있다. 거의 모든 곳에서 이 메서드가 동작하긴 하지만 브라우저 이외의 호스트 환경에서는 제대로 동작하지 않을 수 있다.

남은 두 메서드 중 `slice`는 음수 인수를 허용한다는 측면에서 `substring`보다 유연하며 메서드 이름도 더 짧다. 따라서 <strong>`slice`</strong>만 외워놓고 사용해도 충분할 것이다.

---

## 문자열 비교하기
[비교 연산자](https://github.com/autroshot/studyroom/blob/main/01-javascript/01-%EC%BD%94%EC%96%B4%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/02-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%20%EA%B8%B0%EB%B3%B8.md#09-%EB%B9%84%EA%B5%90-%EC%97%B0%EC%82%B0%EC%9E%90)  챕터에서 알아봤듯이 문자열을 비교할 때는 알파벳 순서를 기준으로 비교가 이뤄진다.

그런데 다음과 같이 몇 가지 이상한 점들이 있다.
1. 소문자는 대문자보다 항상 크다.
    ```js
    alert('a' > 'Z'); // true
    ```
2. 발음 구별 기호(diacritical mark)가 붙은 문자는 알파벳 순서 기준을 따르지 않는다.
    ```js
    // Österreich는 오스트리아를 독일어로 표기한 것이다.
    alert('Österreich' > 'Zealand'); // true
    ```
모든 문자열은 UTF-16을 사용해서 인코딩되는데, UTF-16에서는 모든 글자가 숫자 형식의 코드와 매칭된다. 코드로 글자를 얻거나 글자에서 연관 코드를 알아낼 수 있는 메서드는 다음과 같다.

### str.codePointAt(pos)
`pos`에 위치한 글자의 코드를 반환한다.
```js
// 글자는 같지만 케이스가 다르므로 반환되는 코드가 다르다.
alert('z'.codePointAt(0)); // 122
alert('Z'.codePointAt(0)); // 90
```

### String.fromCodePoint(code)
숫자 형식의  `code`에 대응하는 글자를 반환한다.
```js
alert(String.fromCodePoint(90)); // Z
```
글자는 글자에 대응하는 **숫자 형식의 코드**를 기준으로 비교된다. 알파벳 소문자의 코드는 대문자의 코드보다 크다. `Ö`  같은 글자의 코드는 일반 알파벳의 코드보다 훨씬 크다.

### 문자열 제대로 비교하기
모던 브라우저 대부분이 국제화 관련 표준인 [ECMA-402](http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf)를 지원한다(IE10는 [Intl.js](https://github.com/andyearnshaw/Intl.js/) 라이브러리를 사용해야 한다). ECMA-402에는 언어가 다를 때 적용할 수 있는 문자열 비교 규칙과 이를 준수하는 메서드가 정의되어있다.

[str1.localeCompare(str2)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)를 사용하면 ECMA-402에서 정의한 규칙에 따라 `str1`이 `str2`보다 작은지, 같은지, 큰지를 알려주는 정수가 반환된다. 작으면 음수, 크면 양수, 같으면 `0`을 반환한다.
```js
alert('z'.localeCompare('Z')); // -1, 음수
alert('Österreich'.localeCompare('Zealand')); // -1, 음수
```
`localeCompare`에 선택 인수 두 개를 더 전달할 수 있다. 기준이 되는 언어를 지정(아무것도 지정하지 않았으면 호스트 환경의 언어가 기준 언어가 된다)해주는 인수와 대·소문자를 구분 여부나 `"a"`와 `"á"`를 다르게 취급할지 여부를 설정해주는 인수가 있다. 자세한 사항은 관련 [MDN 문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)에서 확인할 수 있다.

## 기타 문자열 메서드
-   `str.trim()`: 문자열 앞과 끝의 공백 문자를 제거한다.
-   `str.repeat(n)`: 문자열을  `n`번 반복한다.
-   이 외의 메서드는  [MDN 문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String)에서 확인할 수 있다.

## 문자열 심화
---
:warning: **심화학습**

이모티콘이나 일부 수학 기호, 상형 문자를 비롯한 희귀 기호 등을 다뤄야 한다면 앞으로 배울 내용이 유용하게 사용될 것이다.

---

### 서로게이트 쌍
유럽권 언어에서 사용되는 글자, 숫자, 상형 문자 대다수는 2바이트 표현 체계를 사용한다. 하지만 2바이트는 현존하는 기호를 모두 표현하기에 충분하지 않았다. 이를 극복하기 위해 사용 빈도가 낮은 기호는 <strong>서로게이트 쌍(surrogate pair)</strong>이라 불리는 2바이트 글자들의 쌍을 사용해 인코딩한다.

서로게이트 쌍을 사용해 인코딩한 기호의 길이는 `2`이다.
```js
alert('𝒳'.length); // 2, 그리스 문자 카이
alert('😂'.length); // 2, 이모티콘
alert('𩷶'.length); // 2, 사용 빈도가 낮은 중국어 상형문자
```
`String.fromCodePoint`와 `str.codePointAt`은 명세서에 추가된 지 얼마 안 된 메서드로, 서로게이트 쌍을 제대로 처리할 수 있는 몇 안 되는 메서드이다.

서로게이트 쌍은 두 글자로 취급되기 때문에 기호를 가져오는 게 꽤 까다롭다.
```js run
alert('𝒳'[0]); // 이상한 기호가 출력된다.
alert('𝒳'[1]); // 서로게이트 쌍의 일부가 출력된다.
```
서로게이트 쌍을 구성하는 글자들은 서로 붙어있을 때만 의미가 있기 때문에 위 예시를 실행하면 얼럿창에는 의미 없는 기호가 출력된다.

기술적으로 서로게이트 쌍은 서로게이트 쌍에 대응하는 코드를 사용해 감지할 수 있다. 서로게이트 쌍을 구성하는 첫 번째 글자는 `0xd800..0xdbff`에, 두 번째 글자의 코드는 `0xdc00..0xdfff`에 존재한다.

서로게이트 쌍을 다루는 다양한 방법에 대해선 [iterable 객체]() 챕터에서 살펴볼 것이다.

### 발음 구별 기호와 유니코드 정규화
일부 언어에서는 글자 위나 아래에 발음 구별 기호를 붙여 글자를 만든다. `a`를 베이스 글자로, `àáâäãåā`를 만드는 것이 그 예이다. 그런데 모든 합성 글자에 코드가 부여되지는 않는다. 조합 가능한 글자의 수가 너무 많기 때문이다.

베이스 글자 뒤에 하나 혹은 여러 개의 유니코드 문자를 붙여 베이스 글자를 꾸밀 수 있다.
```js
alert('S\u0307'); // Ṡ
alert('S\u0307\u0323'); // Ṩ
```
이런 방식은 엄청난 유연성을 제공하지만 단점도 있다. 눈으로 봤을 때는 같은 글자인데 유니코드 조합이 다른 경우가 생긴다.
```js
let s1 = 'S\u0307\u0323'; // Ṩ, S + 윗 점 + 아랫 점
let s2 = 'S\u0323\u0307'; // Ṩ, S + 아랫 점 + 윗 점

alert(`s1: ${s1}, s2: ${s2}`);

alert(s1 == s2); // 눈으로 보기엔 같은 글자이지만 동등 비교 시 false가 반환된다.
```
이런 문제를 해결하려면 '유니코드 정규화(unicode normalization)'라 불리는 알고리즘을 사용해 각 문자열을 동일한 형태로 정규화해야 한다. 유니코드 정규화 알고리즘은  [str.normalize()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)에 구현되어 있다.
```js
alert('S\u0307\u0323'.normalize() == 'S\u0323\u0307'.normalize()); // true
```
```js
alert('S\u0307\u0323'.normalize().length ); // 1

alert('S\u0307\u0323'.normalize() == '\u1e68'); // true
```
정규화 규칙과 변형에 대해 더 알고 싶다면 유니코드 표준 부록의 [Unicode Normalization Forms](http://www.unicode.org/reports/tr15/)에서 확인할 수 있다.
<br></br>
# 04. 배열
**순서가 있는 컬렉션**을 저장할 때는 **배열**을 사용하면 편리하다.

## 배열 선언
빈 배열을 만드는 방법은 아래 두 가지가 있다.
```js
let arr = new Array();
let arr = [];
```
대부분 두 번째 방법으로 배열을 선언하는데, 이때 대괄호 안에 초기 요소를 넣어주는 것도 가능하다.
```js
let fruits = ['사과', '오렌지', '자두'];
```
각 배열 요소엔 0부터 시작하는 숫자(**인덱스**)가 매겨져 있다. 이 숫자들은 배열 내 순서를 나타낸다.

배열 내 특정 요소를 얻고 싶다면 대괄호 안에 인덱스를 넣어주면 된다.
```js
let fruits = ['사과', '오렌지', '자두'];

alert(fruits[0]); // 사과
alert(fruits[1]); // 오렌지
alert(fruits[2]); // 자두
```
같은 방법으로 요소를 수정할 수 있다.
```js
fruits[2] = '배'; // 배열이 ['사과', '오렌지', '배']로 바뀐다.
```

새로운 요소를 배열에 추가하는 것도 가능하다.

```js
fruits[3] = '레몬'; // 배열이 ['사과', '오렌지', '배', '레몬']으로 바뀐다.
```

`length`를 사용하면 배열에 담긴 요소가 몇 개인지 알 수 있다.

```js
let fruits = ['사과', '오렌지', '자두'];

alert(fruits.length); // 3
```
`alert`를 사용해 요소 전체를 출력하는 것도 가능하다.
```js
let fruits = ['사과', '오렌지', '자두'];

alert(fruits); // 사과,오렌지,자두
```
배열 요소의 자료형에는 제약이 없다.
```js run no-beautify
// 요소에 여러 가지 자료형이 섞여 있다.
let arr = ['사과', { name: '이보라' }, true, function() { alert('안녕하세요.'); }];

// 인덱스가 1인 요소(객체)의 name 프로퍼티를 출력한다.
alert(arr[1].name); // 이보라

// 인덱스가 3인 요소(함수)를 실행한다.
arr[3](); // 안녕하세요.
```

---
:information_source: **trailing 쉼표**
배열의 마지막 요소는 객체와 마찬가지로 쉼표로 끝날 수 있다.
```js
let fruits = [
  '사과',
  '오렌지',
  '자두',
];
```
trailing(길게 늘어지는) 쉼표를 사용하면 모든 줄의 생김새가 유사해지기 때문에 요소를 넣거나 빼기가 쉬워진다.

---

## pop/push와 shift/unshift
<strong>큐(queue)</strong>는 배열을 사용해 만들 수 있는 대표적인 자료구조로, 배열과 마찬가지로 순서가 있는 컬렉션을 저장하는 데 사용한다. 큐에서 사용하는 주요 연산은 아래와 같다.
-   `push`: 맨 끝에 요소를 추가한다.
-   `shift`: 제일 앞 요소를 꺼내 제거한 후 남아있는 요소들을 앞으로 밀어준다. 이렇게 하면 두 번째 요소가 첫 번째 요소가 된다.

![queue](https://user-images.githubusercontent.com/95019875/156590982-ba8e25d8-a017-4768-aa98-94e3f02289af.svg)

배열은 큐 이외에  <strong>스택(stack)</strong>이라 불리는 자료구조를 구현할 때도 쓰입니다. 스택에서 사용하는 연산은 아래와 같습니다.
-   `push`: 요소를 스택의 끝에 집어넣는다.
-   `pop`: 스택의 끝 요소를 추출한다.

![stack](https://user-images.githubusercontent.com/95019875/156591014-ddddc6be-30f2-48b3-a11c-b38580880a06.svg)

큐는 먼저 집어넣은 요소가 먼저 나오기 때문에 큐는 선입선출(First-In-First-Out, FIFO) 자료구조라고 부른다. 반면 스택은 가장 나중에 집어넣은 요소가 먼저 나오기 때문에 후입선출(Last-In-First-Out, LIFO) 자료구조라고 부른다.

자바스크립트 배열을 사용하면 큐나 스택을 모두 만들 수 있다. 이 자료구조들은 배열의 처음이나 끝에 요소를 더하거나 뺄 때 사용한다. 이렇게 처음이나 끝에 요소를 더하거나 빼주는 연산을 제공하는 자료구조를 컴퓨터 과학 분야에서는 <strong>데큐(deque, Double Ended Queue)</strong>라고 부른다.

### pop/push는 배열의 끝에 무언가를 해주는 메서드이다.

`pop`: 배열의 끝 요소를 제거하고, 제거한 요소를 반환한다.
```js
let fruits = ['사과', '오렌지', '배'];

alert(fruits.pop()); // 배열에서 '배'를 제거하고 제거된 요소를 얼럿창에 띄운다.

alert(fruits); // 사과, 오렌지
```
`push`: 배열의 끝에 요소를 추가한다. 여러 개도 가능하다.
```js
let fruits = ['사과', '오렌지'];

fruits.push('배');

alert(fruits); // 사과, 오렌지, 배
```
`fruits.push(...)`를 사용하는 것은 `fruits[fruits.length] = ...` 코드와 동일할 기능을 한다.
<br></br>

### shift/unshift는 배열의 앞에 무언가를 해주는 메서드이다.

`shift`: 배열의 앞 요소를 제거하고, 제거한 요소를 반환한다.
```js
let fruits = ['사과', '오렌지', '배'];

alert(fruits.shift()); // 배열에서 '사과'를 제거하고 제거된 요소를 얼럿창에 띄운다.

alert(fruits); // 오렌지, 배
```
`unshift`: 배열의 앞에 요소를 추가한다. 여러 개도 가능하다.
```js run
let fruits = ['오렌지', '배'];

fruits.unshift('사과');

alert(fruits); // 사과, 오렌지, 배
```

## 배열의 내부 동작 원리
배열은 **특별한 종류의 객체**이며 객체처럼 동작한다.

배열은 객체와 마찬가지로 참조를 통해 복사된다.
```js
let fruits = ['바나나']
let arr = fruits; // 참조를 복사한다(두 변수가 같은 객체를 참조한다).

alert(arr === fruits); // true
arr.push('배'); // 참조를 이용해 배열을 수정한다.
alert(fruits); // 바나나, 배 - 요소가 두 개가 되었다.
```

배열에서 객체와 동일하게 `this`를 사용할 수 있다.
```js
let arr = ['a', 'b'];

arr.push(function() {
  alert(this);
})

arr[2](); // a,b,function(){...}
```

배열을 '순서가 있는 자료의 컬렉션’처럼 다루지 않고 '일반 객체'처럼 다루면 자바스크립트의 최적화 기법이 동작하지 않아 배열 특유의 이점이 사라진다. 배열을 다음과 같이 사용하는 것은 잘못된 사용법이다.
-   `arr.test = 5`  같이 숫자가 아닌 값을 프로퍼티 키로 사용하는 경우
-   `arr[0]`과  `arr[1000]`만 추가하고 그사이에 아무런 요소도 없는 경우
-   `arr[1000]`,  `arr[999]`같이 요소를 역순으로 채우는 경우

임의의 키를 사용해야 한다면 배열보다는 일반 객체 `{}`가 적합한 자료구조일 확률이 높다.

## 성능
`push`/`pop`은 빠르지만 `shift`/`unshift`는 느리다. `shift`/`unshift`는 요소 전체를 이동시켜야 되기 때문이다.

## 반복문
`for`문은 배열을 순회할 때 쓰는 가장 오래된 방법이다. 순회할 때 인덱스를 사용한다. 가장 빠른 방법이며 오래된 브라우저와도 호환된다.
```js
let arr = ['사과', '오렌지', '배'];

for (let i = 0; i < arr.length; i++) {
  alert(arr[i]);
}
```
배열에 적용할 수 있는 또 다른 순회 문법으로는 `for..of`가 있다.
```js run
let fruits = ['사과', '오렌지', '자두'];

// 배열 요소를 대상으로 반복 작업을 수행한다.
for (let fruit of fruits) {
  alert(fruit);
}
```
`for..of`를 사용하면 현재 요소의 인덱스는 얻을 수 없고 값만 얻을 수 있다.`for..of`가 문법도 짧고 사용이 간편하기 때문에, 인덱스가 필요한 상황이 아니면 **`for..of`를 사용**하는 것을 권장한다.

배열은 객체형에 속하므로 `for..in`을 사용하는 것도 가능하다.
```js
let arr = ['사과', '오렌지', '배'];

for (let key in arr) {
  alert(arr[key]); // 사과, 오렌지, 배
}
```
그런데 `for..in`은 다음과 같은 특징을 지니기 때문에 **배열에 `for..in`을 사용해서는 안 된다.**
1. `for..in` 반복문은 '모든 프로퍼티'를 대상으로 순회합니다. 키가 숫자가 아닌 프로퍼티도 순회 대상에 포함된다.
	객체 중에는 배열과 유사한 형태를 보이는 ‘유사 배열(array-like)’ 객체가 존재한다. 유사 배열 객체에는 배열과 달리 키가 숫자형이 아닌 프로퍼티와 메서드가 있을 수 있다. `for..in`을 유사 배열 객체에 사용하면 이 모든 것을 대상으로 순회가 이뤄져서 ‘필요 없는’ 프로퍼티들이 문제를 일으킬 가능성이 생긴다.

2. `for..in`  반복문은 객체에 사용하는 것에 최적화되어 있어서 배열에 사용하면 객체 대비 10~100배 정도 느리다.

## length 프로퍼티
배열에 무언가 조작을 가하면 `length` 프로퍼티가 자동으로 갱신된다. 

`length` 프로퍼티는 배열 내 요소의 개수가 아니라 **가장 큰 인덱스에 1을 더한 값**이다. 따라서 배열에 요소가 하나만 있는데, 이 요소의 인덱스가 아주 큰 수라면 배열의 `length` 프로퍼티도 아주 커진다.
```js
let fruits = [];
fruits[123] = '사과';

alert(fruits.length); // 124
```
물론 배열을 이렇게 사용해서는 안 된다.

`length`  프로퍼티의 또 다른 독특한 특징은 **쓰기가 가능하다**는 것이다.

`length`의 값을 수동으로 증가시키면 아무 일도 일어나지 않는 반면, 값을 감소시키면 배열이 잘리는 것을 확인할 수 있다. 짧아진 배열은 다시 되돌릴 수 없다.
```js
let arr = [1, 2, 3, 4, 5];

arr.length = 2; // 요소를 2개만 남긴다.
alert(arr); // [1, 2]

arr.length = 5; // 원래 길이로 되돌린다.
alert(arr[3]); // undefined, 삭제된 기존 요소들이 복구되지 않는다.
```
이런 특징을 활용해 `arr.length = 0;`을 사용하면 아주 간단하게 배열을 비울 수 있다.

## new Array()
`new Array()` 문법을 사용해도 배열을 만들 수 있다.
```js
let arr = new Array('사과', '배', '기타');
```
대괄호 `[]`를 사용하면 더 짧은 문법으로 배열을 만들 수 있기 때문에 `new Array()`는 잘 사용되지 않는다.

숫자형 인수 하나를 넣어서 `new Array`를 호출하면 배열이 만들어지는데, 이 배열에는 요소가 없는 반면 길이는 인수와 같아진다.
```js
let arr = new Array(2);

alert(arr[0]); // undefined가 출력된다. 요소가 하나도 없는 배열이 만들어졌다.
alert(arr.length); // 길이는 2이다.
```
이런 뜻밖의 상황을 마주치지 않기 위해 `new Array`의 기능을 잘 알지 않는 한 대부분의 개발자는 대괄호를 써서 배열을 만든다.

## 다차원 배열
배열 역시 배열의 요소가 될 수 있다. 이런 배열을 가리켜 다차원 배열(multidimensional array)이라 부른다. 다차원 배열은 행렬을 저장하는 용도로 쓰인다.
```js
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert(matrix[1][1]); // 5
```

## toString
배열에는 `toString` 메서드가 구현되어 있어서 이를 사용하면 요소를 쉼표로 구분한 문자열이 반환된다. 쉼표 뒤에 빈 칸이 없는 것을 주의해야 한다.
```js run
let arr = [1, 2, 3];

alert(arr); // 1,2,3
alert(String(arr) === '1,2,3'); // true
```
배열에는 `Symbol.toPrimitive`나 `valueOf` 메서드가 없다. 따라서 아래 예시에서는 문자열로의 형 변환이 일어나 `[]`는 빈 문자열, `[1]`은 문자열 `'1'`, `[1,2]`는 문자열 `'1,2'`로 변환된다.
```js
alert([] + 1); // '1'
alert([1] + 1); // '11'
alert([1,2] + 1); // '1,21'
```
<br></br>
# 05. 배열과 메서드
##  요소 추가·제거 메서드
###  splice
배열에 연산자 `delete`를 사용하면 빈 공간이 생긴다.
```js
let arr = ['I', 'go', 'home'];

delete arr[1]; // 'go'를 삭제한다.

alert(arr[1]); // undefined

// delete를 써서 요소를 지우고 난 후의 배열 -> arr = ['I', , 'home'];
alert(arr.length); // 3
```

빈 공간 없이 요소를 지우려면 [arr.splice(start)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)를 사용한다. 이 메서드를 사용하면 요소의 추가, 삭제, 교체가 모두 가능하다.
```js
arr.splice(index, [deleteCount], [elem1, ..., elemN])
```
첫 번째 매개변수는 조작을 가할 첫 번째 요소를 가리키는 `인덱스(index)`이다. 두 번째 매개변수는 `deleteCount`로, 제거하고자 하는 요소의 개수를 나타낸다. `elem1, ..., elemN`은 배열에 추가할 요소를 나타낸다.

`splice`는 삭제된 요소로 구성된 배열을 반환한다.

다음은 `splice` 메서드를 사용한 예시들이다.
```js
let arr = ['I', 'study', 'JavaScript'];

arr.splice(1, 1); // 인덱스 1부터 요소 한 개를 제거한다.

alert(arr); // ['I', 'JavaScript']
```
```js
let arr = ['I', 'study', 'JavaScript', 'right', 'now'];

// 처음(0) 세 개(3)의 요소를 지우고, 이 자리를 다른 요소로 대체한다.
arr.splice(0, 3, "Let's", 'dance');

alert(arr) // now ["Let's", 'dance', 'right', 'now']
```
```js
let arr = ['I', 'study', 'JavaScript', 'right', 'now'];

// 처음 두 개의 요소를 삭제한다.
let removed = arr.splice(0, 2);

alert(removed); // "I", "study" <- 삭제된 요소로 구성된 배열이다.
```
인자 `deleteCount`를 `0`으로 설정하면 요소를 제거하지 않으면서 새로운 요소를 추가할 수 있다.
```js
let arr = ['I', 'study', 'JavaScript'];

// 인덱스 2부터 0개의 요소를 삭제한다.
// 그 후, "complex"와 "language"를 추가한다.
arr.splice(2, 0, 'complex', 'language');

alert(arr); // 'I', 'study', 'complex', 'language', 'JavaScript'
```

---
:information_source: **음수 인덱스도 사용할 수 있다.**

배열 관련 메소드에는 음수 인덱스를 사용할 수 있다. 음수 인덱스는 배열 끝에서부터의 위치를 가리킨다.
```js run
let arr = [1, 2, 5];

// 인덱스 -1부터 0개의 요소를 삭제하고, 3과 4를 추가한다.
arr.splice(-1, 0, 3, 4);

alert(arr); // 1,2,3,4,5
```
---

### slice
[arr.slice](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)는 `arr.splice`와 유사하지만 훨씬 간단하다.
```js
arr.slice([start], [end])
```
이 메서드는 `"start"` 인덱스부터 `"end"`인덱스 전까지의 요소를 복사한 새로운 배열을 반환합니다. `start`와 `end`는 둘 다 음수가 가능하다.
```js
let arr = ['t', 'e', 's', 't'];

alert(arr.slice(1, 3)); // e,s
alert(arr.slice(-2)); // s,t
```
`arr.slice()`와 같이 인수를 하나도 넣지 않으면 `arr`의 복사본을 만들 수 있다. `arr.slice()`는 기존의 배열을 건드리지 않으면서, 추가 변환을 위한 복사본을 얻기 위해 자주 사용된다.

### concat
[arr.concat](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)은 **기존 배열의 요소를 사용해 새로운 배열을 만들거나 기존 배열에 요소를 추가**할 때 사용할 수 있다.
```js
arr.concat(arg1, arg2...)
```
인수에는 배열이나 값이 올 수 있으며 인수 개수에는 제한이 없다.

메서드를 호출하면  `arr`에 속한 모든 요소와  `arg1`,  `arg2`  등에 속한 모든 요소를 한데 모은 새로운 배열이 반환된다.
```js
let arr = [1, 2];

alert(arr.concat([3, 4])); // 1,2,3,4
alert(arr.concat([3, 4], [5, 6])); // 1,2,3,4,5,6
alert(arr.concat([3, 4], 5, 6)); // 1,2,3,4,5,6
```
인자로 객체를 넣으면 객체가 그대로 복사된다.
```js
let arr = [1, 2];

let arrayLike = {
  0: 'something',
  length: 1
};

alert(arr.concat(arrayLike)); // 1,2,[object Object]
```
그런데 인자로 받은 유사 배열 객체에 특수한 프로퍼티 `Symbol.isConcatSpreadable`이 있으면 `concat`은 이 객체를 배열처럼 취급한다.
```js
let arr = [1, 2];

let arrayLike = {
  0: 'something',
  1: 'else',
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert(arr.concat(arrayLike)); // 1,2,something,else
```

## forEach로 반복작업 하기
[arr.forEach](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)는 **주어진 함수를 배열의 각 요소에서 호출한다.**
```js
arr.forEach(function(item, [index], [array]) {
  // 요소에 무언가를 할 수 있다.
});
```
```js
// 각 요소마다 얼럿을 호출한다.
['Bilbo', 'Gandalf', 'Nazgul'].forEach(alert);
```
```js
['Bilbo', 'Gandalf', 'Nazgul'].forEach((item, index, array) => {
  alert(`${item} is at index ${index} in ${array}`);
});
```
인수로 넣은 함수의 반환값은 무시된다.

## 배열 탐색하기
### indexOf/lastIndexOf, includes
[arr.indexOf](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)/[arr.lastIndexOf](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf), [arr.includes](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)는 같은 이름을 가진 문자열 메서드와 사용법이 동일하다. 연산 대상이 문자열이 아닌 배열의 요소라는 점만 다르다.
-   `arr.indexOf(item, from)`는 인덱스  `from`부터 시작해서  `item(요소)`을 찾는다. `item`를 찾으면 해당 요소의 인덱스를 반환하고, 찾지 못하면  `-1`을 반환한다.
-   `arr.lastIndexOf(item, from)`는 배열의 끝에서부터 찾는다.
-   `arr.includes(item, from)`는 인덱스  `from`부터 시작해  `item`이 있는지를 찾고, `item`를 찾으면  `true`를 반환한다.
```js
let arr = [1, 0, false];

alert(arr.indexOf(0)); // 1
alert(arr.indexOf(false)); // 2, '==='을 사용하기 때문에 요소 0은 지나가고 2가 출력된다.
alert(arr.indexOf(null)); // -1

alert(arr.includes(1)); // true
```
위 메서드들은 요소를 찾을 때 완전 항등 연산자 `===` 을 사용한다는 점을 주의해야 한다.

요소가 배열 내에 존재하는지만 확인하고 싶다면 `arr.includes`를 사용하는 것이 좋다. `includes`는 `NaN`도 제대로 찾는다는 점에서 `indexOf/lastIndexOf`와 약간의 차이가 있다.
```js
const arr = [NaN];
alert(arr.indexOf(NaN)); // -1, '==='는 NaN에 동작하지 않으므로 -1이 출력된다.
alert( arr.includes(NaN) );// true, NaN을 찾았다.
```

### find와 findIndex
[arr.find(fn)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/find)는 배열 내에서 **특정 조건에 부합하는 객체를 찾을 때** 사용한다. 실무에서 객체로 구성된 배열을 자주 다룬다.
```js
let result = arr.find(function(item, [index], [array]]) {
  // 함수의 결과가 true이면 반복을 멈추고 해당 요소를 반환한다.
  // 조건에 해당하는 요소가 없으면 undefined를 반환한다.
});
```
요소 전체를 대상으로 함수가 순차적으로 호출된다.
-   `item`  – 함수를 호출할 요소
-   `index`  – 요소의 인덱스
-   `array`  – 배열 자기 자신
```js
let users = [
  {id: 1, name: 'John'},
  {id: 2, name: 'Pete'},
  {id: 3, name: 'Mary'}
];

let user = users.find(item => item.id == 1);

alert(user.name); // John
```
위 예시와 같이 `find` 안의 함수에 인자가 하나만 있는 패턴을 가장 많이 사용한다. 다른 인자들(`index`, `array`)은 잘 사용되지 않는다.

[arr.findIndex](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex)는 조건에 맞는 요소를 반환하는 대신 **해당 요소의 인덱스를 반환한다.** 조건에 맞는 요소가 없으면 `-1`을 반환한다.

### filter
[arr.filter(fn)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)는 **조건을 충족하는 요소를 여러 개 찾고 싶을 때** 사용한다.
```js
let results = arr.filter(function(item, index, array) {
  // 조건을 충족하는 요소들이 들어있는 배열을 반환한다.
  // 조건을 충족하는 요소가 하나도 없으면 빈 배열을 반환한다.
});
```
```js
let users = [
  {id: 1, name: 'John'},
  {id: 2, name: 'Pete'},
  {id: 3, name: 'Mary'}
];

// id가 1, 2인 객체가 들어있는 배열을 반환한다.
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
```

## 배열을 변형하는 메서드
### map
[arr.map](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/map)은 **배열의 각 요소를 대상으로 함수를 호출하고, 그 결과들을 배열로 반환한다.** `map`은 유용성과 사용 빈도가 아주 높은 메서드 중 하나이다.
```js
let result = arr.map(function(item, index, array) {
  // 요소를 변환한 값들이 들어있는 배열을 반환한다.
});
```
```js
let lengths = ['Bilbo', 'Gandalf', 'Nazgul'].map(item => item.length);
alert(lengths); // 5,7,6
```

### sort(fn)
[arr.sort()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)는 **배열의 요소를 정렬해준다.**

메서드는 정렬된 배열을 반환하는데, 이미  `arr`  자체가 수정되었기 때문에 반환 값은 잘 사용하지 않는다.
```js
let arr = [1, 2, 15];

// arr 내부가 재정렬된다.
arr.sort();

alert(arr);  // 1, 15, 2
```
위 예시를 보면 **요소가 문자형으로 변환된 후 정렬**된 것을 알 수 있다.

기본 정렬 기준 대신에 새로운 정렬 기준을 적용하려면 `arr.sort()`에 인수로 새로운 함수를 넣어줘야 한다. 인수로 넣어주는 함수는 반드시 값 두 개를 비교해야 하고 반환 값도 있어야 한다. 오름차순으로 정렬하려면 `a > b`일 때 양수여야 한다.
```js
function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [1, 2, 15];

arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15
```

---
:information_source: **정렬 함수는 어떤 숫자든 반환할 수 있다.**

정렬 함수의 반환 값에는 제약이 없다. 첫 번째 인수가 두 번째 인수보다 크면 양수를 반환하고, 첫 번째 인수가 두 번째 인수보다 작으면 음수를 반환하면 된다.

이 점을 이용하면 다음과 같이 정렬 함수를 더 간결하게 만들 수 있다.
```js
let arr = [1, 2, 15];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // 1, 2, 15
```
---
:information_source: **화살표 함수를 사용하면 정렬 함수가 더 깔끔해진다.**

```js
arr.sort((a, b) => a - b);
```
---
:information_source: **문자열에는 `localeCompare`를 사용한다.**

`localeCompare`는 유니코드를 기준으로 글자를 비교한다. `Ö` 같은 문자가 있는 언어에도 대응할 수 있다.
```js
let countries = ['Österreich', 'Andorra', 'Vietnam'];

alert(countries.sort((a, b) => a > b ? 1 : -1)); // Andorra, Vietnam, Österreich -> 제대로 정렬되지 않았다.
alert(countries.sort((a, b) => a.localeCompare(b))); // Andorra,Österreich,Vietnam -> 제대로 정렬되었다.
```
### reverse
[arr.reverse](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)는 `arr`의 요소를 **역순으로 정렬한다.** 반환 값은 역순으로 정렬된 배열이다.
```js
let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert(arr); // 5,4,3,2,1
```
### split과 join
[str.split(delim)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/split)은 구분자(delimiter) `delim`을 기준으로 문자열을 나눠서 배열에 저장한다.
```js
let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(', ');

for (let name of arr) {
  alert(`${name}에게 보내는 메시지`); // Bilbo에게 보내는 메시지
}
```
`split` 메서드는 두 번째 인수로 숫자를 받을 수 있다. 이 숫자는 배열의 길이를 제한해주며 길이를 넘어서는 요소를 무시할 수 있다. 실무에서 자주 사용하는 기능은 아니다.
```js
let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);

alert(arr); // Bilbo, Gandalf
```
---
:information_source: **문자열을 글자 단위로 분리하기**

`split(delim)`의 `delim`을 빈 문자열로 지정하면 문자열을 글자 단위로 분리할 수 있다.
```js
let str = 'test';

alert(str.split('')); // t,e,s,t
```
---

[arr.join(glue)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/join)은 `split`과 반대 역할을 하는 메서드이다. 인수 `glue`를 접착제처럼 사용해서 배열 요소를 모두 합친 하나의 문자열을 만들어준다.
```js
let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';'); // 배열 요소들을 ;를 사용해 하나의 문자열로 합친다.

alert(str); // Bilbo;Gandalf;Nazgul
```

### reduce/reduceRight
`reduce`와 `reduceRight`는 **배열을 기반으로 값 하나를 도출**할 때 사용된다.
```js
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
```
인수로 넘겨주는 함수는 배열의 모든 요소를 대상으로 차례로 적용되는데, 적용 결과는 다음 함수 호출 시 사용된다.

함수의 인수는 다음과 같다.
-   `accumulator`: 이전 함수 호출 결과이다.  `initial`은 함수 최초 호출 시 사용되는 초깃값을 나타내며 생략할 수 있다.
-   `item`: 현재 배열 요소
-   `index`: 요소의 위치
-   `array`: 배열

이전 함수 호출 결과는 다음 함수를 호출할 때 첫 번째 인수(`previousValue`)로 사용된다. 첫 번째 인수는 앞서 호출했던 함수들의 결과가 누적되어 저장되는 '누산기(accumulator)' 역할을 한다. 마지막 함수까지 호출되면 이 값은 `reduce` 메서드의 반환 값이 된다.

```js
let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
```
보통은 이렇게 인수를 두 개만 사용한다.

초깃값을 생략할 경우, 배열이 비어있는 상태면 에러가 발생한다.
```js
let arr = [];

// TypeError: Reduce of empty array with no initial value
// 초깃값을 설정해 주었다면 초깃값이 반환되었을 것이다.
arr.reduce((sum, current) => sum + current);
```
이런 예외상황 때문에 **항상 초깃값을 명시**해 줄 것을 권장한다.

[arr.reduceRight](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight)는  `reduce`와 동일한 기능을 하지만 배열의 오른쪽부터 연산을 수행한다.

## Array.isArray로 배열 여부 알아내기
자바스크립트에서 배열은 독립된 자료형으로 취급되지 않고 객체형에 속한다. 따라서  `typeof`로는 일반 객체와 배열을 구분할 수 없다.
```js
alert(typeof {}); // object
alert(typeof []); // object
```

[Array.isArray(value)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)를 사용하면 구별이 가능하다. `value`가 배열이면 `true`를, 배열이 아니면 `false`를 반환한다.
```js
alert(Array.isArray({})); // false
alert(Array.isArray([])); // true
```

## 배열 메서드와 'thisArg'
함수를 호출하는 대부분의 배열 메서드(`sort` 제외)는 `thisArg`라는 매개변수를 옵션으로 받을 수 있다.
```js
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg는 선택적으로 사용할 수 있는 마지막 인수이다.
```
**`thisArg`는 `func`의 `this`가 된다.**
```js run
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  { age: 16 },
  { age: 20 },
  { age: 23 },
  { age: 30 }
];

// army.canJoin 호출 시 참을 반환해주는 user를 찾는다.
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
```
`thisArgs`에  `army`를 지정하지 않고 단순히  `users.filter(army.canJoin)`를 사용했다면  `army.canJoin`은 단독 함수처럼 취급되고, 함수 본문 내  `this`는  `undefined`가 되어 에러가 발생했을 것이다.

`users.filter(user => army.canJoin(user))`를 사용해도 같은 결과가 나오지만  `thisArg`를 사용하는 방식이 이해하기 쉬우므로 더 많이 사용된다.

## 기타 배열 메서드
-   [arr.some(fn)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/some)과  [arr.every(fn)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/every)는 배열의 요소들에 대해 검사를 실시한다.
    
    두 메서드는  `map`과 유사하게 모든 요소를 대상으로 함수를 호출한다.  `some`은 함수의 반환 값을  `true`로 만드는 요소가 하나라도 있는지 여부를 확인하고,  `every`는 모든 요소가 함수의 반환 값을  `true`로 만드는지 여부를 확인한다. 두 메서드 모두 조건을 충족하면  `true`를, 그렇지 않으면  `false`를 반환한다.

-   [arr.fill(value, start, end)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)은  `start`부터  `end`까지  `value`를 채워 넣는다.
    
-   [arr.copyWithin(target, start, end)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)은  `start`부터  `end`까지 요소를 복사하고, 복사한 요소를  `target`에 붙여 넣는다. 기존 요소가 있다면 덮어씌운다.

배열에 관한 모든 메서드는 [MDN 문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array)에서 찾아볼 수 있다.

## 요약
-   요소를 더하거나 지우기
    
    -   `push(...items)`: 맨 끝에 요소 추가하기. 원본 배열 변경됨.
    -   `pop()`: 맨 끝 요소 추출하기. 원본 배열 변경됨.
    -   `shift()`: 첫 요소 추출하기. 원본 배열 변경됨.
    -   `unshift(...items)`: 맨 앞에 요소 추가하기. 원본 배열 변경됨.
    -   `splice(pos, deleteCount, ...items)`: `pos`부터  `deleteCount`개의 요소를 지우고, `items` 추가하기. 원본 배열 변경됨.
    -   `slice(start, end)`: `start`부터  `end`  바로 앞까지의 요소를 복사해 새로운 배열을 만듦. 원본 배열 유지됨.
    -   `concat(...items)`: 배열의 모든 요소를 복사하고  `items`를 추가해 새로운 배열을 만든 후 이를 반환함.  `items`가 배열이면 이 배열의 인수를 기존 배열에 더해줌. 원본 배열 유지됨.
-   원하는 요소 찾기: 모두 원본 배열 유지됨.
    
    -   `indexOf/lastIndexOf(item, pos)`: `pos`부터 원하는  `item`을 찾음. 찾게 되면 해당 요소의 인덱스를, 아니면  `-1`을 반환함.
    -   `includes(value)`: 배열에  `value`가 있으면  `true`를, 그렇지 않으면  `false`를 반환함.
    -   `find/filter(func)`: `func`의 반환 값을  `true`로 만드는 첫 번째/전체 요소를 반환함.
    -   `findIndex`는  `find`와 유사함. 다만 요소 대신 인덱스를 반환함.
-   배열 전체 순회하기
    
    -   `forEach(func)`: 모든 요소에  `func`을 호출함. 결과는 반환되지 않음.
-   배열 변형하기
    
    -   `map(func)`: 모든 요소에서  `func`을 호출하고, 반환된 결과를 가지고 새로운 배열을 만듦. 원본 배열 유지됨.
    -   `sort(func)`: 배열을 정렬하고 정렬된 배열을 반환함. 원본 배열 변경됨.
    -   `reverse()`: 배열을 뒤집어 반환함. 원본 배열 변경됨.
    -   `split/join`: 문자열을 배열로, 배열을 문자열로 변환함. 원본 배열 유지됨.
    -   `reduce(func, initial)`: 요소를 차례로 돌면서  `func`을 호출함. 반환값은 다음 함수 호출에 전달함. 최종적으로 하나의 값이 도출됨. 원본 배열 유지됨.
-   기타
    
    -   `Array.isArray(arr)`: `arr`이 배열인지 여부를 판단함.
<br></br>
# 06. iterable 객체
<strong>반복 가능한(iterable, 이터러블)</strong> 객체는 배열을 일반화한 객체이다. 이터러블을 사용하면 어떤 객체에든 `for...of` 반복문을 적용할 수 있다.

배열과 문자열은 대표적인 이터러블이다.

## Symbol.iterator
어떤 객체를 이터러블로 만들려면(`for...of`가 동작하도록 하려면) `Symbol.iterator`(특수 내장 심볼)라는 메서드를 추가해 아래와 같은 과정이 가능하도록 해야 한다.
1.  `for..of`가 시작되면 `Symbol.iterator`를 호출된다(`Symbol.iterator`가 없으면 에러가 발생한다).  `Symbol.iterator`는 반드시  이터레이터(iterator, 메서드  `next`가 있는 객체)를 반환해야 한다.
2.  이후  `for...of`는  반환된 객체(이터레이터)만을 대상으로 동작한다.
3.  `for...of`에 다음 값이 필요하면,  `for...of`는 이터레이터의  `next()`메서드를 호출한다.
4.  `next()`의 반환 값은  `{done: Boolean, value: any}`와 같은 형태이어야 한다.  `done=true`는 반복이 종료되었음을 의미한다.  `done=false`일땐  `value`에 다음 값이 저장된다.

이터러블 객체의 핵심은 '관심사의 분리(Separation of concern, SoC)'에 있다. 이터레이터 객체와 반복 대상인 객체의 분리는 다음과 같이 구현한다.
-   `range`에는 메서드  `next()`가 없다.
-   대신  `range[Symbol.iterator]()`를 호출해서 만든 ‘이터레이터’ 객체와 이 객체의 메서드  `next()`에서 반복에 사용될 값을 만들어낸다.
```js
let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return {done: false, value: this.current++};
    } else {
      return {done: true};
    }
  }
};

for (let num of range) {
  alert(num); // 1, then 2, 3, 4, 5
}
```

---
:information_source: **무한개의 이터레이터**

`range`에서  `range.to`에  `Infinity`를 할당하면  `range`가 무한대가 된다. 무수히 많은 의사 난수(pseudorandom numbers)를 생성하는 이터러블 객체를 만드는 것도 가능하다. 이 방법이 유용하게 쓰이는 경우도 있다.

`next`에는 제약사항이 없다.  `next`가 값을 계속 반환하는 것은 정상적인 동작이다.

물론 위와 같은 이터러블에  `for...of`  반복문을 사용하면 끝이 없을 것이다. 그렇다 하더라도  `break`를 사용하면 언제든지 반복을 멈출 수 있다.

## 문자열은 이터러블이다
배열과 문자열은 가장 광범위하게 쓰이는 내장 이터러블이다. `for...of`는 문자열의 각 글자를 순회한다.
```js
for (let char of 'test') {
  // 글자 하나당 한 번 실행된다(4회 호출).
  alert(char); // t, e, s, t가 차례대로 출력된다.
}
```
서로게이트 쌍(surrogate pair)에도 잘 동작한다.
```js
let str = '𝒳😂';
for (let char of str) {
    alert(char); // 𝒳와 😂가 차례대로 출력된다.
}
```

## 이터레이터를 명시적으로 호출하기
```js
let str = 'Hello';

// for...of를 사용한 것과 동일한 작업을 한다.
// for (let char of str) alert(char);

let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // 글자가 하나씩 출력된다.
}
```
이터레이터를 명시적으로 호출하는 경우는 거의 없지만, 이 방법을 사용하면 `for..of`를 사용하는 것보다 반복 과정을 더 잘 통제할 수 있다는 장점이 있다. 반복을 시작했다가 잠시 멈추고 다른 작업을 하다가, 다시 반복을 시작하는 것과 같이 반복 과정을 여러 개로 나누는 것이 가능하다.

## 이터러블과 유사 배열 [#array-like]
비슷해 보이지만 아주 다른 용어 두 가지가 있다.
-   이터러블(iterable)은 위에서 설명한 바와 같이 메서드  `Symbol.iterator`가 구현된 객체이다.
-   유사 배열(array-like)은 인덱스와  `length`  프로퍼티가 있어서 배열처럼 보이는 객체이다.

브라우저나 등의 호스트 환경에서 자바스크립트를 사용해 문제를 해결할 때 이터러블 객체, 유사 배열 객체, 혹은 둘 다인 객체를 만날 수 있다. 이터러블 객체(`for..of` 를 사용할 수 있음)이면서 유사배열 객체(숫자 인덱스와 `length` 프로퍼티가 있음)인 문자열이 대표적인 예이다.

이터러블 객체라고 해서 유사 배열 객체는 아니다. 유사 배열 객체라고 해서 이터러블 객체인 것도 아니다. 위 예시의 `range`는 이터러블 객체이지만 인덱스도 없고 `length` 프로퍼티도 없으므로 유사 배열 객체가 아니다. 아래 예시의 객체는 유사 배열 객체이지만 이터러블 객체가 아니다.
```js
let arrayLike = { // 인덱스와 length프로퍼티가 있으므로 유사 배열이다.
  0: 'Hello',
  1: 'World',
  length: 2
};

// Symbol.iterator가 없으므로 에러가 발생한다.
for (let item of arrayLike) {}
```
이터러블과 유사 배열은 보통 배열이 아니기 때문에  `push`, `pop` 등의 메서드를 지원하지 않는다. 이터러블과 유사 배열에 배열 메서드를 적용하는 방법은 다음 챕터에서 바로 알아보겠다.

## Array.from
범용 메서드 [Array.from](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/from)는 이터러블이나 유사 배열을 받아 ‘진짜’ 배열을 만들어준다. 이 과정을 거치면 이터러블이나 유사 배열에 배열 메서드를 사용할 수 있다.
```js
let arrayLike = {
  0: 'Hello',
  1: 'World',
  length: 2
};

let arr = Array.from(arrayLike);
alert(arr.pop()); // World, 메서드가 제대로 동작한다.
```
`Array.from`은 인수로 받은 객체가 이터러블이나 유사 배열인지 확인한다. 넘겨 받은 인수가 이터러블이나 유사 배열인 경우, 새로운 배열을 만들고 객체의 모든 요소를 새롭게 만든 배열로 복사한다.

`Array.from`에 ‘매핑(mapping)’ 함수를 선택적으로 넘겨줄 수 있다. `mapFn`을 두 번째 인수로 넘겨주면 각 요소를 대상으로 `mapFn`을 적용할 수 있다. 새로운 배열에는 `mapFn`을 적용하고 반환된 값이 추가된다. 세 번째 인수 `thisArg`는 각 요소의 `this`를 지정할 수 있다.
```js
Array.from(obj, [mapFn], [thisArg])
```
```js
// range는 챕터 위쪽 예시에서 그대로 가져왔다고 가정한다.

// 각 숫자를 제곱한다.
let arr = Array.from(range, num => num * num);

alert(arr); // 1,4,9,16,25
```
다음 예시에서는 `Array.from`를 사용해 문자열을 배열로 만들어보았다.
```js
let str = '𝒳😂';

// str를 분해해서 글자가 담긴 배열로 만들었다.
let chars = Array.from(str);

alert(chars[0]); // 𝒳
alert(chars[1]); // 😂
alert(chars.length); // 2
```
`Array.from`은 `str.split`과 달리, 문자열 자체가 가진 이터러블 속성을 이용해 동작한다. 따라서 `for...of`처럼 서로게이트 쌍에도 제대로 적용된다.

`Array.from`을 사용하면 서로게이트 쌍을 처리할 수 있는 `slice`를 직접 구현할 수도 있다.
```js
function slice(str, start, end) {
  return Array.from(str).slice(start, end).join('');
}

let str = '𝒳😂𩷶';

alert(slice(str, 1, 3)); // 😂𩷶

// 내장 순수 메서드는 서로게이트 쌍을 지원하지 않는다.
alert(str.slice(1, 3)); // 쓰레기값(영역이 다른 특수 값)이 출력된다.
```
<br></br>
# 07. 맵과 셋
## 맵
[맵(Map)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/map)은 키가 있는 데이터를 저장한다는 점에서  객체와 유사하지만 **키에 다양한 자료형을 허용한다**는 점에서 차이가 있다.

맵에는 다음과 같은 주요 메서드와 프로퍼티가 있다.
-   `new Map()`  – 맵을 만든다.
-   `map.set(key, value)`  –  `key`를 이용해  `value`를 저장한다.
-   `map.get(key)`  –  `key`에 해당하는 값을 반환한다.  `key`가 존재하지 않으면  `undefined`를 반환한다.
-   `map.has(key)`  –  `key`가 존재하면  `true`, 존재하지 않으면  `false`를 반환한다.
-   `map.delete(key)`  –  `key`에 해당하는 값을 삭제한다.
-   `map.clear()`  – 맵 안의 모든 요소를 제거한다.
-   `map.size`  – 요소의 개수를 반환한다.

맵은 객체와 다르게 키를 문자형으로 변환하지 않는다. 키에 자료형 제약이 없다.
```js
let map = new Map();

map.set('1', 'str1');   // 문자형 키
map.set(1, 'num1');     // 숫자형 키
map.set(true, 'bool1'); // 불린형 키

// 객체는 키를 문자형으로 변환하는 반면, 맵은 키의 타입을 변환시키지 않고 그대로 유지한다. 
// 따라서 아래의 코드는 출력되는 값이 다르다.
alert(map.get(1)); // 'num1'
alert(map.get('1')); // 'str1'

alert(map.size); // 3
```

---
:information_source: **`map[key]`는 `Map`을 쓰는 올바른 방법이 아니다.**

`map[key]`를 사용하는 것이 가능은 하지만, `map`을 사용할 때는 `map`전용 메서드 `set`, `get` 등을 사용해야 한다.

---

**맵은 키에 객체를 사용할 수 있다.** 객체는 키에 객체를 사용할 수 없다.
```js run
let john = {name: 'John'};

let visitsCountMap = new Map();

// john을 맵의 키로 사용한다.
visitsCountMap.set(john, 123);

alert(visitsCountMap.get(john)); // 123
```

---
:information_source: **맵이 키를 비교하는 방식**

맵은 SameValueZero라는 알고리즘을 사용해 값의 등가 여부를 확인한다. 이 알고리즘은 일치 연산자 `===`와 거의 유사하지만, `NaN`과 `NaN`을 같다고 취급하는 것에서 일치 연산자와 차이가 있다. 따라서 맵에서는 `NaN`도 키로 쓸 수 있다.

---
:information_source: **체이닝**

`map.set`을 호출할 때마다 맵 자신이 반환된다. 이를 이용하면 `map.set`을 '체이닝(chaining)'할 수 있다.
```js
map.set('1', 'str1')
  .set(1, 'num1')
  .set(true, 'bool1');
```

## 맵의 요소에 반복 작업하기
다음 세 가지 메서드를 사용해서 맵의 각 요소에 반복 작업을 할 수 있다.
-   `map.keys()`  – 각 요소의 키를 모은 반복 가능한(iterable, 이터러블) 객체를 반환한다.
-   `map.values()`  – 각 요소의 값을 모은 이터러블 객체를 반환한다.
-   `map.entries()`  – 요소의  `[키, 값]`을 한 쌍으로 하는 이터러블 객체를 반환한다. 이 이터러블 객체는  `for...of`반복문의 기초로 쓰인다.
```js
let recipeMap = new Map([
  ['cucumber', 500],
  ['tomatoes', 350],
  ['onion',    50]
]);

// 키(vegetable)를 대상으로 순회한다.
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // cucumber, tomatoes, onion
}

// 값(amount)을 대상으로 순회한다.
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// [키, 값] 쌍을 대상으로 순회한다. 
for (let entry of recipeMap) { // recipeMap.entries()와 동일하다.
  alert(entry); // cucumber,500 ...
}
```

---
:information_source: **맵은 삽입 순서를 기억한다.**

맵은 값이 삽입된 순서대로 순회를 실시한다. 객체는 프로퍼티 순서를 기억하지 못하는 것과는 다르다.

---

맵은 배열과 유사하게 내장 메서드 `forEach`도 지원한다.
```js
// 각 (키, 값) 쌍을 대상으로 함수를 실행한다.
recipeMap.forEach((value, key, map) => {
  alert(`${key}: ${value}`); // cucumber: 500 ...
});
```

## Object.entries: 객체를 맵으로 바꾸기
각 요소가 키-값 쌍인 배열이나 이터러블 객체를 초기화 용도로 맵에 전달해 새로운 맵을 만들 수 있다.
```js
// 각 요소가 [키, 값] 쌍인 배열
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);

alert(map.get('1')); // str1
```
평범한 객체를 `맵`으로 만들고 싶다면 내장 메서드 [Object.entries(obj)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)를 활용해야 한다. 이 메서드는 객체의 키-값 쌍을 요소(`[key, value]`)로 가지는 배열을 반환한다.
```js
let obj = {
  name: 'John',
  age: 30
};

let map = new Map(Object.entries(obj));

alert(map.get('name')); // John
```

## Object.fromEntries: 맵을 객체로 바꾸기
`Object.fromEntries`를 사용하면 맵을 객체로 바꿀 수 있다. 이 메서드는 각 요소가 `[키, 값]` 쌍인 배열을 객체로 바꿔준다.
```js
let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);

// prices = {banana: 1, orange: 2, meat: 4}

alert(prices.orange); // 2
```
맵을 객체로 바꾸는 것이 가능하다.
```js
let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

// 인자로 map 대신 map.entries()을 넣어도 동일하다.
let obj = Object.fromEntries(map);

// 맵이 객체가 되었다.
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2
```

## 셋
셋(Set)은 중복을 허용하지 않는 값을 모아놓은 특별한 컬렉션이다. 셋에는 키가 없는 값이 저장된다.

주요 메서드는 다음과 같다.
-   `new Set(iterable)`  – 셋을 만든다.  `이터러블`  객체를 전달받으면(대개 배열을 전달받음) 그 안의 값을 복사해 셋에 넣어준다.
-   `set.add(value)`  – 값을 추가하고 셋 자신을 반환한다.
-   `set.delete(value)`  – 값을 제거한다. 호출 시점에 셋 내에 값이 있어서 제거에 성공하면  `true`, 아니면  `false`를 반환한다.
-   `set.has(value)`  – 셋 내에 값이 존재하면  `true`, 아니면  `false`를 반환한다.
-   `set.clear()`  – 셋을 비운다.
-   `set.size`  – 셋에 들어있는 값의 개수를 반환한다.

셋 내에 동일한 값(value)이 있다면 `set.add(value)`을 아무리 많이 호출해도 반응이 없다. 셋 내의 값에 중복이 없는 이유가 바로 이 때문이다.
```js
let set = new Set();

let john = {name: 'John'};
let pete = {name: 'Pete'};
let mary = {name: 'Mary'};

set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// 셋에는 유일한 값만 저장된다.
alert( set.size ); // 3

for (let user of set) {
  alert(user.name); // // John, Pete, Mary 순으로 출력된다.
}
```
`셋` 대신 배열을 사용하여 방문자 정보를 저장한 후, 중복 값 여부는 배열 메서드인 [arr.find](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/find)를 이용해 확인할 수도 있다. 하지만 `arr.find`는 배열 내 요소 전체를 검색해서 중복 값을 찾기 때문에, 셋보다 성능 면에서 떨어진다.

## 셋의 값에 반복 작업하기
`for...of`나 `forEach`를 사용하면 셋의 값을 대상으로 반복 작업을 수행할 수 있다.
```js
let set = new Set(['oranges', 'apples', 'bananas']);

for (let value of set) alert(value);

// forEach를 사용해도 동일하게 동작한다.
set.forEach((value, valueAgain, set) => {
  alert(value);
});
```
`forEach`에 쓰인 콜백 함수는 세 개의 인수를 받는데, 첫 번째는 `값`, 두 번째도 같은 값인 `valueAgain`을 받고 있다. 세 번째는 목표하는 객체(셋)이다. 동일한 값이 인수에 두 번 등장하는데, 이것은 맵과의 호환성 때문이다. 이렇게 구현해 놓았기 때문에 맵을 셋으로 혹은 셋을 맵으로 교체하기가 쉽다는 장점이 있다.

셋에도 맵과 마찬가지로 반복 작업을 위한 메서드가 있다.
-   `set.keys()`  – 셋 내의 모든 값을 포함하는 이터러블 객체를 반환한다.
-   `set.values()`  –  `set.keys`와 동일한 작업을 한다.  `맵`과의 호환성을 위해 만들어진 메서드이다.
-   `set.entries()`  – 셋 내의 각 값을 이용해 만든  `[value, value]`  배열을 포함하는 이터러블 객체를 반환한다.  `맵`과의 호환성을 위해 만들어졌다.
<br></br>
# 08. 위크맵과 위크셋
자료구조를 구성하는 요소는 자신이 속한 자료구조가 메모리에 남아있는 동안 메모리에서 삭제되지 않는다. 객체의 프로퍼티나 배열의 요소, 맵이나 셋을 구성하는 요소들이 이에 해당한다.
```js
let john = {name: 'John'};
let array = [john];

john = null; // 참조를 null로 덮어쓴다.

// john을 나타내는 객체는 배열의 요소이기 때문에 가비지 컬렉터의 대상이 되지 않는다.
// array[0]을 이용하면 해당 객체를 얻는 것도 가능하다.
alert(JSON.stringify(array[0]));
```
맵에서 객체를 키로 사용한 경우 역시, 맵이 메모리에 있는 한 객체도 메모리에 남는다. 가비지 컬렉터의 대상이 되지 않는다.

반면 위크맵(WeakMap)은 일반 맵과 전혀 다른 양상을 보인다. 위크맵을 사용하면 키로 쓰인 객체가 가비지 컬렉션의 대상이 된다.

## 위크맵
맵과 위크맵의 첫 번째 차이는 위크맵의 **키가 반드시 객체여야 한다**는 것이다. 원시값은 위크맵의 키가 될 수 없다.

위크맵의 키로 사용된 객체를 참조하는 것이 아무것도 없다면 해당 객체는 메모리와 위크맵에서 자동으로 삭제된다.
```js
let john = {name: 'John'};

let weakMap = new WeakMap();
weakMap.set(john, '...');

john = null; // 참조를 덮어쓴다.

// john을 나타내는 객체는 이제 메모리에서 지워졌다.
```

맵과 위크맵의 두 번째 차이는 위크맵은 반복 작업과 `keys()`, `values()`, `entries()` 메서드를 지원하지 않는다는 것이다. 따라서 위크맵에서는 키나 값 전체를 얻는 게 불가능하다.

위크맵이 지원하는 메서드는 맵에 비해 단출하다.
-   `weakMap.get(key)`
-   `weakMap.set(key, value)`
-   `weakMap.delete(key)`
-   `weakMap.has(key)`

이렇게 지원하는 메소드가 적은 이유는 가비지 컬렉션의 동작 방식 때문이다.

## 유스 케이스: 추가 데이터
위크맵은 **부차적인 데이터를 저장**할 곳이 필요할 때 그 진가를 발휘한다.

서드파티 라이브러리와 같은 외부 코드에 속한 객체를 가지고 작업을 해야 하는 상황에서 위크맵을 사용할 수 있다. 이 객체에 추가할 데이터를 객체가 살아있는 동안에만 유효하도록 만들 수 있다.

위크맵에 원하는 데이터를 저장하는데, 이때 **키는 객체를 사용**하면 된다. 이렇게 하면 객체가 가비지 컬렉션의 대상이 될 때, 데이터도 함께 사라지게 된다.
```js
weakMap.set(john, '비밀문서');
// john이 사망하면, 비밀문서는 자동으로 파기된다.
```
```js
// 📁 visitsCount.js
let visitsCountMap = new WeakMap(); // 위크맵에 사용자의 방문 횟수를 저장한다.

// 사용자가 방문하면 방문 횟수를 늘려준다.
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
```
위크맵을 사용해 사용자 방문 횟수를 저장하면 `visitsCountMap`을 수동으로 청소해줄 필요가 없다. `john`을 나타내는 객체가 도달 가능하지 않은 상태가 되면 자동으로 메모리에서 삭제되기 때문이다.

## 유스 케이스: 캐싱
캐싱(caching)은 시간이 오래 걸리는 작업의 결과를 저장해서 연산 시간과 비용을 절약해주는 기법이다. 동일한 함수를 여러 번 호출해야 할 때, 최초 호출 시 반환된 값을 어딘가에 저장해 놓았다가 그다음에는 함수를 호출하는 대신 저장된 값을 사용하는 것이 캐싱의 한 예시이다.
```js
// 📁 cache.js
let cache = new WeakMap();

// 연산을 수행하고 그 결과를 위크맵에 저장한다.
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* 연산 수행 */ obj;

    cache.set(obj, result);
  }

  return cache.get(obj);
}

// 📁 main.js
let obj = {/* ... 객체 ... */};

let result1 = process(obj);
let result2 = process(obj);

// 객체가 쓸모없어지면 아래와 같이 null로 덮어쓴다.
obj = null;

// 이 예시에선 맵을 사용한 예시처럼 cache.size를 사용할 수 없다.
// 하지만 obj가 가비지 컬렉션의 대상이 되므로, 캐싱된 데이터 역시 메모리에서 삭제될 것이다.
// 삭제가 진행되면 cache에는 그 어떤 요소도 남아있지 않을 것이다.
```

## 위크셋
-   위크셋(WeakSet)은  셋과 유사한데, 객체만 저장할 수 있다는 점이 다르다. 원시값은 저장할 수 없다.
-   셋 안의 객체는 도달 가능할 때만 메모리에서 유지된다.
-   셋과 동일하게  위크셋은  `add`,  `has`,  `delete`를 지원한다.  `size`,  `keys()`, 반복 작업 관련 메서드는 사용할 수 없다.

위크맵과 유사하게 위크셋도 부차적인 데이터를 저장할 때 사용할 수 있다. 다만, 위크셋에는 위크맵처럼 복잡한 데이터를 저장하지 않는다. 대신 "예"나 “아니오” 같은 간단한 데이터를 저장하는 용도로 사용된다. 물론 위크셋에 저장되는 값들은 객체여야 한다.
```js
let visitedSet = new WeakSet();

let john = {name: 'John'};
let pete = {name: 'Pete'};
let mary = {name: 'Mary'};

visitedSet.add(john); // John이 사이트를 방문한다.
visitedSet.add(pete); // 이어서 Pete가 사이트를 방문한다.
visitedSet.add(john); // 이어서 John이 다시 사이트를 방문한다.

// visitedSet에는 두 명의 사용자가 저장된다.

// John의 방문 여부를 확인한다.
alert(visitedSet.has(john)); // true

// Mary의 방문 여부를 확인한다.
alert(visitedSet.has(mary)); // false

john = null;

// visitedSet에서 john을 나타내는 객체가 자동으로 삭제된다.
```

위크맵과 위크셋의 가장 큰 단점은 반복 작업이 불가능하다는 것이다. 위크맵이나 위크셋에 저장된 자료를 한 번에 얻는 것이 불가능하다. 하지만 이런 단점이 위크맵과 위크셋의 주 용도인, 다른 곳에서 저장⋅관리되는 객체의 추가 데이터 저장소 역할을 수행하는 데에 문제가 되지는 않는다.
<br></br>
# 09. Object.keys, values, entries
`keys()`,  `values()`,  `entries()`를 사용할 수 있는 자료구조는 다음과 같다.
-   `Map`
-   `Set`
-   `Array`

일반 객체에도 순회 관련 메서드가 있지만,  `keys()`,  `values()`,  `entries()`와는 문법의 차이가 있다.

## Object.keys, values, entries
일반 객체에서는 다음과 같은 메서드를 사용할 수 있다.
-   [Object.keys(obj)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)  – 객체의 키만 담은 배열을 반환합니다.
-   [Object.values(obj)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/values)  – 객체의 값만 담은 배열을 반환합니다.
-   [Object.entries(obj)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)  –  `[키, 값]`  쌍을 담은 배열을 반환합니다.

`Map`, `Set`, `Array` 전용 메서드와 일반 객체용 메서드의 차이를 (맵을 기준으로) 비교하면 다음과 같다.
|        |맵           |객체                          |
|--------|------------|------------------------------|
|호출 문법 |`map.keys()`|`Object.keys(obj)`(인수가 있음)|
|반환 값  |iterable 객체|'진짜' 배열                    |

첫 번째 차이는 `obj.keys()`가 아닌 `Object.keys(obj)`를 호출한다는 것이다. 이렇게 문법이 다른 이유는 유연성 때문이다.

두 번째 차이는 메서드 `Object.*`를 호출하면 iterable 객체가 아닌 객체의 한 종류인 배열을 반환한다는 것이다. ‘진짜’ 배열을 반환하는 이유는 하위 호환성 때문이다.

```js
let user = {
  name: "John",
  age: 30
};
```
위 객체에 대해 메서드를 사용한 결과는 다음과 같다.
-   `Object.keys(user) = ['name', 'age']`
-   `Object.values(user) = ['John', 30]`
-   `Object.entries(user) = [['name','John'], ['age',30]]`

아래 예시처럼 `Object.values`를 사용하면 프로퍼티 값을 대상으로 원하는 작업을 할 수 있다.
```js
let user = {
  name: 'Violet',
  age: 30
};

// 값을 순회합니다.
for (let value of Object.values(user)) {
  alert(value); // Violet과 30이 출력된다.
}
```

---
:warning: **Object.keys, values, entries는 심볼형 프로퍼티를 무시한다.**
`for...in` 반복문과 동일하게 Object.keys, Object.values, Object.entries는 키가 심볼형인 프로퍼티를 무시한다.

심볼형 키가 필요한 경우에는 심볼형 키만 배열 형태로 반환해주는 메서드인 [Object.getOwnPropertySymbols](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols)를 사용하면 된다. 또는 심볼형을 포함한 키 전체를 배열 형태로 반환하는 메서드인 [Reflect.ownKeys(obj)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys)를 사용할 수 있다.

---

## 객체 변환하기
객체에는  `map`,  `filter`  같은 배열 전용 메서드를 사용할 수 없다.

하지만  `Object.entries`와  `Object.fromEntries`를 순차적으로 적용하면 객체에도 배열 전용 메서드를 사용할 수 있다. 적용 방법은 다음과 같다.
1.  `Object.entries(obj)`를 사용해서 객체의 키-값 쌍이 요소인 배열을 얻는다.
2.  1.에서 만든 배열에  `map`  등의 배열 전용 메서드를 적용한다.
3.  2.에서 반환된 배열에  `Object.fromEntries(array)`를 적용해 배열을 다시 객체로 되돌린다.
```js
let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

let doublePrices = Object.fromEntries(
  // 객체를 배열로 변환해서 배열 전용 메서드인 map을 적용하고 fromEntries를 사용해 배열을 다시 객체로 되돌린다.
  Object.entries(prices).map(([key, value]) => [key, value * 2])
);

alert(doublePrices.meat); // 8
```
<br></br>
# 10. 구조 분해 할당
개발을 하다 보면 함수에 객체나 배열을 전달해야 하는 경우가 생긴다. 또는 객체나 배열에 저장된 데이터 전체가 아닌 일부만 필요한 경우가 생긴다.

이럴 때 객체나 배열을 변수로 '분해’할 수 있게 해주는 특별한 문법인  <strong>구조 분해 할당(destructuring assignment)</strong>을 사용할 수 있다. 이 외에도 함수의 매개변수가 많거나 매개변수 기본값이 필요한 경우 등에서 구조 분해(destructuring)는 그 진가를 발휘한다.

## 배열 분해하기
```js
// 이름과 성을 요소로 가진 배열이다.
let arr = ['Bora', 'Lee']

// 구조 분해 할당을 이용해 firstName에는 arr[0]을, surname에는 arr[1]을 할당하였다.
let [firstName, surname] = arr;

alert(firstName); // Bora
alert(surname);  // Lee
```

반환 값이 배열인 `split` 같은 메서드를 구조 분해 할당에 활용할 수 있다.
```js
let [firstName, surname] = 'Bora Lee'.split(' ');
```

---
:information_source: **'분해(destructuring)'는 '파괴(destructive)'를 의미하지 않는다.**

구조 분해 할당이라는 명칭은 어떤 것을 복사한 이후에 변수로 '분해(destructurize)'해준다는 의미 때문에 붙여졌다. 이 과정에서 분해 대상은 수정되거나 파괴되지 않는다.

---
:information_source: **쉼표를 사용하여 요소를 무시할 수 있다.**

쉼표를 사용하면 필요하지 않은 배열 요소를 버릴 수 있다.
```js
// 두 번째 요소는 필요하지 않음
let [firstName, , title] = ['Julius', 'Caesar', 'Consul', 'of the Roman Republic'];

alert(title); // Consul
```
---
:information_source: **할당 연산자 우측에는 모든 이터러블이 올 수 있다.**

배열뿐만 아니라 모든 이터러블(iterable, 반복 가능한 객체)에 구조 분해 할당을 적용할 수 있다.
```js
let [a, b, c] = 'abc'; // ['a', 'b', 'c']
let [one, two, three] = new Set([1, 2, 3]);
```
---
:information_source: **할당 연산자 좌측에는 무엇이든 올 수 있다.**

할당 연산자 좌측에는 ‘할당할 수 있는(assignables)’ 것이라면 어떤 것이든 올 수 있다. 아래와 같이 객체 프로퍼티도 가능하다.
```js
let user = {};
[user.name, user.surname] = 'Bora Lee'.split(' ');

alert(user.name); // Bora
```
---
:information_source: **.entries()로 반복하기**

[Object.entries(obj)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)와 구조 분해를 조합하면 객체의 키와 값을 순회해서 변수로 분해 할당할 수 있다.
```js
let user = {
  name: 'John',
  age: 30
};

// 객체의 키와 값을 순회한다.
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, age:30이 차례대로 출력된다.
}
```
맵은 이터러블 객체이므로 비슷한 기능을 하는 코드가 더 간단하다.
```js
let user = new Map();
user.set('name', 'John');
user.set('age', '30');

for (let [key, value] of user) {
  alert(`${key}:${value}`); // name:John, then age:30
}
```
---
:information_source: **변수 교환 트릭**

두 변수에 저장된 값을 교환할 때 구조 분해 할당을 활용할 수 있다. 이 방식을 사용하면 두 개뿐만 아니라 여러 개의 변수에 담긴 값도 교환할 수 있다.
```js
let guest = 'Jane';
let admin = 'Pete';

// 변수 guest에는 Pete, 변수 admin에는 Jane이 저장되도록 값을 교환한다.
[guest, admin] = [admin, guest];

alert(`${guest} ${admin}`); // Pete Jane(값 교환이 성공적으로 이뤄졌다)
```
---

### '...'로 나머지 요소 가져오기
배열 앞쪽에 위치한 값 몇 개만 필요하고 나머지 값들은 한데 모아서 저장하고 싶을 때가 있다. 이럴 때는 점 세 개 `...`를 붙인 매개변수 하나를 추가하면 ‘나머지(rest)’ 요소를 가져올 수 있다.
```js
let [name1, name2, ...rest] = ['Julius', 'Caesar', 'Consul', 'of the Roman Republic'];

alert(name1); // Julius
alert(name2); // Caesar

// `rest`는 배열이다.
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2
```
`rest`는 나머지 배열 요소들이 저장된 새로운 배열이 된다.

### 기본값
할당하고자 하는 변수의 개수가 분해하고자 하는 배열의 길이보다 크더라도 에러가 발생하지 않는다. 할당할 값이 없으면 undefined로 할당되기 때문이다.
```js
let [firstName, surname] = [];

alert(firstName); // undefined
alert(surname); // undefined
```
`=`을 이용하면 '기본값(default value)'을 설정할 수 있다.
```js
// 기본값
let [name = 'Guest', surname = 'Anonymous'] = ['Julius'];

alert(name);    // Julius(배열에서 받아온 값)
alert(surname); // Anonymous(기본값)
```
복잡한 표현식이나 함수 호출도 기본값이 될 수 있다. 이렇게 기본값으로 표현식이나 함수를 설정하면 할당할 값이 없을 때 표현식이 평가되거나 함수가 호출된다.
```js
// name의 prompt만 실행된다.
let [surname = prompt('성을 입력하세요.'), name = prompt('이름을 입력하세요.')] = ['김'];

alert(surname); // 김(배열에서 받아온 값)
alert(name);    // prompt에서 받아온 값
```

## 객체 분해하기
```js
let {var1, var2} = {var1: ..., var2: ...}
```
할당 연산자 우측에는 분해하고자 하는 객체를, 좌측에는 상응하는 객체 프로퍼티의 '패턴’을 넣는다.
```js
let options = {
  title: 'Menu',
  width: 100,
  height: 200
};

let {title, width, height} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
```
프로퍼티 `options.title`, `options.width`, `options.height`에 저장된 값이 상응하는 변수에 할당된 것을 확인할 수 있다. 참고로 **순서는 상관이 없다.**

할당 연산자 좌측에는 복잡한 패턴이 올 수 있다. 분해하려는 객체의 프로퍼티와 변수의 연결을 원하는 대로 조정할 수 있다. 콜론(:)을 사용하면 객체 프로퍼티를 프로퍼티 키와 다른 이름을 가진 변수에 저장할 수 있다. 콜론은 '분해하려는 객체의 프로퍼티: 목표 변수’와 같은 형태로 사용한다.
```js
let options = {
  title: 'Menu',
  width: 100,
  height: 200
};

// {객체 프로퍼티: 목표 변수}
let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title

alert(title); // Menu
alert(w);     // 100
alert(h);     // 200
```
프로퍼티가 없는 경우를 대비해서 `=`을 사용해 기본값을 설정하는 것도 가능하다.
```js
let options = {
  title: 'Menu'
};

let {width = 100, height = 200, title} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
```
배열 혹은 함수의 매개변수에서 했던 것처럼 객체에도 표현식이나 함수 호출을 기본값으로 할당할 수 있다.
```js
let options = {
  title: 'Menu'
};

let {width = prompt('width?'), title = prompt('title?')} = options;

alert(title); // Menu
alert(width); // prompt 창에 입력한 값
```
콜론과 할당 연산자를 동시에 사용할 수도 있다.
```js
let options = {
  title: 'Menu'
};

let {width: w = 100, height: h = 200, title} = options;

alert(title); // Menu
alert(w);     // 100
alert(h);     // 200
```

### 나머지 패턴 '...'
나머지 패턴(rest pattern)을 사용하면, 배열에서 했던 것처럼 나머지 프로퍼티를 변수에 할당하는 것이 가능하다. 참고로 모던 브라우저는 나머지 패턴을 지원하지만, IE를 비롯한 몇몇 구식 브라우저는 나머지 패턴을 지원하지 않는다. 물론 바벨(Babel)을 이용하면 문제없이 사용할 수 있다.
```js
let options = {
  title: 'Menu',
  height: 200,
  width: 100
};

// title = 이름이 title인 프로퍼티
// rest = 나머지 프로퍼티들
let {title, ...rest} = options;

// title에는 'Menu', rest에는 {height: 200, width: 100}이 할당된다.
alert(rest.height); // 200
alert(rest.width);  // 100
```

---
:information_source: **`let` 없이 사용하기**

지금까지는 할당 연산 `let {…} = {…}` 안에서 변수들을 선언하였다. `let`으로 새로운 변수를 선언하지 않고 기존에 있던 변수에 분해한 값을 할당할 수도 있는데, 이때는 주의할 점이 있다.
```js
let title, width, height;

// SyntaxError: Unexpected token '=' 이라는 에러가 아랫줄에서 발생한다.
{title, width, height} = {title: "Menu", width: 200, height: 100};
```
자바스크립트는 표현식 안에 있지 않으면서 주요 코드 흐름 상에 있는 `{...}`를 코드 블록으로 인식한다. 위 예시에서는 구조 분해 할당을 위해 사용한 `{...}`를 자바스크립트가 코드 블록으로 인식해서 에러가 발생하였다.

에러를 해결하려면 할당문을 괄호`(...)`로 감싸서 자바스크립트가 `{...}`를 코드 블록이 아닌 표현식으로 해석하게 만들면 된다.
```js
let title, width, height;

// 에러가 발생하지 않는다.
({title, width, height} = {title: 'Menu', width: 200, height: 100});

alert( title ); // Menu
```
---

## 중첩 구조 분해
객체나 배열이 다른 객체나 배열을 포함하는 경우, 좀 더 복잡한 패턴을 사용해서 중첩 배열이나 객체의 정보를 추출할 수 있다. 이를 <strong>중첩 구조 분해(nested destructuring)</strong>라고 부른다.
```js
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ['Cake', 'Donut'],
  extra: true
};

// 코드를 여러 줄에 걸쳐 작성해 의도하는 바를 명확히 드러내는 것이 좋다.
let {
  size: { // size는 여기에 할당한다.
    width,
    height
  },
  items: [item1, item2], // items는 여기에 할당한다.
  title = 'Menu' // 분해하려는 객체에 title 프로퍼티가 없으므로 기본값을 사용한다.
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut
```
위 예시에서 `size`와 `items` 자체를 할당하는 변수 대신, 그것들의 내용물을 할당하는 변수를 만들었다는 것을 주의해야 한다.

## 똑똑한 함수 매개변수
구조 분해는 매개변수가 많은 함수를 사용할 때 유용하다. 매개변수를 객체에 모아서 함수에 전달하면, 함수가 전달받은 객체를 분해하여 변수에 할당한다.
```js
// 함수에 전달할 객체
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

// 똑똑한 함수는 전달받은 객체를 분해해 변수에 즉시 할당한다.
function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
  // title, items -> 객체 options에서 가져온다.
  // width, height -> 기본값
  alert(`${title} ${width} ${height}`); // My Menu 200 100
  alert(items); // Item1, Item2
}

showMenu(options);
```
중첩 객체와 콜론을 조합한 복잡한 구조 분해도 가능하다.
```js
let options = {
  title: 'My menu',
  items: ['Item1', 'Item2']
};

function showMenu({
  title = 'Untitled',
  width: w = 100,  // width는 w에,
  height: h = 200, // height는 h에,
  items: [item1, item2] // items의 첫 번째 요소는 item1에, 두 번째 요소는 item2에 할당한다.
}) {
  alert(`${title} ${w} ${h}`); // My Menu 100 200
  alert(item1); // Item1
  alert(item2); // Item2
}

showMenu(options);
```
똑똑한 함수 매개변수 문법은 구조 분해 할당 문법과 동일하다.
```js
function({
  incomingProperty: varName = defaultValue
  ...
})
```
매개변수로 전달된 객체의 프로퍼티 `incomingProperty`는 `varName`에 할당된다. 만약 값이 없다면 `defaultValue`가 기본값으로 사용된다.

참고로 이렇게 함수 매개변수를 구조 분해할 때는 인수가 전달된다고 가정한다는 것을 주의해야 한다. 모든 인수에 기본값을 할당해 주려면 빈 객체를 명시적으로 전달해야 한다.
```js
showMenu({}); // 모든 인수에 기본값이 할당된다.

showMenu(); // 에러가 발생할 수 있다.
```
이 문제를 예방하려면 **빈 객체 `{}`를 인수 전체의 기본값으로 만들면 된다.**
```js run
function showMenu({title = 'Menu', width = 100, height = 200} = {}) {
  alert(`${title} ${width} ${height}`);
}

showMenu(); // Menu 100 200
```
이렇게 하면 어떤 경우에도 분해할 것이 생겨서 함수에 인수를 하나도 전달하지 않아도 에러가 발생하지 않는다.
<br></br>
# 11. Date 객체와 날짜
날짜를 저장할 수 있으며 날짜와 관련된 메서드를 제공하는 내장 객체 [Date](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date)에 대해 알아볼 것이다.

## 객체 생성하기
`new Date()`를 호출하면 새로운 `Date` 객체가 만들어지는데, `new Date()`는 다음과 같이 다양한 형태로 호출할 수 있다.

### `new Date()`
인수 없이 호출하면 현재 날짜와 시간이 저장된 `Date` 객체가 반환된다.
```js
let now = new Date();
alert(now); // 현재 날짜 및 시간이 출력된다.
```

### `new Date(milliseconds)`
UTC 기준(UTC+0) 1970년 1월 1일 0시 0분 0초에서 `milliseconds` 밀리초(1/1000초) 후의 시점이 저장된 `Date` 객체가 반환된다.
 ```js run
// 1970년 1월 1일 0시 0분 0초(UTC+0)를 나타내는 객체이다.
let Jan01_1970 = new Date(0);
alert(Jan01_1970);

// 1970년 1월 1일의 24시간 후는 1970년 1월 2일(UTC+0)이다.
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert(Jan02_1970);
```

1970년의 첫날을 기준으로 흘러간 밀리초를 나타내는 정수를 <strong>타임스탬프(timestamp)</strong>라고 부른다.

타임스탬프를 사용하면 날짜를 숫자 형태로 간편하게 나타낼 수 있다. `new Date(timestamp)`를 사용하면 특정 날짜가 저장된 `Date` 객체를 손쉽게 만들 수 있고, `date.getTime()` 메서드를 사용하면 `Date` 객체에서 타임스탬프를 추출하는 것도 가능하다.

1970년 1월 1일 이전 날짜에 해당하는 타임스탬프 값은 음수로 나타낸다.
```js
// 31 Dec 1969
let Dec31_1969 = new Date(-24 * 3600 * 1000);
alert(Dec31_1969);
```

### `new Date(datestring)`
인수가 하나이고 문자열이라면 해당 문자열은 자동으로 구문 분석(parsed)된다. 구문 분석에 적용되는 알고리즘은 아래 [Date.parse](https://github.com/autroshot/studyroom/blob/main/01-javascript/01-%EC%BD%94%EC%96%B4%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/05-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80%20%EC%9E%90%EB%A3%8C%ED%98%95.md#dateparse%EC%99%80-%EB%AC%B8%EC%9E%90%EC%97%B4)에서 사용하는 것과 동일하다.

### `new Date(year, month, date, hours, minutes, seconds, ms)`
주어진 인수를 조합해 만들 수 있는 날짜가 저장된 객체가 반환됩니다(지역 시간대 기준). 첫 번째와 두 번째 인수만 필숫값이다.
-   `year`는 반드시 네 자리 숫자여야 한다.  `2013`은 가능하고 `98`은 안 된다.
-   `month`는  `0`(1월)부터  `11`(12월) 사이의 숫자여야 한다.
-   `date`는 일을 나타내는데, 값이 없으면 `1`일로 처리된다.
-   `hours/minutes/seconds/ms`는 값이 없으면  `0`으로 처리된다.
```js
new Date(2011, 0, 1, 0, 0, 0, 0); // 2011년 1월 1일, 00시 00분 00초
new Date(2011, 0, 1); // hours부터는 기본값인 0이 되므로 위와 동일하다.
```
최소 정밀도는 1밀리초(1/1000초)이다.
```js
let date = new Date(2011, 0, 1, 2, 3, 4, 567);
alert(date); // 2011년 1월 1일, 02시 03분 04.567초
```

## 날짜 구성요소 얻기
`Date` 객체의 메서드를 이용하면 연, 월, 일 등의 값을 얻을 수 있다.

[getFullYear()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/getFullYear)  
연도(네 자릿수)를 반환한다.

[getMonth()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/getMonth)  
월을 반환한다(**0 이상 11 이하**).

[getDate()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/getDate)  
일을 반환한다(1 이상 31 이하). 메서드 이름을 주의해야 한다.

[getHours()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/getHours),  [getMinutes()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/getMinutes),  [getSeconds()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/getSeconds),  [getMilliseconds()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/getMilliseconds)  
시, 분, 초, 밀리초를 반환한다.

---
:warning: **`getYear()` 대신 `getFullYear()`를 사용해야 한다.**

여러 자바스크립트 엔진이 더는 사용되지 않는(deprecated) 비표준 메서드 `getYear()`을 구현하고 있다. 이 메서드는 두 자릿수 연도를 반환하는 경우가 있기 때문에 절대 사용해서는 안 된다. 연도 정보를 얻고 싶다면 `getFullYear()`를 사용해야 한다.

---

[getDay()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/getDay)  
일요일을 나타내는  `0`부터 토요일을 나타내는  `6`까지의 숫자 중 하나를 반환한다. 몇몇 나라에서 요일의 첫날이 일요일이 아니지만, **getDay에서는 항상  `0`이 일요일을 나타낸다.**

**위에서 소개한 메서드는 모두 현지 시간을 기준으로 날짜 구성요소를 반환한다.**

메서드 이름의 ‘get’ 다음에 'UTC’를 붙여주면, 표준시(UTC+0) 기준의 날짜 구성 요소를 반환해주는 메서드 [getUTCFullYear()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCFullYear), [getUTCMonth()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCMonth), [getUTCDay()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/getUTCDay)를 만들 수 있다.

아래 두 메서드는 위에서 소개한 메서드와 달리 표준시(UTC+0) 기준의 날짜 구성 요소를 반환해주는 메서드가 없다.

[getTime()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/getTime)  
주어진 일시와 1970년 1월 1일 00시 00분 00초 사이의 간격인 타임스탬프(밀리초)를 반환한다.

[getTimezoneOffset()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset)  
현지 시간과 표준 시간의 차이(분)를 반환한다.
```js
// UTC-1 시간대에서 이 예시를 실행하면 60이 출력된다.
// UTC+3 시간대에서 이 예시를 실행하면 -180이 출력된다.
alert(new Date().getTimezoneOffset());
```

## 날짜 구성요소 설정하기
-   [`setFullYear(year, [month], [date])`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/setFullYear)
-   [`setMonth(month, [date])`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/setMonth)
-   [`setDate(date)`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/setDate)
-   [`setHours(hour, [min], [sec], [ms])`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/setHours)
-   [`setMinutes(min, [sec], [ms])`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/setMinutes)
-   [`setSeconds(sec, [ms])`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/setSeconds)
-   [`setMilliseconds(ms)`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/setMilliseconds)
-   [`setTime(milliseconds)`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/setTime)(1970년 1월 1일 00:00:00 UTC부터 경과된 밀리초 단위의 날짜를 설정한다)

`setTime()`을 제외한 모든 메서드는  `setUTCHours()`같이 표준시에 따라 날짜 구성 요소를 설정해주는 메서드가 있다.

`setHours`와 같은 메서드는 여러 개의 날짜 구성요소를 동시에 설정할 수 있는데, 메서드의 인수에 없는 구성요소는 변경되지 않는다.
```js
let today = new Date();

today.setHours(0);
alert(today); // 날짜는 변경되지 않고 시만 0으로 변경된다.

today.setHours(0, 0, 0, 0);
alert(today); // 날짜는 변경되지 않고 시, 분, 초가 모두 변경된다(00시 00분 00초).
```

## 자동 고침
`Date` 객체에는 <strong>자동 고침(autocorrection)</strong>이라는 유용한 기능이 있다. 범위를 벗어나는 값을 설정하려고 하면 자동 고침 기능이 활성화되면서 값이 자동으로 수정된다.
```js
let date = new Date(2013, 0, 32); // 2013년 1월 32일은 존재하지 않는다.
alert(date); // 2013년 2월 1일이 출력된다.
```
입력받은 날짜 구성 요소가 범위를 벗어나면 초과분은 자동으로 다른 날짜 구성 요소에 배분된다.

'2016년 2월 28일’의 이틀 뒤 날짜를 구하고 싶다면 단순히 이틀을 더해주기만 하면 된다. 윤년 계산을 비롯한 나머지 작업은 `Date` 객체가 알아서 처리해 준다.
```js
let date = new Date(2016, 1, 28);
date.setDate(date.getDate() + 2);

alert(date); // 2016년 3월 1일
```
```js
let date = new Date();
date.setSeconds(date.getSeconds() + 70);

alert(date); // 70초 후의 날짜가 출력된다.
```
날짜 구성 요소에 0이나 음수를 설정하는 것도 가능하다.
```js
let date = new Date(2016, 0, 2); // 2016년 1월 2일

date.setDate(1); // 1일로 변경한다.
alert(date); // 01 Jan 2016

date.setDate(0); // 일의 최솟값은 1이므로 0을 입력하면 자동으로 이전 달의 마지막 날이 된다.
alert( date ); // 31 Dec 2015
```

## Date 객체를 숫자로 변경해 시간차 측정하기
`Date` 객체를 숫자형으로 변경하면 타임스탬프가 된다.
```js
let date = new Date();
alert(+date); // 타임스탬프(date.getTime()을 호출한 것과 동일하다)
```
이를 응용하면 날짜에 마이너스 연산자를 적용해 밀리초 기준 시차를 구할 수 있다.

다음은 스톱워치를 구현한 예시이다.
```js
let start = new Date(); // 측정 시작

// 원하는 작업을 수행한다.
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = new Date(); // 측정 종료

alert(`반복문을 모두 도는데 ${end - start} 밀리초가 걸렸습니다.`);
```

## Date.now()
시차를 측정하는 또 하나의 방법은 타임스탬프를 반환하는 메서드 `Date.now()`를 응용하는 것이다.

`Date.now()`는 `new Date().getTime()`과 의미는 동일하지만 중간에 `Date` 객체를 만들지 않는다는 점이 다르다. 따라서 `new Date().getTime()`를 사용하는 것보다 빠르고 가비지 컬렉터의 일을 덜어준다는 장점이 있다.

스톱워치 예시에 `Date.now()`를 사용하면 성능이 더 좋아진다.
```js
let start = Date.now(); // 1970년 1월 1일부터 현재까지 경과한 밀리초

// 원하는 작업을 수행한다.
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = Date.now(); // done

alert(`반복문을 모두 도는데 ${end - start} 밀리초가 걸렸습니다.`); // Date 객체가 아닌 숫자끼리 차감한다.
```

## 벤치마크 테스트
비슷한 기능을 수행하는 함수들 중 어느 것이 더 빠른지 알고 싶을 때 <strong>벤치마크(benchmark) 테스트</strong>를 시행한다.

신뢰할만한 벤치마크 테스트를 만들려면  `benchmark`를 번갈아 가면서 여러 번 돌려야 한다.
```js
function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

let time1 = 0;
let time2 = 0;

// 함수 bench를 각 함수(diffSubtract, diffGetTime)별로 10번씩 시행한다.
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}

alert('diffSubtract에 소모된 시간: ' + time1);
alert('diffGetTime에 소모된 시간: ' + time2);
```

모던 자바스크립트 엔진은 아주 많이 실행된 코드인 'hot code’를 대상으로 최적화를 수행한다. 위 예시에서 bench를 처음 실행했을 때는 최적화가 잘 되지 않은 상태이다. 따라서 메인 반복문을 실행하기 전에 예열용(heat-up)으로 bench를 실행할 수 있다.
```js
// 메인 반복문 실행 전, '예열용'으로 추가한 코드이다.
bench(diffSubtract);
bench(diffGetTime);

// 벤치마크 테스트 시작
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}
```

## Date.parse와 문자열
메서드 [Date.parse(str)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date/parse)를 사용하면 문자열에서 날짜를 읽을 수 있다.

단, 읽는 문자열의 형식은 `YYYY-MM-DDTHH:mm:ss.sssZ`이어야 한다.
-   `YYYY-MM-DD`: 날짜(연-월-일)
-   `"T"`: 구분 기호로 쓰인다.
-   `HH:mm:ss.sss`: 시:분:초.밀리초
-   `'Z'`(옵션): `+-hh:mm`  형식의 시간대를 나타낸다.  `Z`  한 글자인 경우에는 UTC+0을 나타낸다.

`YYYY-MM-DD`, `YYYY-MM`, `YYYY`같이 더 짧은 문자열 형식도 가능하다.

위 조건을 만족하는 문자열을 대상으로 `Date.parse(str)`를 사용하면 타임스탬프가 반환된다. 문자열의 형식이 조건에 맞지 않은 경우에는 `NaN`이 반환된다.
```js
let ms = Date.parse('2012-01-26T13:51:50.417-07:00');

alert(ms); // 1327611110417(타임스탬프)
```
<br></br>
# 12. JSON과 메서드
## JSON.stringify
JSON(JavaScript Object Notation)은 값이나 객체를 나타내주는 범용 포맷으로,  RFC 4627 표준에 정의되어 있다. JSON은 원래 자바스크립트에서 사용할 목적으로 만들어진 포맷이다. 그런데 자바스크립트가 아닌 언어에서도 라이브러리를 사용해서 JSON을 데이터 교환 목적으로 사용하는 경우가 많다.

자바스크립트가 제공하는 JSON 관련 메서드는 아래와 같다.
-   `JSON.stringify`  – 객체를 JSON으로 바꿔준다.
-   `JSON.parse`  – JSON을 객체로 바꿔준다.

```js
let student = {
  name: 'John',
  age: 30,
  isAdmin: false,
  courses: ['html', 'css', 'js'],
  wife: null
};

let json = JSON.stringify(student);

alert(typeof json); // 문자열이다.

alert(json);
/* JSON으로 인코딩된 객체:
{
  "name": "John",
  "age": 30,
  "isAdmin": false,
  "courses": ["html", "css", "js"],
  "wife": null
}
*/
```

`JSON.stringify(student)`를 호출하자 `student`가 문자열로 바뀐 것을 확인할 수 있다.

이렇게 변경된 문자열은 **JSON으로 인코딩된(JSON-encoded)**, **직렬화 처리된(serialized)**, **문자열로 변환된(stringified)**, **결집된(marshalled)** 객체라고 부른다. 객체는 이렇게 문자열로 변환된 후에 네트워크를 통해 전송하거나 저장소에 저장할 수 있다.

JSON으로 인코딩된 객체는 다음과 같이 일반 객체와 다른 특징을 가진다.
-   문자열은 큰따옴표로 감싸야 한다. JSON에서는 작은따옴표나 백틱을 사용할 수 없다.
-   객체 프로퍼티 이름은 큰따옴표로 감싸야 한다.

`JSON.stringify`는 객체뿐만 아니라 배열과 원시값에도 적용할 수 있다. 적용할 수 있는 자료형은 다음과 같다.
-   객체  `{ ... }`
-   배열  `[ ... ]`
-   원시형
    -   문자형
    -   숫자형
    -   불린형 값  `true`/`false`
    -   `null`

```js
alert( JSON.stringify(1) ) // 1

// 문자열은 큰따옴표로 변경된다.
alert(JSON.stringify('test')) // "test"

alert(JSON.stringify(true)); // true

alert(JSON.stringify([1, 2, 3])); // [1,2,3]
```

JSON은 데이터 교환을 목적으로 만들어진 언어에 종속되지 않는 포맷이다. 따라서 자바스크립트 특유의 객체 프로퍼티는 `JSON.stringify`가 처리할 수 없다.

`JSON.stringify` 호출 시 무시되는 프로퍼티는 다음과 같다.
-   함수 프로퍼티 (메서드)
-   심볼형 프로퍼티 (키가 심볼인 프로퍼티)
-   값이  `undefined`인 프로퍼티

```js
let user = {
  sayHi() { // 무시된다.
    alert('Hello');
  },
  [Symbol('id')]: 123, // 무시된다.
  something: undefined // 무시된다.
};

alert(JSON.stringify(user)); // {}, 빈 객체가 출력된다.
```
`JSON.stringify`는 중첩 객체도 자동으로 문자열로 바꿔준다.
```js
let meetup = {
  title: 'Conference',
  room: {
    number: 23,
    participants: ['john', 'ann']
  }
};

alert(JSON.stringify(meetup));
/* 객체 전체가 문자열로 변환되었다.
{
  "title":"Conference",
  "room":{"number":23,"participants":["john","ann"]},
}
*/
```
`JSON.stringify`를 사용할 때 객체에 순환 참조가 있으면 에러가 발생한다.
```js
let room = {
  number: 23
};

let meetup = {
  title: 'Conference',
  participants: ['john', 'ann']
};

meetup.place = room;       // meetup은 room을 참조한다.
room.occupiedBy = meetup; // room은 meetup을 참조한다.

JSON.stringify(meetup); // Error: Converting circular structure to JSON
```

## replacer로 원하는 프로퍼티만 직렬화하기
`JSON.stringify`의 전체 문법은 다음과 같다.
```js
let json = JSON.stringify(value, [replacer], [space])
```
**value**  
인코딩 하려는 값

**replacer**  
JSON으로 인코딩 하길 원하는 프로퍼티가 담긴 배열 또는 매핑 함수  `function(key, value)`

**space**  
서식 변경 목적으로 사용할 공백 문자의 수

대다수의 경우에는 `JSON.stringify`에 인수를 하나만 넣어서 사용한다. 그런데 순환 참조를 다뤄야 하는 상황처럼 전환 프로세스를 정교하게 조정할 필요가 있다면, 두 번째 인수를 사용해야 한다.

JSON으로 변환하길 원하는 프로퍼티가 담긴 배열을 두 번째 인수로 넘겨주면 이 프로퍼티들만 인코딩할 수 있다. 아래 예시에서는 순환 참조를 발생시키는 프로퍼티 `room.occupiedBy`만 제외하고 모든 프로퍼티를 배열에 넣었다.
```js
let room = {
  number: 23
};

let meetup = {
  title: 'Conference',
  participants: [{name: 'John'}, {name: 'Alice'}],
  place: room // meetup은 room을 참조한다.
};

room.occupiedBy = meetup; // room은 meetup을 참조한다.

alert(JSON.stringify(meetup, ['title', 'participants', 'place', 'name', 'number']));
/*
{
  "title":"Conference",
  "participants":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/
```
이번에는 `replacer` 자리에 함수를 넣어보겠다. `replacer`에 전달되는 함수는 프로퍼티 `(키, 값)` 쌍 전체를 대상으로 호출되는데, 반드시 기존 프로퍼티 값을 대신하여 사용할 값을 반환해야 한다. 특정 프로퍼티를 직렬화에서 제외하려면 반환 값을 `undefined`로 만들면 된다.
```js
let room = {
  number: 23
};

let meetup = {
  title: 'Conference',
  participants: [{name: 'John'}, {name: 'Alice'}],
  place: room // meetup은 room을 참조한다.
};

room.occupiedBy = meetup; // room은 meetup을 참조한다.

alert(JSON.stringify(meetup, function replacer(key, value) {
  alert(`${key}: ${value}`);
  return (key == 'occupiedBy') ? undefined : value;
}));

/* replacer 함수에서 처리하는 키:값 쌍 목록
:             [object Object]
title:        Conference
participants: [object Object],[object Object]
0:            [object Object]
name:         John
1:            [object Object]
name:         Alice
place:        [object Object]
number:       23
*/
```
`replacer` 함수가 중첩 객체와 배열의 요소까지 포함한 모든 키-값 쌍을 처리한다. `replacer` 함수는 재귀적으로 키-값 쌍을 처리하는데, 함수 내에서 `this`는 현재 처리하고 있는 프로퍼티가 위치한 객체를 가리킨다.

첫 얼럿창에 문자열 `":[object Object]"`이 뜨는데, 이는 함수가 최초로 호출될 때 `{"": meetup}` 형태의 '래퍼 객체'가 만들어지기 때문이다. `replacer`함수가 가장 처음 처리하는 `(key, value)` 쌍의 키는 빈 문자열, 값은 변환하고자 하는 객체(meetup) 전체가 되는 것이다.

## space로 가독성 높이기
`JSON.stringify(value, replacer, space)`의 세 번째 인수 `space`는 가독성을 높이기 위해 중간에 삽입해 줄 공백 문자의 수를 나타낸다.
```js
let user = {
  name: 'John',
  age: 25,
  roles: {
    isAdmin: false,
    isEditor: true
  }
};

alert(JSON.stringify(user, null, 2));
/* 공백 문자 두 개를 사용하여 들여쓰기가 된다.
{
  "name": "John",
  "age": 25,
  "roles": {
    "isAdmin": false,
    "isEditor": true
  }
}
*/

/* JSON.stringify(user, null, 4)라면 아래와 같이 좀 더 들여쓰기가 된다.
{
    "name": "John",
    "age": 25,
    "roles": {
        "isAdmin": false,
        "isEditor": true
    }
}
*/
```

## 커스텀 "toJSON"
`toString`을 사용해 객체를 문자형으로 변환시키는 것처럼, 객체에 `toJSON`이라는 메서드가 구현되어 있으면 객체를 JSON으로 바꿀 수 있다. `JSON.stringify`는 이런 경우를 감지하고 `toJSON`을 자동으로 호출해준다.
```js
let room = {
  number: 23,
  toJSON() {
    return this.number;
  }
};

let meetup = {
  title: 'Conference',
  room
};

alert(JSON.stringify(room)); // 23

alert(JSON.stringify(meetup));
/*
  {
    "title":"Conference",
    "room": 23
  }
*/
```

## JSON.parse
[JSON.parse](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse)를 사용하면 JSON으로 인코딩된 객체를 다시 객체로 디코딩 할 수 있다.
```js
let value = JSON.parse(str, [reviver]);
```
**str**  
JSON 형식의 문자열

**reviver**  
모든  `(key, value)`  쌍을 대상으로 호출되는 function(key,value) 형태의 함수로 값을 변경할 수 있다.

```js
// 문자열로 변환된 배열
let numbers = '[0, 1, 2, 3]';

numbers = JSON.parse(numbers);

alert(numbers[1]); // 1
```
`JSON.parse`는 중첩 객체에도 사용할 수 있다.
```js
let userData = '{ "name": "John", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }';

let user = JSON.parse(userData);

alert(user.friends[1]); // 1
```
디버깅을 목적으로 직접 JSON을 만들 때 흔히 하는 실수는 다음과 같다.
```js
let json = `{
  name: "John",                     // 실수 1: 프로퍼티 이름을 큰따옴표로 감싸지 않았다.
  "surname": 'Smith',               // 실수 2: 프로퍼티 값은 큰따옴표로 감싸야 하는데, 작은따옴표로 감쌌다.
  'isAdmin': false                  // 실수 3: 프로퍼티 키는 큰따옴표로 감싸야 하는데, 작은따옴표로 감쌌다.
  "birthday": new Date(2000, 2, 3), // 실수 4: "new"를 사용할 수 없다. 순수한 값(bare value)만 사용할 수 있다.
  "friends": [0,1,2,3]              // 이 프로퍼티는 괜찮다.
}`;
```
JSON은 주석을 지원하지 않는다. 주석을 추가하면 유효하지 않은 형식이 된다.

키를 큰따옴표로 감싸지 않아도 되고 주석도 지원해주는 JSON5라는 포맷도 있는데, 이 포맷은 자바스크립트 명세서에서 정의하지 않은 독자적인 라이브러리이다.

## reviver 사용하기
서버로부터 받은 JSON 문자열을 역 직렬화(deserialize)한 객체의 프로퍼티에 Date 내장 메소드를 사용하면 에러가 발생한다.
```js
let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str);

alert(meetup.date.getDate()); // 에러가 발생한다.
```
`meetup.date`의 값은 `Date` 객체가 아니고 문자열이기 때문에 발생한 에러이다.

이 문제를 해결하기 위해서는 `JSON.parse`의 두 번째 인수 `reviver`를 사용하면 된다. 나머지 값은 그대로 두고 `date`만 `Date` 객체를 반환하도록 함수를 구현한다.
```js
let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert(meetup.date.getDate()); // 이제 문제없이 동작한다.
```
중첩 객체에도 똑같이 적용할 수 있다.
```js
let schedule = `{
  "meetups": [
    {"title":"Conference","date":"2017-11-30T12:00:00.000Z"},
    {"title":"Birthday","date":"2017-04-18T12:00:00.000Z"}
  ]
}`;

schedule = JSON.parse(schedule, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( schedule.meetups[1].date.getDate() ); // 잘 동작한다.
```
<br></br>
