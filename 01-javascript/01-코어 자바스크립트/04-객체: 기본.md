# [04] 객체: 기본
## 01. 객체
 - **원시형(primitive type)**: 오직 하나의 데이터(문자열, 숫자 등)만 담을 수 있는 자료형으로 객체형을 제외한 모든 자료형이 이에 해당한다.
- **객체형**: 다양한 데이터를 담을 수 있는 자료형으로 키로 구분된 데이터 집합이나 복잡한 개체(entity)를 저장할 수 있다. 
- 객체는 중괄호 `{...}`를 이용해 만들 수 있다.
- 객체를 선언하는 방법은 다음과 같이 두 가지가 있는데 주로 **객체 리터럴(object literal)** 방법을 사용한다.
```js
let user =  new  Object();  // '객체 생성자' 문법
let user =  {};  // '객체 리터럴' 문법
```

### 리터럴과 프로퍼티
중괄호 `{...}` 안에는 ‘키: 값’ 쌍으로 구성된 프로퍼티가 들어간다.
```js
let user =  {    // 객체 
  name: 'John',  // 키: 'name', 값: 'John'
  age: 30        // 키: 'age', 값: 30
};
```
- `'콜론(:)'`을 기준으로 왼쪽에는 키가, 오른쪽에는 값이 위치한다. 프로퍼티 키는 프로퍼티 ‘**이름**’ 혹은 '식별자’라고도 부른다.
- 점 표기법(dot notation)을 이용하면 프로퍼티 값을 읽을 수 있다.
```js
// 프로퍼티 값 얻기
alert(user.name); // John
alert(user.age); // 30
```
- 프로퍼티 값에는 모든 자료형이 올 수 있으며 새로운 프로퍼티를 추가 방법은 다음과 같다.
```js
user.isAdmin =  true;
```
- `delete` 연산자를 사용하면 프로퍼티를 삭제할 수 있다.
```js
delete user.age;
```
- 여러 단어를 조합해서 프로퍼티 이름을 만드는 경우에는 프로퍼티 이름을 따옴표로 묶어줘야 한다.
```js
let user = {
  name: 'John',
  age: 30,
  'likes birds': true  // 복수의 단어는 따옴표로 묶어야 한다.
};
```
- 마지막 프로퍼티의 끝은 쉼표로 끝날 수 있으며 이것을 ‘trailing(길게 늘어지는)’ 혹은 ‘hanging(매달리는)’ 쉼표라고 부른다. 이렇게 끝에 쉼표를 붙이면 모든 프로퍼티가 유사한 형태를 보이기 때문에 프로퍼티를 추가, 삭제, 이동하는 것이 쉬워진다.
- 상수 객체는 수정될 수 있다.
```js
const user = {
  name: 'John'
};

user.name = 'Pete'; // 오류가 발생하지 않는다.

alert(user.name); // Pete
```
`const`는  `user=...`를 전체적으로 설정하려고 할 때만 오류가 발생한다.

상수 객체 프로퍼티를 만드는 또 다른 방법이 있는데,  [프로퍼티 플래그와 설명자]()  챕터에서 확인할 수 있다.

### 대괄호 표기법
여러 단어를 조합해 프로퍼티 키를 만든 경우에는 점 표기법 대신 '대괄호 표기법(square bracket notation)'을 사용해야 한다.
```js
let user = {};

// set
user['likes birds'] = true;

// get
alert(user['likes birds']); // true

// delete
delete user['likes birds'];
```
대괄호 표기법 안에서 문자열을 사용할 때는 문자열을 따옴표로 묶어줘야 한다는 점에 주의해야 한다.

대괄호 표기법을 사용하면 아래 예시에서 변수를 키로 사용한 것과 같이 문자열뿐만 아니라 모든 표현식의 평가 결과를 프로퍼티 키로 사용할 수 있다. 점 표기법은 이런 방식이 불가능하다.
```js
let key = 'likes birds';

user[key] = true; // user['likes birds'] = true;
```

### 계산된 프로퍼티
객체를 만들 때 객체 리터럴 안의 프로퍼티 키가 대괄호로 둘러싸여 있는 경우, 이를 계산된 프로퍼티(computed property)라고 부른다.
```js
let fruit = prompt('어떤 과일을 구매하시겠습니까?', 'apple');

let bag = {
  [fruit]: 5, // 변수 fruit에서 프로퍼티 이름을 동적으로 받아온다.
};

alert(bag.apple); // fruit에 'apple'이 할당되었다면, 5가 출력된다.
```
- 다음과 같이 대괄호 안에 복잡한 표현식을 넣는 것도 가능하다.
```js
let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};
```
- 대괄호 표기법은 프로퍼티 이름과 값의 제약을 없애주기 때문에 점 표기법보다 훨씬 강력하다. 그런데 작성하기 번거롭다는 단점이 있다. 이런 이유로 프로퍼티 이름이 확정된 상황이고 단순한 이름이라면 **점 표기법**을 사용하다가, 뭔가 복잡한 상황이 발생했을 때 **대괄호 표기법**으로 바꾸는 경우가 많다.

### 단축 프로퍼티
변수를 이용해 프로퍼티의 이름과 값을 만드는 경우, 프로퍼티 값 단축 구문(property value shorthand)을 사용하면 코드를 짧게 만들 수 있다.
```js
function makeUser(name, age) {
  return {
    name, // name: name
    age,  // age: age
    // ...
  };
}
```

### 프로퍼티 이름의 제약사항
프로퍼티 이름에는 특별한 제약이 없다. 예약어를 비롯한 어떤 문자형, 심볼형 값도 프로퍼티 키가 될 수 있다. 문자형이나 심볼형에 속하지 않은 값은 문자열로 자동 형 변환된다.
```js
let obj = {
  0: 'test' // '0': 'test'
};

// 숫자 0은 문자열 '0'으로 변환되기 때문에 두 얼럿 창은 같은 프로퍼티에 접근한다.
alert(obj['0']); // test
alert(obj[0]); // test (동일한 프로퍼티)
```
이와 같이 객체 프로퍼티 키에 쓸 수 있는 문자열엔 제약이 없지만, 역사적인 이유 때문에 특별대우를 받는 이름이 하나 있다. 바로 `__proto__`이다.
```js
let obj = {};
obj.__proto__ = 5; // 숫자를 할당한다.
alert(obj.__proto__); // [object Object] - 숫자를 할당했지만 값은 객체가 되었다.
```
`__proto__`의 본질은 [프로토타입 상속]()에서, 이 문제를 어떻게 해결할 수 있을지에 대해선 [프로토타입 메서드와 __proto__가 없는 객체]()에서 확인할 수 있다.

### ‘in’ 연산자로 프로퍼티 존재 여부 확인하기`
연산자 `in`을 사용하면 프로퍼티 존재 여부를 확인할 수 있다.
```js
'key' in object
```
`in` 왼쪽에는 반드시 프로퍼티 이름이 와야 한다. 프로퍼티 이름은 보통 따옴표로 감싼 문자열이다.

값에 `undefined`을 할당한 경우에는 `undefined`을 이용해서 프로퍼티 존재 여부를 제대로 판별할 수 없다. 따라서 **프로퍼티 존재 여부를 확인할 때는 `in`을 사용**하는 것을 추천한다.
```js
let obj = {
  test: undefined
};

alert(obj.test); // 값이 `undefined`이므로, 얼럿 창에는 undefined가 출력됩니다. 그런데 프로퍼티 test는 존재한다.

alert('test' in obj ); // `in`을 사용하면 프로퍼티 유무를 제대로 확인할 수 있다(true가 출력됨).
```
- 객체에 프로퍼티가 하나 이상 존재하는지 확인하는 함수는 다음과 같이 만들 수 있다.
```js
function isEmpty(obj) {
  for (let key in obj) {
    // 루프가 시작하면 프로퍼티가 있는 것이다.
    return false;
  }
  return true;
}
```

### 'for...in' 반복문
`for..in` 반복문을 사용하면 객체의 모든 키를 순회할 수 있다.
```js
for (key in object) {
  // 각 프로퍼티 키(key)를 이용하여 본문(body)을 실행한다.
}
```
```js
let user = {
  name: 'John',
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // 키
  alert(key);  // name, age, isAdmin
  // 키에 해당하는 값
  alert(user[key]); // John, 30, true
}
```
반복 변수(looping variable)를 선언(`let key`)했다는 점을 주목할 필요가 있다. 반복 변수명은 자유롭게 정할 수 있다.

### 객체 정렬 방식
정수 프로퍼티(integer property)는 자동으로 정렬되고, 그 외의 프로퍼티는 객체에 추가한 순서 그대로 정렬된다.
```js
let codes = {
  '49': '독일',
  '41': '스위스',
  '44': '영국',
  // ..,
  '1': '미국'
};

for (let code in codes) {
  alert(code); // 1, 41, 44, 49
}
```
- 정수 프로퍼티: 정수로 이루어진 문자열이다. 정수로 변환하거나 변환한 정수를 다시 문자열로 바꿔도 원본과 동일해야 한다.
```js
alert(String(Math.trunc(Number('49')))); // '49'가 출력된다. 기존에 입력한 값과 같으므로 정수 프로퍼티이다.
alert(String(Math.trunc(Number('+49')))); // '49'가 출력된다. 기존에 입력한 값(+49)과 다르므로 정수 프로퍼티가 아니다.
alert(String(Math.trunc(Number('1.2')))); // '1'이 출력된다. 기존에 입력한 값(1.2)과 다르므로 정수 프로퍼티가 아니다.
```
이름에 정수를 사용하면서 자동 정렬이 되지 않게 하려면 다음과 같은 속임수를 써야 한다.
```js
let codes = {
  '+49': '독일',
  '+41': '스위스',
  '+44': '영국',
  // ..,
  '+1': '미국'
};

for (let code in codes) {
  alert(+code); // 49, 41, 44, 1
}
```
<br></br>
## 02. 참조에 의한 객체 복사
원시값은 '값 그대로' 저장, 할당, 복사된다.
```js
let message = 'Hello!';
let phrase = message; // 'Hello!'가 그대로 복사된다.
```
객체는 '메모리 주소', 즉 '**참조 값**'이 복사된다.
```js
let user = {name: 'John'};
let admin = user; // 참조값을 복사한다.
```
변수는 두 개이지만 각 변수엔 동일 객체에 대한 참조 값이 저장되는 것이다.

따라서 객체에 접근하거나 객체를 조작할 때에 여러 변수를 사용할 수 있다.
```js
let user = {name: 'John'};
let admin = user;

admin.name = 'Pete'; // 'admin' 참조 값에 의해 변경된다.
alert(user.name); // 'Pete'가 출력된다. 'user' 참조 값을 이용해 변경사항을 확인한다.
```

### 참조에 의한 비교
객체 비교 시 동등 연산자 `==`와 일치 연산자 `===`는 동일하게 동작한다. 비교 시 피연산자인 두 객체가 동일한 객체인 경우에 참을 반환한다.
```js
let a = {};
let b = a;

alert(a == b); // true
alert(a === b); // true
```
```js
let a = {};
let b = {};

alert(a == b); // 독립된 두 객체이므로 false를 출력한다.
```

### 객체 복사, 병합과 Object.assign
객체의 참조 값을 복사하는 것이 아닌 객체 자체를 복사하려면 Object.assign을 사용할 수 있다. `assign` 메서드는 '**얕은 복사(shallow copy)**'를 가능하게 해준다.
```js
Object.assign(dest, [src1, src2, src3...])
```
- `dest`는 값을 넣을 객체이다.
- 이어지는 인수  `src1, ..., srcN`는 복사하고자 하는 객체이다.  `...`은 필요에 따라 얼마든지 많은 객체를 인수로 사용할 수 있다는 것을 나타낸다.
- 메서드는 객체 `src1, ..., srcN`의 프로퍼티를 `dest`에 복사하고 `dest`를 반환한다.
- `dest`에 동일한 이름을 가진 프로퍼티가 있을 경우에는 기존 값이 덮어씌워진다.

`assign` 메서드를 사용하면 여러 객체를 하나로 병합할 수 있다.
```js
let user = {name: 'John'};

let permissions1 = {canView: true};
let permissions2 = {canEdit: true};

// permissions1과 permissions2의 프로퍼티를 user로 복사한다.
Object.assign(user, permissions1, permissions2);

// now user = {name: 'John', canView: true, canEdit: true}
```
`assign` 메서드를 사용하면 간단하게 객체를 복사할 수 있다.
```js
let user = {
  name: 'John',
  age: 30
};

// user에 있는 모든 프로퍼티가 빈 배열에 복사되고, 해당 객체가 clone에 할당된다.
let clone = Object.assign({}, user);
```

### 중첩 객체 복사
객체의 프로퍼티가 원시값이 아닌 객체인 경우에는 복사가 어려워진다. 객체의 각 값을 검사하면서, 그 값이 객체인 경우 객체의 구조도 복사해주는 반복문을 사용해야 한다. 이런 방식을 '**깊은 복사(deep cloning)**'라고 한다.

자바스크립트 라이브러리 [lodash](https://lodash.com/)의 메서드인 [\_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep)을 사용하면 깊은 복사를 처리할 수 있다.
<br></br>
## 03. 가비지 컬렉션
### 가비지 컬렉션 기준
자바스크립트는 **도달 가능성(reachability)**이라는 개념을 사용해 메모리 관리를 수행한다.

**‘도달 가능한(reachable)’** 값은 어떻게든 접근하거나 사용할 수 있는 값을 의미한다. 도달 가능한 값은 메모리에서 삭제되지 않는다.

1. 루트(root)는 태생부터 도달 가능하기 때문에, 명백한 이유 없이는 삭제되지 않는다.
    - 현재 함수의 지역 변수와 매개변수
    - 중첩 함수의 체인에 있는 함수에서 사용되는 변수와 매개변수
    - 전역 변수
    - 기타 등등
2. 루트가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값은 도달 가능한 값이 된다.

자바스크립트 엔진 내에선 가비지 컬렉터(garbage collector)가 끊임없이 동작한다. 가비지 컬렉터는 모든 객체를 모니터링하고 도달할 수 없는 객체는 삭제한다.

### 요약
-   가비지 컬렉션은 엔진이 자동으로 수행하므로 개발자는 이를 억지로 실행하거나 막을 수 없다.
-   객체는 도달 가능한 상태일 때 메모리에 남는다.
-   참조된다고 해서 도달 가능한 것은 아니다. 서로 연결된 객체들도 도달 불가능할 수 있다.

가비지 컬렉션에 대한 자세한 내용과 예제는 [원문](https://ko.javascript.info/garbage-collection)을 확인한다.
<br></br>
## 04. 메서드와 this
자바스크립트에서는 객체의 프로퍼티에 함수를 할당해 객체에게 행동할 수 있는 능력을 부여해준다.
### 메서드 만들기
객체 프로퍼티에 할당된 함수를 <strong>메서드(method)</strong>라고 부른다.
```js
let user = {
  name: 'John',
  age: 30
};

user.sayHi = function() {
  alert('안녕하세요!');
};

user.sayHi(); // '안녕하세요!'가 출력된다. user의 메서드를 호출했다.
```
이미 정의된 함수로 메서드를 만드는 것도 가능하다.
```js
let user = {
  // ...
};

// 함수 선언
function sayHi() {
  alert('안녕하세요!');
};

// 선언된 함수를 메서드로 등록한다.
user.sayHi = sayHi;

user.sayHi(); // 안녕하세요!
```
- 객체 지향 프로그래밍: 객체를 사용하여 개체를 표현하는 방식을 객체 지향 프로그래밍(object-oriented programming, OOP)이라 부른다.

### 메서드 단축 구문
객체 리터럴 안에서 메서드를 선언할 때 사용할 수 있는 단축 문법이다. `function`을 생략할 수 있다.
```js
user = {
  sayHi: function() {
    alert('Hello');
  }
};

user = {
  sayHi() { // "sayHi: function()"과 동일하다.
    alert('Hello');
  }
};
```
일반적인 방법과 단축 구문을 사용한 방법이 완전히 동일하진 않다. 객체 상속과 관련된 미묘한 차이가 존재하는데 지금으로서는 이 차이가 중요하지 않다.

### 메서드와 this
**메서드 내부에서  `this`  키워드를 사용하면 객체에 접근할 수 있다.** 정확히는 메서드를 호출할 때 사용된 객체에 접근한다.
```js
let user = {
  name: 'John',
  age: 30,

  sayHi() {
    // 'this'는 '현재 객체'를 나타낸다.
    alert(this.name);
  }
};

user.sayHi(); // John
```
`this`를 사용하지 않고 외부 변수 `user`를 참조해 객체에 접근하는 것도 가능하지만 문제가 발생할 수 있다.

### 자유로운 this
자바스크립트에서는 모든 함수에서 `this`를 사용할 수 있다.

`this` 값은 런타임에 결정된다. 동일한 함수라도 다른 객체에서 호출했다면 'this’가 참조하는 값이 달라진다.
```js
let user = {name: 'John'};
let admin = {name: 'Admin'};

function sayHi() {
  alert( this.name );
}

// 별개의 객체에서 동일한 함수를 사용한다.
user.f = sayHi;
admin.f = sayHi;

// 'this'는 '점(.) 앞의' 객체를 참조하기 때문에 this 값이 다르다.
user.f(); // John(this == user)
admin.f(); // Admin(this == admin)

admin['f'](); // Admin(점과 대괄호는 동일하게 동작한다.)
```
- 객체 없이 호출하기: `this == undefined`
```js
function sayHi() {
  alert(this);
}

sayHi(); // undefined
```
위와 같은 코드를 엄격 모드에서 실행하면, `this`에는 `undefined`가 할당된다. 엄격 모드가 아닐 때는 `this`가 전역 객체를 참조하는데, 브라우저 환경에서는 `window`라는 전역 객체를 참조한다. 이런 동작 차이는 `'use strict'`가 도입된 배경이기도 하다.

### this가 없는 화살표 함수
화살표 함수는 일반 함수와는 달리 ‘고유한’ `this`를 가지지 않는다. 화살표 함수에서 `this`를 참조하면, 화살표 함수가 아닌 ‘평범한’ 외부 함수에서 `this` 값을 가져온다.
```js
let user = {
  firstName: '보라',
  sayHi() {
    // 함수 `arrow()`의 `this`는 외부 함수 `user.sayHi()`의 `this`이다.
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // 보라
```
별개의 `this`가 만들어지는 것을 원하지 않고 외부 컨텍스트에 있는 `this`를 이용하고 싶은 경우에는 화살표 함수가 유용하다. 이에 대한 자세한 내용은 별도의 챕터, [화살표 함수 다시 살펴보기]()에서 확인할 수 있다.
<br></br>
