# [04] 객체: 기본
# 01. 객체
 - **원시형(primitive type)**: 오직 하나의 데이터(문자열, 숫자 등)만 담을 수 있는 자료형으로 객체형을 제외한 모든 자료형이 이에 해당한다.
- **객체형**: 다양한 데이터를 담을 수 있는 자료형으로 키로 구분된 데이터 집합이나 복잡한 개체(entity)를 저장할 수 있다. 
- 객체는 중괄호 `{...}`를 이용해 만들 수 있다.
- 객체를 선언하는 방법은 다음과 같이 두 가지가 있는데 **객체 리터럴(object literal)** 방법을 주로 사용한다.
```js
let user =  new  Object();  // '객체 생성자' 문법
let user =  {};  // '객체 리터럴' 문법
```

## 리터럴과 프로퍼티
중괄호 `{...}` 안에는 ‘키: 값’ 쌍으로 구성된 프로퍼티가 들어간다.
```js
let user =  {    // 객체 
  name: 'John',  // 키: 'name', 값: 'John'
  age: 30        // 키: 'age', 값: 30
};
```
- `'콜론(:)'`을 기준으로 왼쪽에는 키가, 오른쪽에는 값이 위치한다. 프로퍼티 키는 프로퍼티 ‘**이름**’ 혹은 '식별자’라고도 부른다.
- 점 표기법(dot notation)을 이용하면 프로퍼티 값을 읽을 수 있다.
```js
// 프로퍼티 값 얻기
alert(user.name); // John
alert(user.age); // 30
```
- 프로퍼티 값에는 모든 자료형이 올 수 있으며 새로운 프로퍼티를 추가하는 방법은 다음과 같다.
```js
user.isAdmin =  true;
```
- `delete` 연산자를 사용하면 프로퍼티를 삭제할 수 있다.
```js
delete user.age;
```
- 여러 단어를 조합해서 프로퍼티 이름을 만드는 경우에는 프로퍼티 이름을 따옴표로 묶어줘야 한다.
```js
let user = {
  name: 'John',
  age: 30,
  'likes birds': true  // 복수의 단어는 따옴표로 묶어야 한다.
};
```
- 마지막 프로퍼티의 끝은 쉼표로 끝날 수 있으며 이것을 ‘trailing(길게 늘어지는)’ 혹은 ‘hanging(매달리는)’ 쉼표라고 부른다. 이렇게 끝에 쉼표를 붙이면 모든 프로퍼티가 유사한 형태를 보이기 때문에 프로퍼티를 추가, 삭제, 이동하는 것이 쉬워진다.

---
:information_source: **상수 객체는 수정될 수 있다.**

```js
const user = {
  name: 'John'
};

user.name = 'Pete'; // 오류가 발생하지 않는다.

alert(user.name); // Pete
```
`const`는  `user=...`와 같이 `user` 자체를 변경하려고 할 때만 오류가 발생한다.

상수 객체 프로퍼티를 만드는 또 다른 방법이 있는데,  [프로퍼티 플래그와 설명자]()  챕터에서 확인할 수 있다.

---

## 대괄호 표기법
여러 단어를 조합해 프로퍼티 키를 만든 경우에는 점 표기법 대신 '대괄호 표기법(square bracket notation)'을 사용해야 한다.
```js
let user = {};

// set
user['likes birds'] = true;

// get
alert(user['likes birds']); // true

// delete
delete user['likes birds'];
```
대괄호 표기법 안에서 문자열을 사용할 때는 문자열을 **따옴표**로 묶어줘야 한다는 점에 주의해야 한다.

대괄호 표기법을 사용하면 아래 예시에서 변수를 키로 사용한 것과 같이 문자열뿐만 아니라 모든 표현식의 평가 결과를 프로퍼티 키로 사용할 수 있다. 점 표기법은 이런 방식이 불가능하다.
```js
let key = 'likes birds';

user[key] = true; // user['likes birds'] = true;
```

### 계산된 프로퍼티
객체를 만들 때 객체 리터럴 안의 프로퍼티 키가 대괄호로 둘러싸여 있는 경우, 이를 계산된 프로퍼티(computed property)라고 부른다.
```js
let fruit = prompt('어떤 과일을 구매하시겠습니까?', 'apple');

let bag = {
  [fruit]: 5, // 변수 fruit에서 프로퍼티 이름을 동적으로 받아온다.
};

alert(bag.apple); // fruit에 'apple'이 할당되었다면, 5가 출력된다.
```
- 다음과 같이 대괄호 안에 복잡한 표현식을 넣는 것도 가능하다.
```js
let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};
```
- 대괄호 표기법은 프로퍼티 이름과 값의 제약을 없애주기 때문에 점 표기법보다 훨씬 강력하다. 그런데 작성하기 번거롭다는 단점이 있다. 이런 이유로 프로퍼티 이름이 확정된 상황이고 단순한 이름이라면 **점 표기법**을 사용하다가, 뭔가 복잡한 상황이 발생했을 때 **대괄호 표기법**으로 바꾸는 경우가 많다.

## 단축 프로퍼티
변수를 이용해 이름과 값이 동일한 프로퍼티를 만드는 경우, 프로퍼티 값 단축 구문(property value shorthand)을 사용할 수 있다.
```js
function makeUser(name, age) {
  return {
    name, // name: name
    age,  // age: age
    // ...
  };
}
```

## 프로퍼티 이름의 제약사항
프로퍼티 이름에는 특별한 제약이 없다. 예약어를 비롯한 어떤 문자형, 심볼형 값도 프로퍼티 키가 될 수 있다. 문자형이나 심볼형에 속하지 않은 값은 문자열로 자동 형 변환된다.
```js
let obj = {
  0: 'test' // '0': 'test'
};

// 숫자 0은 문자열 '0'으로 변환되기 때문에 두 얼럿 창은 같은 프로퍼티에 접근한다.
alert(obj['0']); // test
alert(obj[0]); // test (동일한 프로퍼티)
```
이와 같이 객체 프로퍼티 키에 쓸 수 있는 문자열에는 제약이 없지만, 역사적인 이유 때문에 특별대우를 받는 이름이 하나 있다. 바로 `__proto__`이다.
```js
let obj = {};
obj.__proto__ = 5; // 숫자를 할당한다.
alert(obj.__proto__); // [object Object] - 숫자를 할당했지만 값은 객체가 되었다.
```
`__proto__`의 본질은 [프로토타입 상속]()에서, 이 문제를 어떻게 해결할 수 있을지에 대해선 [프로토타입 메서드와 __proto__가 없는 객체]()에서 확인할 수 있다.

## ‘in’ 연산자로 프로퍼티 존재 여부 확인하기
연산자 `in`을 사용하면 프로퍼티 존재 여부를 확인할 수 있다.
```js
'key' in object
```
`in` 왼쪽에는 반드시 프로퍼티 이름이 와야 한다. 프로퍼티 이름은 보통 따옴표로 감싼 문자열이다.

값에 `undefined`을 할당한 경우에는 `undefined`을 이용해서는 프로퍼티 존재 여부를 제대로 판별할 수 없다. 따라서 **프로퍼티 존재 여부를 확인할 때는 `in`을 사용**하는 것을 추천한다.
```js
let obj = {
  test: undefined
};

alert(obj.test); // 값이 `undefined`이므로, 얼럿 창에는 undefined가 출력됩니다. 그런데 프로퍼티 test는 존재한다.

alert('test' in obj ); // `in`을 사용하면 프로퍼티 유무를 제대로 확인할 수 있다(true가 출력됨).
```

## 'for...in' 반복문
`for..in` 반복문을 사용하면 객체의 모든 키를 순회할 수 있다.
```js
for (key in object) {
  // 각 프로퍼티 키(key)를 이용하여 본문(body)을 실행한다.
}
```
```js
let user = {
  name: 'John',
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // 키
  alert(key);  // name, age, isAdmin
  // 키에 해당하는 값
  alert(user[key]); // John, 30, true
}
```
반복 변수(looping variable)를 선언(`let key`)했다는 점을 주목할 필요가 있다. 반복 변수명은 자유롭게 정할 수 있다.

- 객체에 프로퍼티가 하나 이상 존재하는지 확인하는 함수는 다음과 같다.
```js
function isEmpty(obj) {
  for (let key in obj) {
    // 루프가 시작하면 프로퍼티가 있는 것이다.
    return false;
  }
  return true;
}
```

### 객체 정렬 방식
정수 프로퍼티(integer property)는 자동으로 정렬되고, 그 외의 프로퍼티는 객체에 추가한 순서 그대로 정렬된다.
```js
let codes = {
  '49': '독일',
  '41': '스위스',
  '44': '영국',
  // ..,
  '1': '미국'
};

for (let code in codes) {
  alert(code); // 1, 41, 44, 49
}
```

---
:information_source: **정수 프로퍼티**

'정수 프로퍼티'는 정수로 이루어진 문자열이다. 정수로 변환하거나 변환한 정수를 다시 문자열로 바꿔도 원본과 동일해야 한다.
```js
alert(String(Math.trunc(Number('49')))); // '49'가 출력된다. 기존에 입력한 값과 같으므로 정수 프로퍼티이다.
alert(String(Math.trunc(Number('+49')))); // '49'가 출력된다. 기존에 입력한 값(+49)과 다르므로 정수 프로퍼티가 아니다.
alert(String(Math.trunc(Number('1.2')))); // '1'이 출력된다. 기존에 입력한 값(1.2)과 다르므로 정수 프로퍼티가 아니다.
```
---

이름에 정수를 사용하면서 자동 정렬이 되지 않게 하려면 다음과 같은 속임수를 써야 한다.
```js
let codes = {
  '+49': '독일',
  '+41': '스위스',
  '+44': '영국',
  // ..,
  '+1': '미국'
};

for (let code in codes) {
  alert(+code); // 49, 41, 44, 1
}
```
<br></br>
# 02. 참조에 의한 객체 복사
원시값은 '값 그대로' 저장, 할당, 복사된다.
```js
let message = 'Hello!';
let phrase = message; // 'Hello!'가 그대로 복사된다.
```
객체는 '메모리 주소', 즉 '**참조 값**'이 복사된다.
```js
let user = {name: 'John'};
let admin = user; // 참조값을 복사한다.
```
변수는 두 개이지만 각 변수엔 동일 객체에 대한 참조 값이 저장되는 것이다.

따라서 객체에 접근하거나 객체를 조작할 때에 여러 변수를 사용할 수 있다.
```js
let user = {name: 'John'};
let admin = user;

admin.name = 'Pete'; // 'admin' 참조 값에 의해 변경된다.
alert(user.name); // 'Pete'가 출력된다. 'user' 참조 값을 이용해 변경사항을 확인한다.
```

### 참조에 의한 비교
객체 비교 시 동등 연산자 `==`와 일치 연산자 `===`는 동일하게 동작한다. 비교 시 피연산자인 두 객체가 동일한 객체인 경우에 참을 반환한다.
```js
let a = {};
let b = a;

alert(a == b); // true
alert(a === b); // true
```
```js
let a = {};
let b = {};

alert(a == b); // 독립된 두 객체이므로 false를 출력한다.
```

## 객체 복사, 병합과 Object.assign
객체의 참조 값을 복사하는 것이 아닌 객체 자체를 복사하려면 `Object.assign`을 사용할 수 있다. `assign` 메서드는 '**얕은 복사(shallow copy)**'를 한다.
```js
Object.assign(dest, [src1, src2, src3...])
```
- `dest`는 값을 넣을 객체이다.
- 이어지는 인수  `src1, ..., srcN`는 복사하고자 하는 객체이다.  `...`은 필요에 따라 얼마든지 많은 객체를 인수로 사용할 수 있다는 것을 나타낸다.
- 메서드는 객체 `src1, ..., srcN`의 프로퍼티를 `dest`에 복사하고 `dest`를 반환한다.
- `dest`에 동일한 이름을 가진 프로퍼티가 있을 경우에는 기존 값이 덮어씌워진다.

`assign` 메서드를 사용하면 여러 객체를 하나로 병합할 수 있다.
```js
let user = {name: 'John'};

let permissions1 = {canView: true};
let permissions2 = {canEdit: true};

// permissions1과 permissions2의 프로퍼티를 user로 복사한다.
Object.assign(user, permissions1, permissions2);

// now user = {name: 'John', canView: true, canEdit: true}
```
`assign` 메서드를 사용하면 간단하게 객체를 복사할 수 있다.
```js
let user = {
  name: 'John',
  age: 30
};

// user에 있는 모든 프로퍼티가 빈 배열에 복사되고, 해당 객체가 clone에 할당된다.
let clone = Object.assign({}, user);
```

## 중첩 객체 복사
객체의 프로퍼티가 원시값이 아닌 객체인 경우에는 복사가 어려워진다. 객체의 각 값을 검사하면서, 그 값이 객체인 경우 객체의 구조도 복사해주는 반복문을 사용해야 한다. 이런 방식을 '**깊은 복사(deep cloning)**'라고 한다.

자바스크립트 라이브러리 [lodash](https://lodash.com/)의 메서드인 [\_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep)을 사용하면 깊은 복사를 처리할 수 있다.
<br></br>
# 03. 가비지 컬렉션
## 가비지 컬렉션 기준
자바스크립트는 <strong>도달 가능성(reachability)</strong>이라는 개념을 사용해 메모리 관리를 수행한다.

<strong>‘도달 가능한(reachable)’</strong> 값은 어떻게든 접근하거나 사용할 수 있는 값을 의미한다. 도달 가능한 값은 메모리에서 삭제되지 않는다.

1. 루트(root)는 태생부터 도달 가능하기 때문에, 명백한 이유 없이는 삭제되지 않는다.
    - 현재 함수의 지역 변수와 매개변수
    - 중첩 함수의 체인에 있는 함수에서 사용되는 변수와 매개변수
    - 전역 변수
    - 기타 등등
2. 루트가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값은 도달 가능한 값이 된다.

자바스크립트 엔진 내에선 <strong>가비지 컬렉터(garbage collector)</strong>가 끊임없이 동작한다. 가비지 컬렉터는 모든 객체를 모니터링하고 도달할 수 없는 객체는 삭제한다.

## 요약
-   가비지 컬렉션은 엔진이 자동으로 수행하므로 개발자는 이를 억지로 실행하거나 막을 수 없다.
-   객체는 도달 가능한 상태일 때 메모리에 남는다.
-   참조된다고 해서 도달 가능한 것은 아니다. 서로 연결된 객체들도 도달 불가능할 수 있다.

가비지 컬렉션에 대한 자세한 내용과 예제는 [원문](https://ko.javascript.info/garbage-collection)을 확인한다.
<br></br>
# 04. 메서드와 this
자바스크립트에서는 객체의 프로퍼티에 함수를 할당해 객체에게 행동할 수 있는 능력을 부여해준다.
## 메서드 만들기
객체 프로퍼티에 할당된 함수를 <strong>메서드(method)</strong>라고 부른다.
```js
let user = {
  name: 'John',
  age: 30
};

user.sayHi = function() {
  alert('안녕하세요!');
};

user.sayHi(); // '안녕하세요!'가 출력된다. user의 메서드를 호출했다.
```
이미 정의된 함수로 메서드를 만드는 것도 가능하다.
```js
let user = {
  // ...
};

// 함수 선언
function sayHi() {
  alert('안녕하세요!');
};

// 선언된 함수를 메서드로 등록한다.
user.sayHi = sayHi;

user.sayHi(); // 안녕하세요!
```

---
:information_source: **객체 지향 프로그래밍**

객체를 사용하여 개체를 표현하는 방식을 객체 지향 프로그래밍(object-oriented programming, OOP)이라 부른다.

---

### 메서드 단축 구문
객체 리터럴 안에서 메서드를 선언할 때 사용할 수 있는 단축 문법이다. `: function`을 생략할 수 있다.
```js
user = {
  sayHi: function() {
    alert('Hello');
  }
};

user = {
  sayHi() { // "sayHi: function()"과 동일하다.
    alert('Hello');
  }
};
```
일반적인 방법과 단축 구문을 사용한 방법이 완전히 동일하진 않다. 객체 상속과 관련된 미묘한 차이가 존재하는데 지금으로서는 이 차이가 중요하지 않다.

## 메서드와 this
**메서드 내부에서  `this`  키워드를 사용하면 객체에 접근할 수 있다.** 정확히는 메서드를 호출할 때 사용된 객체에 접근한다.
```js
let user = {
  name: 'John',
  age: 30,

  sayHi() {
    // 'this'는 '현재 객체'를 나타낸다.
    alert(this.name);
  }
};

user.sayHi(); // John
```
`this`를 사용하지 않고 외부 변수 `user`를 참조해 객체에 접근하는 것도 가능하지만 문제가 발생할 수 있다.

## 자유로운 this
자바스크립트에서는 모든 함수에서 `this`를 사용할 수 있다.

`this` 값은 런타임에 결정된다. 동일한 함수라도 다른 객체에서 호출했다면 'this’가 참조하는 값이 달라진다.
```js
let user = {name: 'John'};
let admin = {name: 'Admin'};

function sayHi() {
  alert(this.name);
}

// 별개의 객체에서 동일한 함수를 사용한다.
user.f = sayHi;
admin.f = sayHi;

// 'this'는 '점(.) 앞의' 객체를 참조하기 때문에 this 값이 다르다.
user.f(); // John(this == user)
admin.f(); // Admin(this == admin)

admin['f'](); // Admin(점과 대괄호는 동일하게 동작한다.)
```

---
:information_source: **객체 없이 호출하기:** `this == undefined`
```js
function sayHi() {
  alert(this);
}

sayHi(); // undefined
```
위와 같은 코드를 엄격 모드에서 실행하면, `this`에는 `undefined`가 할당된다. 엄격 모드가 아닐 때는 `this`가 전역 객체를 참조하는데, 브라우저 환경에서는 `window`라는 전역 객체를 참조한다. 이런 동작 차이는 `'use strict'`가 도입된 배경이기도 하다.

---

## this가 없는 화살표 함수
화살표 함수는 일반 함수와는 달리 ‘고유한’ `this`를 가지지 않는다. 화살표 함수에서 `this`를 참조하면, 화살표 함수가 아닌 ‘평범한’ 외부 함수에서 `this` 값을 가져온다.
```js
let user = {
  firstName: '보라',
  sayHi() {
    // 함수 `arrow()`의 `this`는 외부 함수 `user.sayHi()`의 `this`이다.
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // 보라
```
별개의 `this`가 만들어지는 것을 원하지 않고 외부 컨텍스트에 있는 `this`를 이용하고 싶은 경우에는 화살표 함수가 유용하다. 이에 대한 자세한 내용은 별도의 챕터, [화살표 함수 다시 살펴보기]()에서 확인할 수 있다.
<br></br>
# 05. new 연산자와 생성자 함수
`'new'` 연산자와 생성자 함수를 사용하면 **유사한 객체 여러 개**를 쉽게 만들 수 있다.
## 생성자 함수
생성자 함수(constructor function)와 일반 함수에 기술적인 차이는 없다. 다만 생성자 함수는 아래 두 관례를 따른다.
1.  함수 이름의 첫 글자는 대문자로 시작한다.
2.  반드시  `'new'`  연산자를 붙여 실행한다.
```js
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User('보라');

alert(user.name); // 보라
alert(user.isAdmin); // false
```
다음과 같은 알고리즘이 실행된다.
```js
function User(name) {
  // this = {};  (빈 객체가 암시적으로 만들어진다.)

  // 새로운 프로퍼티를 this에 추가함
  this.name = name;
  this.isAdmin = false;

  // return this;  (this가 암시적으로 반환된다.)
```
이제 `let user = new User("보라")`는 아래 코드와 동일하게 동작한다.
```js
let user = {
  name: '보라',
  isAdmin: false
};
```
모든 함수는 생성자 함수가 될 수 있다는 점을 기억해야 한다. `new`를 붙이면 어떤 함수라도 위에 언급된 알고리즘이 실행된다.

---
:information_source: **new function() { … }**

재사용할 필요가 없는 복잡한 객체를 만들 때 익명 생성자 함수를 사용하면 된다.
```js
let user = new function() {
  this.name = 'John';
  this.isAdmin = false;

  // 사용자 객체를 만들기 위한 여러 코드, 지역 변수, 복잡한 로직, 구문 등의
  // 다양한 코드가 이곳에 들어간다.
};
```
---

## new.target과 생성자 함수
:information_source: **심화 학습**

`new.target` 프로퍼티를 사용하면 함수가 `new`와 함께 호출되었는지 여부를 알 수 있다.
```js
function User() {
  alert(new.target);
}

// 'new' 없이 호출한 경우에는 undefined를 반환한다.
User(); // undefined

// 'new'를 붙여 호출한 경우에는 함수 자체를 반환한다.
new User(); // function User { ... }
```
이를 활용해 일반적인 방법으로 함수를 호출해도 `new`를 붙여 호출한 것과 같이 동작하게 만들 수 있다.
```js
function User(name) {
  if (!new.target) { // new 없이 호출해도
    return new User(name); // new를 붙여준다.
  }

  this.name = name;
}

let bora = User('보라'); // 'new User'를 쓴 것처럼 바꿔준다.
alert(bora.name); // 보라
```
이 방식은 주로 라이브러리에서 사용하고 우리가 실제 코드를 작성할 때는 사용할 일이 거의 없다.

## 생성자와 return문
생성자 함수엔 보통 `return` 문이 없지만 `return`문이 있다면 다음과 같은 규칙이 적용된다.
1. 객체를  `return`  한다면  `this`  대신 객체가 반환된다.
```js
function BigUser() {
  this.name = '원숭이';
  
  return {name: '고릴라'};  // <-- this가 아닌 새로운 객체를 반환함
}

alert(new BigUser().name);  // 고릴라
```
2. 원시형을  `return`  한다면  `return`문이 무시된다.
```js
function SmallUser() {
  this.name = '원숭이';

  return; // <-- this를 반환함
}

alert(new SmallUser().name);  // 원숭이
```
`return`문이 있는 생성자 함수는 거의 없다. 위 예제들은 특이 케이스이다.

---
:information_source: **괄호 생략하기**

인수가 없는 생성자 함수는 괄호를 생략해 호출할 수 있지만 '좋은 스타일'은 아니다.
```js
let user = new User();
// 아래 코드는 위 코드와 똑같이 동작한다.
let user = new User;
```
---

## 생성자 내 메서드
생성자 함수를 사용하면 매개변수를 이용해 객체 내부를 자유롭게 구성할 수 있다.

다음과 같이 메서드를 더해주는 것도 가능하다.
```js
function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert('제 이름은 ' + this.name + '입니다.');
  };
}

let bora = new User('이보라');

bora.sayHi(); // 제 이름은 이보라입니다.

/*
bora = {
   name: '이보라',
   sayHi: function() { ... }
}
*/
```
[class]() 문법을 사용하면 생성자 함수를 사용하는 것과 마찬가지로 복잡한 객체를 만들 수 있다.
<br></br>
# 06. 옵셔널 체이닝 '?.'
---
:warning: **최근에 추가됨**
스펙에 추가된 지 얼마 안 된 문법으로 구식 브라우저는 폴리필이 필요하다.

---
옵셔널 체이닝(optional chaining) `?.`을 사용하면 프로퍼티가 없을 수 있는 중첩 객체에 에러 없이 안전하게 접근할 수 있다.
## 옵셔널 체이닝이 필요한 이유
존재하지 않는 객체의 프로퍼티에 접근하려 할 때 오류가 발생한다.
```js
let user = {}; // 주소 정보가 없는 사용자이다.

alert(user.address.street); // TypeError: Cannot read property 'street' of undefined
```
```js
// querySelector(...) 호출 결과가 null인 경우 에러 발생
let html = document.querySelector('.my-element').innerHTML;
```
명세서에 `?.`이 추가되기 전에는 이런 문제들을 해결하기 위해 `&&` 연산자를 사용하곤 했다.
```js
let user = {}; // 주소 정보가 없는 사용자이다.

alert(user && user.address && user.address.street); // undefined, 에러가 발생하지 않는다.
```

## 옵셔널 체이닝의 등장
`?.`은 왼쪽에 있는 평가 대상이 `undefined`나 `null`이면 평가를 멈추고 `undefined`를 반환한다.
```js
let user = {}; // 주소 정보가 없는 사용자이다.

alert(user?.address?.street); // undefined, 에러가 발생하지 않는다.
```
---
:warning: **옵셔널 체이닝을 남용해서는 안 된다.**

`?.`은 값이 없어도 되는 곳에서만 사용해야 한다. 그러지 않을 경우 에러를 조기에 발견하지 못하고 디버깅이 어려워진다.

---
:warning: **`?.`앞의 변수는 반드시 선언되어 있어야 한다.**

옵셔널 체이닝은 선언이 완료된 변수를 대상으로만 동작한다.

---

## 단락 평가
`?.`는 왼쪽 평가대상에 값이 없으면 즉시 평가를 멈춘다.
```js
let user = null;
let x = 0;

user?.sayHi(x++); // 아무 일도 일어나지 않는다.

alert(x); // 0, x는 증가하지 않는다.
```
## ?.()와 ?.[]
`?.()`은 존재하지 않을 수 있는 메서드에 안전하게 접근할 수 있다. `?.[]`은 존재하지 않을 수 있고 대괄호 표기법으로 접근해야 하는 프로퍼티에 안전하게 접근할 수 있다.
```js
let user1 = {
  admin() {
    alert('관리자 계정입니다.');
  }
}

let user2 = {};

user1.admin?.(); // 관리자 계정입니다.
user2.admin?.();
```
```js run
let user1 = {
  firstName: 'Violet'
};

let user2 = null; // user2는 권한이 없는 사용자이다.

let key = 'firstName';

alert(user1?.[key]); // Violet
alert(user2?.[key]); // undefined

alert( user1?.[key]?.something?.not?.existing); // undefined
```
- `?.`은 `delete`와 조합해 사용할 수도 있다.
```js
delete user?.name; // user가 존재하면 user.name을 삭제한다.
```

---
:warning: **`?.`은 읽기나 삭제하기에는 사용할 수 있지만 쓰기에는 사용할 수 없다.**

`?.`은 할당 연산자 왼쪽에서 사용할 수 없다.
```js
// user가 존재할 경우 user.name에 값을 쓰려는 의도로 아래와 같이 코드를 작성했다.

user?.name = 'Violet'; // SyntaxError: Invalid left-hand side in assignment
// 에러가 발생하는 이유는 undefined = 'Violet'이 되기 때문이다.
```
---
<br></br>
# 07. 심볼형
## 심볼
'심볼(symbol)'은 유일한 식별자(unique identifier)를 만들고 싶을 때 사용한다. `Symbol()`을 사용하면 심볼값을 만들 수 있다.
```js
// id는 새로운 심볼이 된다.
let id = Symbol();
```
심볼을 만들 때 심볼 이름이라 불리는 설명을 붙일 수도 있으며, 디버깅 시 유용하게 쓰인다.
```js
// 심볼 id에는 "id"라는 설명이 붙는다.
let id = Symbol('id');
```
심볼은 **유일성이 보장**되는 자료형이기 때문에, 설명이 동일한 심볼을 여러 개 만들어도 각 심볼값은 다르다. 심볼에 붙이는 설명(심볼 이름)은 어떤 것에도 영향을 주지 않는 이름표 역할만을 한다.


---
:warning: **심볼은 다른 자료형으로 자동 형 변환되지 않는다.**

```js
let id = Symbol('id');
alert(id); // TypeError: Cannot convert a Symbol value to a string
```
자바스크립트에선 '언어 차원의 보호장치(language guard)'를 마련해 심볼형이 다른 형으로 변환되지 않게 막아준다.

심볼을 반드시 출력해줘야 하는 상황이라면 `.toString()` 메서드를 이용하면 된다. 또는 `symbol.description` 프로퍼티를 이용하면 설명만 보여주는 것도 가능하다.
```js
let id = Symbol('id');
alert(id.toString()); // id
```
```js
let id = Symbol('id');
alert(id.description); // id
```
---

## '숨김' 프로퍼티
숨김 프로퍼티는 외부 코드에서 접근이 불가능하고 값도 덮어쓸 수 없는 프로퍼티이다.
```js
let user = { // 서드파티 코드에서 가져온 객체이다.
  name: 'John'
};

let id = Symbol('id');

user[id] = 1;

alert(user[id]); // 심볼을 키로 사용해 데이터에 접근할 수 있다.
```
문자열 `"id"`를 키로 사용해는 대신 `Symbol("id")`을 사용한 이유는 심볼을 사용하면 유일성을 보장받기 때문이다.

제3의 스크립트에서도 다음과 같이 `Symbol("id")`을 이용해 전용 식별자를 만들어 사용할 수 있다.
```js
// ...
let id = Symbol('id');

user[id] = '제3 스크립트 id 값';
```

### 객체 리터럴의 심볼
객체 리터럴 `{...}`을 사용해 객체를 만든 경우, 대괄호를 사용해 심볼형 키를 만들어야 한다.
```js
let id = Symbol('id');

let user = {
  name: 'John',
  [id]: 123 // "id": 123은 안된다.
};
```

### 심볼은 for…in 에서 배제된다.
```js
let id = Symbol('id');
let user = {
  name: 'John',
  age: 30,
  [id]: 123
};

for (let key in user) alert(key); // name과 age만 출력되고, 심볼은 출력되지 않는다.

// 심볼로 직접 접근하면 잘 작동한다.
alert('직접 접근한 값: ' + user[id]);
```
`Object.keys(user)`에서도 키가 심볼인 프로퍼티는 배제된다. '심볼형 프로퍼티 숨기기(hiding symbolic property)'라는 원칙 때문에 외부 스크립트나 라이브러리는 심볼형 키를 가진 프로퍼티에 접근하지 못한다.

반면 `Object.assign`은 키가 심볼인 프로퍼티를 배제하지 않고 객체 내 모든 프로퍼티를 복사한다.
```js
let id = Symbol('id');
let user = {
  [id]: 123
};

let clone = Object.assign({}, user);

alert(clone[id]); // 123
```

## 전역 심볼
이름이 같은 심볼이 같은 개체를 가리키길 원하는 경우에 전역 심볼 레지스트리(global symbol registry)를 사용한다.

레지스트리 안에 있는 심볼을 읽거나 새로운 심볼을 생성하려면 `Symbol.for(key)`를 사용하면 된다.
```js
// 전역 레지스트리에서 심볼을 읽는다.
let id = Symbol.for("id"); // 심볼이 존재하지 않으면 새로운 심볼을 만든다.

// 동일한 이름을 이용해 심볼을 다시 읽는다.
let idAgain = Symbol.for("id");

// 두 심볼은 같다.
alert( id === idAgain ); // true
```
전역 심볼 레지스트리 안에 있는 심볼을 **전역 심볼**이라고 부른다. 애플리케이션에서 광범위하게 사용해야 하는 심볼이라면 전역 심볼을 사용한다.

### Symbol.keyFor
`Symbol.keyFor(sym)`를 사용하면 심볼의 이름을 얻을 수 있다.
```js
// 이름을 이용해 심볼을 찾는다.
let sym = Symbol.for('name');
let sym2 = Symbol.for('id');

// 심볼을 이용해 이름을 얻는다.
alert(Symbol.keyFor(sym)); // name
alert(Symbol.keyFor(sym2)); // id
```
`Symbol.keyFor`는 전역 심볼 레지스트리를 뒤져서 해당 심볼의 이름을 얻어낸다. 검색 범위가 전역 심볼 레지스트리이기 때문에 전역 심볼이 아닌 심볼에는 사용할 수 없다. 전역 심볼이 아닌 인자가 넘어오면 `Symbol.keyFor`는 `undefined`를 반환한다.

전역 심볼이 아닌 일반 심볼에는 `description` 프로퍼티가 있다. 일반 심볼에서 이름을 얻고 싶을 때 사용한다.
```js run
let globalSymbol = Symbol.for('name');
let localSymbol = Symbol('name');

alert(Symbol.keyFor(globalSymbol)); // name, 전역 심볼이다.
alert(Symbol.keyFor(localSymbol)); // undefined, 전역 심볼이 아니다.

alert(localSymbol.description); // name
```

## 시스템 심볼
'시스템 심볼(system symbol)'은 자바스크립트 내부에서 사용되는 심볼이다. 시스템 심볼을 활용하면 객체를 미세 조정할 수 있다.

많이 사용하는 시스템 심볼은 다음과 같다.
-   `Symbol.hasInstance`
-   `Symbol.isConcatSpreadable`
-   `Symbol.iterator`
-   `Symbol.toPrimitive`

시스템 심볼 각각에 대한 내용은 연관되는 자바스크립트 기능을 학습할 때 알아볼 것이다.
<br></br>
# 08. 객체를 원시형으로 변환하기
## ToPrimitive
특수 객체 메서드를 사용하면 숫자형이나 문자형으로의 형 변환이 가능하다.

객체 형 변환은 세 종류로 구분되는데, **'hint’가 구분 기준이 된다. 'hint’는 목표로 하는 자료형이다.**

`"string"`

`alert`  함수같이 문자열을 기대하는 연산을 수행할 때는(객체-문자형 변환), hint가  `string`이 된다.
```js
// 객체를 출력하려고 한다.
alert(obj);

// 객체를 프로퍼티 키로 사용하고 있다.
anotherObj[obj] = 123;
```
`"number"`

수학 연산을 적용하려 할 때(객체-숫자형 변환), hint는  `number`가 된다.
```js
// 명시적 형 변환
let num = Number(obj);

// (이항 덧셈 연산을 제외한) 수학 연산 
let n = +obj; // 단항 덧셈 연산
let delta = date1 - date2;

// 크고 작음 비교하기
let greater = user1 > user2;
```

`"default"`

연산자가 기대하는 자료형이 ‘확실치 않을 때’ hint는  `default`가 된다. 아주 드물게 발생한다.
```js
// 이항 덧셈 연산은 hint로 `default`를 사용한다.
    let total = obj1 + obj2;

// obj == number 연산은 hint로 `default`를 사용한다.
if (user == 1) { ... };
```
연산자 `<`, `>` 역시 피연산자에 문자형과 숫자형 둘 다를 허용하는데, 이 연산자들은 hint를 'number’로 고정한다. 이는 하위 호환성 때문에 정해진 규칙이다.

`Date` 객체를 제외한 모든 내장 객체는 hint가 `"default"`인 경우와 `"number"`인 경우를 **동일하게 처리**한다. 우리가 커스텀 객체를 만들 때도 동일하게 처리한다.

---
:information_source: `"boolean"` hint는 존재하지 않는다.

모든 객체는 `true`로 평가된다. 우리도 내장 객체에 사용되는 규칙처럼 `"default"`와 `"number"`를 동일하게 처리하면  두 종류의 형 변환(객체-문자형, 객체-숫자형)만 남게 됩니다.

---

자바스크립트는 형 변환이 필요할 때, 아래와 같은 알고리즘에 따라 원하는 메서드를 찾고 호출한다.
1.  객체에  `obj[Symbol.toPrimitive](hint)`메서드가 있는지 찾고, 있다면 메서드를 호출한다.  `Symbol.toPrimitive`는 시스템 심볼로, 심볼형 키로 사용된다.
2.  hint가  `"string"`이라면 `obj.toString()` -> `obj.valueOf()` 순으로 호출한다.
3.  hint가  `"number"`나  `"default"`라면 `obj.valueOf()` -> `obj.toString()` 순으로 호출한다.

## Symbol.toPrimitive
목표로 하는 자료형(hint)에 따라 반환할 값을 설정한다.
```js
obj[Symbol.toPrimitive] = function(hint) {
  // 반드시 원시값을 반환해야 한다.
  // hint는 'string', 'number', 'default' 중 하나가 될 수 있다.
};
```
```js
let user = {
  name: 'John',
  money: 1000,

  // `user`는 hint에 따라 (자기 자신을 설명해주는) 문자열로 변환되기도 하고 
  // (가지고 있는 돈의 액수를 나타내는) 숫자로 변환되기도 한다.
  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == 'string' ? `{name: '${this.name}'}` : this.money;
  }
};

alert(user); // hint: string -> {name: 'John'}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
```

## toString과 valueOf
`toString`과 `valueOf`는 심볼이 생기기 이전부터 존재해 왔던 ‘평범한’ 메서드이다. 이 메서드를 이용하면 '구식’이긴 하지만 형 변환을 직접 구현할 수 있다.

객체에 `Symbol.toPrimitive`가 없으면 자바스크립트는 아래 규칙에 따라 `toString`이나 `valueOf`를 호출한다.
-   hint가 'string’인 경우:  `toString -> valueOf`  순(`toString`이 있다면  `toString`을 호출,  `toString`이 없다면  `valueOf`를 호출한다)
-   그 외:  `valueOf -> toString`  순

이 메서드들은 반드시 원시값을 반환해야한다. `toString`이나 `valueOf`가 객체를 반환하면 그 결과는 무시된다(메서드가 없는 것처럼 취급된다).

이 메서드들을 따로 정의해주지 않는 경우에는 다음 규칙을 따른다.
-   `toString`은 문자열  `"[object Object]"`을 반환한다.
-   `valueOf`는 객체 자신을 반환한다.

아래 코드는 위에서 `Symbol.toPrimitive`를 사용한 코드와 동일하게 동작한다.
```js
let user = {
  name: 'John',
  money: 1000,

  // hint가 'string'인 경우
  toString() {
    return `{name: "${this.name}"}`;
  },

  // hint가 'number'나 'default'인 경우
  valueOf() {
    return this.money;
  }
};

alert(user); // toString -> {name: 'John'}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
```

간혹 모든 형 변환을 한 곳에서 처리해야 하는 경우에는 `toString`만 구현해 주면 된다. 객체에 `Symbol.toPrimitive`와 `valueOf`가 없으면, `toString`이 모든 형 변환을 처리한다.
```js run
let user = {
  name: 'John',

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500
```

## 반환 타입
위에서 소개해드린 세 개의 메서드는 'hint’에 명시된 자료형으로의 형 변환을 보장해 주지 않는다.

`toString()`이 항상 문자열을 반환한다는 보장이 없고,  `Symbol.toPrimitive`의 hint가  `"number"`일 때 항상 숫자형 자료가 반환되리라는 보장이 없다.

한 가지 확실한 것은 객체가 아닌 원시값을 반환해 준다는 것뿐이다.

---
:information_source: **과거의 잔재**

`toString`이나 `valueOf`가 객체를 반환해도 에러가 발생하지 않고 반환값이 무시된다. 반면 `Symbol.toPrimitive`는 반드시 원시자료를 반환해야 하며, 그렇지 않으면 에러가 발생한다.

---

## 추가 형 변환
객체가 피연산자일 때는 다음과 같은 단계를 거쳐 형 변환이 일어난다.
1.  위에서 설명한 변환 규칙에 따라 객체가 원시형으로 변화된다.
2.  변환된 원시값이 원하는 형이 아닌 경우에는 또다시 형 변환이 일어난다.
```js
let obj = {
  // 다른 메서드가 없으면 toString에서 모든 형 변환을 처리한다.
  toString() {
    return '2';
  }
};

alert(obj * 2); // 4, 객체가 문자열 '2'로 바뀌고, 곱셈 연산 과정에서 문자열 '2'는 숫자 2로 변경된다.
```
