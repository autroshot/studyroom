# [04] 객체: 기본
## 01. 객체
 - **원시형(primitive type)**: 오직 하나의 데이터(문자열, 숫자 등)만 담을 수 있는 자료형으로 객체형을 제외한 모든 자료형이 이에 해당한다.
- **객체형**: 다양한 데이터를 담을 수 있는 자료형으로 키로 구분된 데이터 집합이나 복잡한 개체(entity)를 저장할 수 있다. 
- 객체는 중괄호 `{...}`를 이용해 만들 수 있다.
- 객체를 선언하는 방법은 다음과 같이 두 가지가 있는데 주로 **객체 리터럴(object literal)** 방법을 사용한다.
```js
let user =  new  Object();  // '객체 생성자' 문법
let user =  {};  // '객체 리터럴' 문법
```

### 리터럴과 프로퍼티
중괄호 `{...}` 안에는 ‘키: 값’ 쌍으로 구성된 프로퍼티가 들어간다.
```js
let user =  {    // 객체 
  name: 'John',  // 키: 'name', 값: 'John'
  age: 30        // 키: 'age', 값: 30
};
```
- `'콜론(:)'`을 기준으로 왼쪽에는 키가, 오른쪽에는 값이 위치한다. 프로퍼티 키는 프로퍼티 ‘**이름**’ 혹은 '식별자’라고도 부른다.
- 점 표기법(dot notation)을 이용하면 프로퍼티 값을 읽을 수 있다.
```js
// 프로퍼티 값 얻기
alert(user.name); // John
alert(user.age); // 30
```
- 프로퍼티 값에는 모든 자료형이 올 수 있으며 새로운 프로퍼티를 추가 방법은 다음과 같다.
```js
user.isAdmin =  true;
```
- `delete` 연산자를 사용하면 프로퍼티를 삭제할 수 있다.
```js
delete user.age;
```
- 여러 단어를 조합해서 프로퍼티 이름을 만드는 경우에는 프로퍼티 이름을 따옴표로 묶어줘야 한다.
```js
let user = {
  name: 'John',
  age: 30,
  'likes birds': true  // 복수의 단어는 따옴표로 묶어야 한다.
};
```
- 마지막 프로퍼티의 끝은 쉼표로 끝날 수 있으며 이것을 ‘trailing(길게 늘어지는)’ 혹은 ‘hanging(매달리는)’ 쉼표라고 부른다. 이렇게 끝에 쉼표를 붙이면 모든 프로퍼티가 유사한 형태를 보이기 때문에 프로퍼티를 추가, 삭제, 이동하는 것이 쉬워진다.
- 상수 객체는 수정될 수 있다.
```js
const user = {
  name: 'John'
};

user.name = 'Pete'; // 오류가 발생하지 않는다.

alert(user.name); // Pete
```
`const`는  `user=...`를 전체적으로 설정하려고 할 때만 오류가 발생한다.

상수 객체 프로퍼티를 만드는 또 다른 방법이 있는데,  [프로퍼티 플래그와 설명자]()  챕터에서 확인할 수 있다.

### 대괄호 표기법
여러 단어를 조합해 프로퍼티 키를 만든 경우에는 점 표기법 대신 '대괄호 표기법(square bracket notation)'을 사용해야 한다.
```js
let user = {};

// set
user['likes birds'] = true;

// get
alert(user['likes birds']); // true

// delete
delete user['likes birds'];
```
대괄호 표기법 안에서 문자열을 사용할 때는 문자열을 따옴표로 묶어줘야 한다는 점에 주의해야 한다.

대괄호 표기법을 사용하면 아래 예시에서 변수를 키로 사용한 것과 같이 문자열뿐만 아니라 모든 표현식의 평가 결과를 프로퍼티 키로 사용할 수 있다. 점 표기법은 이런 방식이 불가능하다.
```js
let key = 'likes birds';

user[key] = true; // user['likes birds'] = true;
```

### 계산된 프로퍼티
객체를 만들 때 객체 리터럴 안의 프로퍼티 키가 대괄호로 둘러싸여 있는 경우, 이를 계산된 프로퍼티(computed property)라고 부른다.
```js
let fruit = prompt('어떤 과일을 구매하시겠습니까?', 'apple');

let bag = {
  [fruit]: 5, // 변수 fruit에서 프로퍼티 이름을 동적으로 받아온다.
};

alert(bag.apple); // fruit에 'apple'이 할당되었다면, 5가 출력된다.
```
- 다음과 같이 대괄호 안에 복잡한 표현식을 넣는 것도 가능하다.
```js
let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};
```
- 대괄호 표기법은 프로퍼티 이름과 값의 제약을 없애주기 때문에 점 표기법보다 훨씬 강력하다. 그런데 작성하기 번거롭다는 단점이 있다. 이런 이유로 프로퍼티 이름이 확정된 상황이고 단순한 이름이라면 **점 표기법**을 사용하다가, 뭔가 복잡한 상황이 발생했을 때 **대괄호 표기법**으로 바꾸는 경우가 많다.

### 단축 프로퍼티
변수를 이용해 프로퍼티의 이름과 값을 만드는 경우, 프로퍼티 값 단축 구문(property value shorthand)을 사용하면 코드를 짧게 만들 수 있다.
```js
function makeUser(name, age) {
  return {
    name, // name: name
    age,  // age: age
    // ...
  };
}
```

### 프로퍼티 이름의 제약사항
프로퍼티 이름에는 특별한 제약이 없다. 예약어를 비롯한 어떤 문자형, 심볼형 값도 프로퍼티 키가 될 수 있다. 문자형이나 심볼형에 속하지 않은 값은 문자열로 자동 형 변환된다.
```js
let obj = {
  0: 'test' // '0': 'test'
};

// 숫자 0은 문자열 '0'으로 변환되기 때문에 두 얼럿 창은 같은 프로퍼티에 접근한다.
alert(obj['0']); // test
alert(obj[0]); // test (동일한 프로퍼티)
```
이와 같이 객체 프로퍼티 키에 쓸 수 있는 문자열엔 제약이 없지만, 역사적인 이유 때문에 특별대우를 받는 이름이 하나 있다. 바로 `__proto__`이다.
```js
let obj = {};
obj.__proto__ = 5; // 숫자를 할당한다.
alert(obj.__proto__); // [object Object] - 숫자를 할당했지만 값은 객체가 되었다.
```
`__proto__`의 본질은 [프로토타입 상속]()에서, 이 문제를 어떻게 해결할 수 있을지에 대해선 [프로토타입 메서드와 __proto__가 없는 객체]()에서 확인할 수 있다.

### ‘in’ 연산자로 프로퍼티 존재 여부 확인하기`
연산자 `in`을 사용하면 프로퍼티 존재 여부를 확인할 수 있다.
```js
'key' in object
```
`in` 왼쪽에는 반드시 프로퍼티 이름이 와야 한다. 프로퍼티 이름은 보통 따옴표로 감싼 문자열이다.

값에 `undefined`을 할당한 경우에는 `undefined`을 이용해서 프로퍼티 존재 여부를 제대로 판별할 수 없다. 따라서 **프로퍼티 존재 여부를 확인할 때는 `in`을 사용**하는 것을 추천한다.
```js
let obj = {
  test: undefined
};

alert(obj.test); // 값이 `undefined`이므로, 얼럿 창에는 undefined가 출력됩니다. 그런데 프로퍼티 test는 존재한다.

alert('test' in obj ); // `in`을 사용하면 프로퍼티 유무를 제대로 확인할 수 있다(true가 출력됨).
```
- 객체에 프로퍼티가 하나 이상 존재하는지 확인하는 함수는 다음과 같이 만들 수 있다.
```js
function isEmpty(obj) {
  for (let key in obj) {
    // 루프가 시작하면 프로퍼티가 있는 것이다.
    return false;
  }
  return true;
}
```

### 'for...in' 반복문
`for..in` 반복문을 사용하면 객체의 모든 키를 순회할 수 있다.
```js
for (key in object) {
  // 각 프로퍼티 키(key)를 이용하여 본문(body)을 실행한다.
}
```
```js
let user = {
  name: 'John',
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // 키
  alert(key);  // name, age, isAdmin
  // 키에 해당하는 값
  alert(user[key]); // John, 30, true
}
```
반복 변수(looping variable)를 선언(`let key`)했다는 점을 주목할 필요가 있다. 반복 변수명은 자유롭게 정할 수 있다.

### 객체 정렬 방식
정수 프로퍼티(integer property)는 자동으로 정렬되고, 그 외의 프로퍼티는 객체에 추가한 순서 그대로 정렬된다.
```js
let codes = {
  '49': '독일',
  '41': '스위스',
  '44': '영국',
  // ..,
  '1': '미국'
};

for (let code in codes) {
  alert(code); // 1, 41, 44, 49
}
```
- 정수 프로퍼티: 정수로 이루어진 문자열이다. 정수로 변환하거나 변환한 정수를 다시 문자열로 바꿔도 원본과 동일해야 한다.
```js
alert(String(Math.trunc(Number('49')))); // '49'가 출력된다. 기존에 입력한 값과 같으므로 정수 프로퍼티이다.
alert(String(Math.trunc(Number('+49')))); // '49'가 출력된다. 기존에 입력한 값(+49)과 다르므로 정수 프로퍼티가 아니다.
alert(String(Math.trunc(Number('1.2')))); // '1'이 출력된다. 기존에 입력한 값(1.2)과 다르므로 정수 프로퍼티가 아니다.
```
이름에 정수를 사용하면서 자동 정렬이 되지 않게 하려면 다음과 같은 속임수를 써야 한다.
```js
let codes = {
  '+49': '독일',
  '+41': '스위스',
  '+44': '영국',
  // ..,
  '+1': '미국'
};

for (let code in codes) {
  alert(+code); // 49, 41, 44, 1
}
```
<br></br>
## 02. 참조에 의한 객체 복사
원시값은 '값 그대로' 저장, 할당, 복사된다.
```js
let message = 'Hello!';
let phrase = message; // 'Hello!'가 그대로 복사된다.
```
객체는 '메모리 주소', 즉 '**참조 값**'이 복사된다.
```js
let user = {name: 'John'};
let admin = user; // 참조값을 복사한다.
```
변수는 두 개이지만 각 변수엔 동일 객체에 대한 참조 값이 저장되는 것이다.

따라서 객체에 접근하거나 객체를 조작할 때에 여러 변수를 사용할 수 있다.
```js
let user = {name: 'John'};
let admin = user;

admin.name = 'Pete'; // 'admin' 참조 값에 의해 변경된다.
alert(user.name); // 'Pete'가 출력된다. 'user' 참조 값을 이용해 변경사항을 확인한다.
```

### 참조에 의한 비교
객체 비교 시 동등 연산자 `==`와 일치 연산자 `===`는 동일하게 동작한다. 비교 시 피연산자인 두 객체가 동일한 객체인 경우에 참을 반환한다.
```js
let a = {};
let b = a;

alert(a == b); // true
alert(a === b); // true
```
```js
let a = {};
let b = {};

alert(a == b); // 독립된 두 객체이므로 false를 출력한다.
```

### 객체 복사, 병합과 Object.assign
객체의 참조 값을 복사하는 것이 아닌 객체 자체를 복사하려면 Object.assign을 사용할 수 있다. `assign` 메서드는 '**얕은 복사(shallow copy)**'를 가능하게 해준다.
```js
Object.assign(dest, [src1, src2, src3...])
```
- `dest`는 값을 넣을 객체이다.
- 이어지는 인수  `src1, ..., srcN`는 복사하고자 하는 객체이다.  `...`은 필요에 따라 얼마든지 많은 객체를 인수로 사용할 수 있다는 것을 나타낸다.
- 메서드는 객체 `src1, ..., srcN`의 프로퍼티를 `dest`에 복사하고 `dest`를 반환한다.
- `dest`에 동일한 이름을 가진 프로퍼티가 있을 경우에는 기존 값이 덮어씌워진다.

`assign` 메서드를 사용하면 여러 객체를 하나로 병합할 수 있다.
```js
let user = {name: 'John'};

let permissions1 = {canView: true};
let permissions2 = {canEdit: true};

// permissions1과 permissions2의 프로퍼티를 user로 복사한다.
Object.assign(user, permissions1, permissions2);

// now user = {name: 'John', canView: true, canEdit: true}
```
`assign` 메서드를 사용하면 간단하게 객체를 복사할 수 있다.
```js
let user = {
  name: 'John',
  age: 30
};

// user에 있는 모든 프로퍼티가 빈 배열에 복사되고, 해당 객체가 clone에 할당된다.
let clone = Object.assign({}, user);
```

### 중첩 객체 복사
객체의 프로퍼티가 원시값이 아닌 객체인 경우에는 복사가 어려워진다. 객체의 각 값을 검사하면서, 그 값이 객체인 경우 객체의 구조도 복사해주는 반복문을 사용해야 한다. 이런 방식을 '**깊은 복사(deep cloning)**'라고 한다.

자바스크립트 라이브러리 [lodash](https://lodash.com/)의 메서드인 [\_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep)을 사용하면 깊은 복사를 처리할 수 있다.
<
