# 1. 재귀와 스택
**함수가 자기 자신을 호출하는 것을 재귀라고 부른다.**

함수가 자신을 호출하는 단계를 <strong>재귀 단계(recursion step)</strong>라고 부른다. basis라고도 불리는 재귀의 <strong>베이스(base)</strong>는 작업을 아주 간단하게 만들어서 함수가 더 이상은 서브 호출을 만들지 않게 해주는 인수이다.

재귀적으로 정의된 자료 구조는 자기 자신을 이용해 자료 구조를 정의한다. 재귀적 구조의 대표적인 예는 <strong>연결 리스트(linked list)</strong>이다.

모든 재귀 함수는 반복문을 사용한 함수로 다시 작성할 수 있다. 최적화를 위해 반복문으로 다시 작성해야 할 수도 있다. 그러나 상당수 작업은 재귀를 사용해도 만족할 만큼 빠르게 동작한다. 재귀를 사용하면 구현과 유지보수가 쉽다는 장점도 있다.

자세한 설명과 예시는 [원본](https://ko.javascript.info/recursion)을 확인한다.

# 2. 나머지 매개변수와 스프레드 문법
상당수의 자바스크립트 내장 함수는 인수의 개수에 제약을 두지 않는다.

## 나머지 매개변수 ...
함수 정의 방법과 상관없이 함수에 넘겨주는 인수의 개수에는 제약이 없다.
```js
function sum(a, b) {
  return a + b;
}

alert(sum(1, 2, 3, 4, 5)); // 에러가 발생하지 않는다.
```
나머지 매개변수를 사용하려면 여분의 값들을 담을 배열의 이름 뒤에 `...`을 붙여서 함수 선언부에 넣는다.
```js
function showName(firstName, lastName, ...titles) {
  alert( firstName + ' ' + lastName ); // Bora Lee

  // 나머지 인수들은 배열 titles의 요소가 된다.
  // titles = ['Software Engineer', 'Researcher']
  alert(titles[0]); // Software Engineer
  alert(titles[1]); // Researcher
  alert(titles.length); // 2
}

showName('Bora', 'Lee', 'Software Engineer', 'Researcher');
```
모든 인수를 나머지 매개변수에 모으는 것도 가능하다.
```js
function sumAll(...args) { // args 배열에 모든 인수가 들어간다.
  let sum = 0;

  for (let arg of args) sum += arg;

  return sum;
}

alert(sumAll(1)); // 1
alert(sumAll(1, 2)); // 3
alert(sumAll(1, 2, 3)); // 6
```
---
:warning: **나머지 매개변수는 항상 마지막에 있어야 한다.**

나머지 매개변수가 마지막에 있지 않으면 에러가 발생한다.
```js
function f(arg1, ...rest, arg2) { // ...rest 후에 arg2가 있으면 안 된다.
  // 에러
}
```
---

## arguments 객체
유사 배열 객체(array-like object)인 `arguemnts`를 사용하면 인덱스를 사용해 인수에 접근할 수 있다.
```js
function showName() {
  alert(arguments.length);
  alert(arguments[0]);
  alert(arguments[1]);

  // arguments는 이터러블 객체이기 때문에
  // for(let arg of arguments) alert(arg);를 사용해 인수를 펼칠 수 있다.
}

// 2, Bora, Lee가 출력된다.
showName('Bora', 'Lee');

// 1, Bora, undefined가 출력된다(두 번째 인수는 없다).
showName('Bora');
```
나머지 매개변수는 비교적 최근 나온 문법으로 이전에는 함수의 인수 전체를 얻어내는 방법이 `arguemnts`를 사용하는 것뿐이었다.

`arguments`는 유사 배열 객체이면서 이터러블(반복 가능한) 객체이다. 배열은 아니므로 배열 메서드는 사용할 수 없다는 단점이 존재한다. 또한 `arguments`는 인수 전체를 담기 때문에 나머지 매개변수처럼 인수의 일부만 사용할 수 없다는 단점도 있다.

따라서 배열 메서드를 사용하거나 인수 일부만 사용할 때는 나머지 매개변수를 사용하는 것이 좋다.

---
:information_source: **화살표 함수는 `arguments` 객체를 지원하지 않는다.**

앞서 배웠듯이 화살표 함수는 고유한 `this`를 가지지 않는다.

`this`와 마찬가지로 화살표 함수에서 `arguments` 객체에 접근하면, 외부에 있는 ‘일반’ 함수의 `arguments` 객체를 가져온다.
```js
function f() {
  let showArg = () => alert(arguments[0]);
  showArg();
}

f(1); // 1
```
---

## 스프레드 문법
전개 문법이라고도 불리는 <strong>스프레드 문법(spread syntax)</strong>은 `...`를 사용하기 때문에 나머지 매개변수와 똑같아 보이지만 정반대의 기능을 한다.

함수를 호출할 때 `...arr`를 사용하면, 이터러블 객체 `arr`이 인수 목록으로 '확장’된다.
```js
let arr = [3, 5, 1];

alert(Math.max(...arr)); // 5, 스프레드 문법이 배열을 인수 목록으로 바꿔주었다.
```
이터러블 객체 여러 개를 전달하는 것도 가능하다.
```js
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert(Math.max(...arr1, ...arr2)); // 8
```
스프레드 문법은 배열을 합칠 때 활용할 수 있다.
```js
let arr = [3, 5, 1];
let arr2 = [8, 9, 15];

let merged = [0, ...arr, 2, ...arr2];

alert(merged); // 0,3,5,1,2,8,9,15
```
배열뿐만 아니라 이터러블 객체이면 스프레드 문법을 사용할 수 있다.

문자열은 이터러블이므로 스프레드 문법을 사용할 수 있다.
```js
let str = 'Hello';

alert([...str]); // H,e,l,l,o
```
`Array.from`을 사용해도 동일한 작업을 할 수 있는데 `Array.from(obj)`와 `[...obj]`는 다음과 같은 미묘한 차이가 있다.
-   `Array.from`은 유사 배열 객체와 이터러블 객체 둘 다에 사용할 수 있다.
-   스프레드 문법은 이터러블 객체에만 사용할 수 있다.
따라서 무언가를 배열로 바꿀 때는 스프레드 문법보다 `Array.from`을 많이 사용한다.

## 배열과 객체의 복사본 만들기
이전 챕터에서 객체를 복사할 때 `Object.assign()`을 사용한다고 배웠던 적이 있다.

`Object.assign()` 말고도 스프레드 문법을 사용하면 배열과 객체를 복사할 수 있다.
```js
let arr = [1, 2, 3];
let arrCopy = [...arr]; // 배열을 펼쳐서 각 요소를 분리해 매개변수 목록으로 만든 다음에
                        // 매개변수 목록을 새로운 배열에 할당한다.

// 배열 복사본의 요소가 기존 배열 요소와 같은지 확인한다.
alert(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true

// 두 배열이 같은지 확인한다.
alert(arr === arrCopy); // false, 참조가 다르다.

// 참조가 다르므로 기존 배열을 수정해도 복사본은 영향을 받지 않는다.
arr.push(4);
alert(arr); // 1, 2, 3, 4
alert(arrCopy); // 1, 2, 3
```
```js
let obj = { a: 1, b: 2, c: 3 };
let objCopy = { ...obj }; // 객체를 펼쳐서 각 요소를 분리해 매개변수 목록으로 만든 다음에
                          // 매개변수 목록을 새로운 객체에 할당한다.

// 객체 복사본의 프로퍼티들이 기존 객체의 프로퍼티들과 같은지 확인한다.
alert(JSON.stringify(obj) === JSON.stringify(objCopy)); // true

// 두 객체는 같은지 확인한다.
alert(obj === objCopy); // false, 참조가 다르다.

// 참조가 다르므로 기존 객체를 수정해도 복사본은 영향을 받지 않는다.
obj.d = 4;
alert(JSON.stringify(obj)); // {"a":1,"b":2,"c":3,"d":4}
alert(JSON.stringify(objCopy)); // {"a":1,"b":2,"c":3}
```
이렇게 스프레드 문법을 사용하는 것이 `Object.assign()`을 사용하는 것보다 코드가 간단하므로 우리는 가능하면 스프레드 문법을 사용하도록 한다.

# 3. 변수의 유효범위와 클로저
---
:information_source: **이 챕터에서는 `let`, `const`로 선언한 변수만 다룬다.**

-   이번 주제의 모든 예시에서는  `let`으로 선언한 변수를 사용할 예정이다.
-   `const`로 선언한 변수 역시  `let`  변수와 동일하게 동작한다. 따라서 예시의  `let`을  `const`로 바꿔도 동일한 동작을 기대할 수 있다.
-   `var`는  `let`과  `const`로 선언한 변수와 몇 가지 중요한 차이가 있다. 자세한 내용은 뒤의 챕터에서 다룰 것이다.
---

## 코드 블록
코드 블록 `{...}` 안에서 선언한 변수는 블록 안에서만 사용할 수 있다.
```js
{
  // 지역 변수를 선언하고 몇 가지 조작을 했지만 그 결과를 밖에서 볼 수 없다.

  let message = '안녕하세요.'; // 블록 내에서만 변숫값을 얻을 수 있다.

  alert(message); // 안녕하세요.
}

alert(message); // ReferenceError: message is not defined
```
이런 블록의 특징은 특정 작업을 수행하는 코드를 한데 묶어두는 용도로 활용할 수 있다. 블록 안에는 작업 수행에 필요한 변수만 들어가는 것이다.
```js
{
  // 메시지 출력
  let message = '안녕하세요.';
  alert(message);
}

{
  // 또 다른 메시지 출력
  let message = '안녕히 가세요.';
  alert(message);
}
```
---
:information_source: **블록이 없으면 에러가 발생한다.**

이미 선언된 변수와 동일한 이름을 가진 변수를 별도의 블록 없이 `let`으로 선언하면 에러가 발생한다.
```js
// 메시지 출력
let message = '안녕하세요.';
alert(message);

// 또 다른 메시지 출력
let message = '안녕히 가세요.'; // SyntaxError: Identifier 'message' has already been declared
alert(message);
```
---

`if`, `for`, `while` 등에서도 마찬가지로 `{...}` 안에서 선언한 변수는 오직 블록 안에서만 접근이 가능하다.

참고로 `for`의 소괄호 안에서 선언한 변수(`let i`)는 `{...}` 밖에 있지만 `{...}`에 속한 코드로 취급된다.

## 중첩 함수
함수 내부에서 선언한 함수를 **중첩(nested) 함수**라고 부른다. 자바스크립트에서는 손쉽게 중첩 함수를 만들 수 있다.

중첩 함수는 다음과 같이 코드를 정돈할 때 사용할 수 있다.
```js
function sayHiBye(firstName, lastName) {
  // 헬퍼(helper) 중첩 함수
  function getFullName() {
    return firstName + ' ' + lastName;
  }

  alert('Hello, ' + getFullName());
  alert('Bye, ' + getFullName());

}
```
다음 함수 `makeCounter`는 호출될 때마다 다음 숫자를 반환해주는 ‘카운터’ 함수를 만든다.
```js
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();

alert(counter()); // 0
alert(counter()); // 1
alert(counter()); // 2
```

## 렉시컬 환경
자바스크립트에서는 실행 중인 함수, 코드 블록 `{...}`, 스크립트 전체는 <strong>렉시컬 환경(Lexical Environment)</strong>이라고 불리는 내부 숨김 연관 객체(internal hidden associated object)를 갖는다.

렉시컬 환경 객체는 두 부분으로 구성된다.
1. <strong>환경 레코드(Environment Record)</strong> – 모든 지역 변수를 프로퍼티로 저장하고 있는 객체이다. `this` 값과 같은 기타 정보도 여기에 저장된다.
2. <strong>외부 렉시컬 환경(Outer Lexical Environment)</strong>에 대한 참조 – 외부 코드와 연관된다.

’변수’는 특수 내부 객체인  환경 레코드의 프로퍼티일 뿐이다. '변수를 가져오거나 변경’하는 것은 '환경 레코드의 프로퍼티를 가져오거나 변경’함을 의미한다.

스크립트 전체와 관련된 렉시컬 환경은 전역 렉시컬 환경(global Lexical Environment)이라고 한다.

스크립트가 시작되면 스크립트 내에서 선언한 변수 전체가 렉시컬 환경에 올라간다(pre-populated). 이때 변수의 상태는 특수 내부 상태(special internal state)인 'uninitialized’가 된다. 자바스크립트 엔진은 uninitialized 상태의 변수를 인지하긴 하지만, let을 만나기 전까진 이 변수를 참조할 수 없다. 일시적으로 변수를 사용할 수 없는 구간, 코드 블록 시작부터 let을 만나기 전까지의 구간을 'dead zone'이라고도 부른다.

함수를 호출해 실행하면 새로운 렉시컬 환경이 자동으로 만들어진다. 이 렉시컬 환경에는 함수 호출 시 넘겨받은 매개변수와 함수의 지역 변수가 저장된다.

코드에서 변수에 접근할 때, 먼저 내부 렉시컬 환경을 검색 범위로 잡는다. 내부 렉시컬 환경에서 원하는 변수를 찾지 못하면 검색 범위를 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 확장한다. 이 과정은 검색 범위가 전역 렉시컬 환경으로 확장될 때까지 반복된다.

모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억한다. 함수는 `[[Environment]]`라 불리는 숨김 프로퍼티를 갖는데, 여기에 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장된다. `[[Environment]]`는 함수가 생성될 때 값이 정해지고 영원히 변하지 않는다.

자세한 설명과 예시는 [본문](https://ko.javascript.info/closure#ref-3654)을 참고한다.

---
:information_source: **클로저**

클로저는 **외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수**를 의미한다.

자바스크립트에서는 모든 함수가 자연스럽게 클로저가 된다. 예외가 하나 있는데 이는 new Function 문법 챕터에서 다룰 것이다.

자바스크립트의 함수는 숨김 프로퍼티인 `[[Environment]]`를 이용해 자신이 어디서 만들어졌는지를 기억한다. 함수 본문에서는 `[[Environment]]`를 사용해 외부 변수에 접근한다.

---

## 가비지 컬렉션
함수 호출이 끝나면 함수에 대응하는 렉시컬 환경이 메모리에서 제거된다. 함수와 관련된 변수들은 이때 모두 사라진다.

호출이 끝난 후에도 여전히 도달 가능한 중첩 함수가 있을 수 있다. 이때는 이 중첩함수의 `[[Environment]]` 프로퍼티에 외부 함수 렉시컬 환경에 대한 정보가 저장된다. 도달 가능한 상태가 되는 것이다. 함수 호출은 끝났지만 렉시컬 환경이 메모리에 유지되는 이유는 바로 이것 때문이다.
```js
function f() {
  let value = 123;

  return function() {
    alert(value);
  }
}

let g = f(); // g.[[Environment]]에 f() 호출 시 만들어지는 렉시컬 환경 정보가 저장된다.
```
렉시컬 환경 객체는 다른 객체와 마찬가지로 도달할 수 없을 때 메모리에서 삭제된다. 해당 렉시컬 환경 객체를 참조하는 중첩 함수가 하나라도 있으면 사라지지 않는다.
```js
function f() {
  let value = 123;

  return function() {
    alert(value);
  }
}

let g = f(); // g가 살아있는 동안엔 연관 렉시컬 환경도 메모리에 살아있다.

g = null; // 도달할 수 없는 상태가 되었으므로 메모리에서 삭제된다.
```

### 최적화 프로세스
이론상으로는 함수가 살아있는 동안에 모든 외부 변수가 메모리에 유지된다.

그러나 실제로는 자바스크립트 엔진이 이를 지속해서 최적화한다. 자바스크립트 엔진은 변수 사용을 분석하고 외부 변수가 사용되지 않는다고 판단되면 이를 메모리에서 제거한다.

**디버깅 시, 최적화 과정에서 제거된 변수를 사용할 수 없다는 점은 V8 엔진(Chrome, Opera에서 쓰임)의 주요 부작용이다.**

이러한 부작용 때문에 생길 수 있는 상황 중 하나는 다음과 같다.
```js
let value = '이름이 같은 다른 변수';

function f() {
  let value = '가장 가까운 변수';

  function g() {
    debugger; // 콘솔에 alert(value);를 입력하면 '이름이 같은 다른 변수'가 출력된다.
  }

  return g;
}

let g = f();
g();
```

# 4. 오래된 var
---
:information_source: **오래된 스크립트를 읽는 데 도움을 주는 챕터이다.**

이번 주제에서는 작성된 지 오래된 스크립트를 읽는 데 도움을 줄 만한 내용을 다룬다.

새로운 코드를 작성할 때는 이 방법을 쓰면 안 된다.

---
`var`로 선언한 변수는 `let`으로 선언한 변수와 유사하다. 대부분의 경우에는 `let`을 `var`로, `var`를 `let`으로 바꿔도 큰 문제 없이 동작하지만 몇 가지 차이가 존재한다.

## var는 블록 스코프가 없다.
`var`로 선언한 변수의 스코프는 함수 스코프이거나 전역 스코프이다. 블록 기준으로 스코프가 생기지 않기 때문에 블록 밖에서 접근 가능하다.
```js
if (true) {
  var test = true; // 'let' 대신 'var'를 사용했다.
}

alert(test); // true(if 문이 끝났어도 변수에 여전히 접근할 수 있다)
```
코드 블록이 함수 안에 있다면, `var`는 함수 레벨 변수가 된다.
```js
function sayHi() {
  if (true) {
    var phrase = 'Hello';
  }

  alert(phrase); // 제대로 출력된다.
}

sayHi();
alert(phrase); // Error: phrase is not defined
```
`var`는 `if`, `for` 등의 코드 블록을 관통한다. 아주 오래전의 자바스크립트에서는 블록 수준 렉시컬 환경이 만들어지지 않았기 때문이다. `var`는 구식 자바스크립트의 잔재이다.

## var는 재선언을 허용한다.
`let`을 이용해 동일한 스코프에서 재선언을 하면 에러가 발생한다.
```js
let user;
let user; // SyntaxError: 'user' has already been declared
```
`var`는 몇 번이고 재선언이 가능하다.
```js
var user = 'Pete';

var user = 'John'; // 이 'var'는 아무 기능도 하지 않는다.
// 에러가 발생하지 않는다.

alert(user); // John
```

## 선언하기 전 사용할 수 있는 var
`var` 선언은 함수가 시작될 때 처리된다. 전역에서 선언한 변수라면 스크립트가 시작될 때 처리된다.

아래 두 예제는 동일하게 동작한다.
```js
function sayHi() {
  phrase = 'Hello';

  alert(phrase);

  var phrase;
}
sayHi();
```
```js
function sayHi() {
  var phrase;

  phrase = 'Hello';

  alert(phrase);
}
sayHi();
```
코드 블록은 무시되기 때문에 아래 코드 역시 동일하게 동작한다.
```js
function sayHi() {
  phrase = 'Hello';

  if (false) { // 이 코드 블록 안은 절대 실행되지 않지만, 이는 호이스팅에 영향을 주지 않는다.
    var phrase;
  }

  alert(phrase);
}
sayHi();
```
이렇게 변수가 끌어올려 지는 현상을 <strong>호이스팅(hoisting)</strong>이라고 부른다. `var`로 선언한 모든 변수는 함수의 최상위로 ‘끌어 올려지기(hoisted)’ 때문이다.

**선언은 호이스팅 되지만 할당은 호이스팅 되지 않는다.**

따라서 아래 두 코드는 동일하게 동작한다.
```js
function sayHi() {
  alert(phrase);  

  var phrase = 'Hello';
}

sayHi(); // undefined
```
```js
function sayHi() {
  var phrase; // 선언은 함수 시작 시 처리된다.

  alert(phrase);

  phrase = 'Hello'; // 할당은 실행 흐름이 해당 코드에 도달했을 때 처리된다.
}

sayHi(); // undefined
```

### 즉시 실행 함수 표현식
`let`, `const`가 없던 과거에는 `var`가 블록 레벨 스코프를 가질 수 있게 여러가지 방안을 고려했다. 이때 만들어진 것이 '즉시 실행 함수 표현식(immediately-invoked function expressions)'이다. 즉시 실행 함수 표현식은 `IIFE`라고 부르기도 한다.
```js
(function() {

  let message = 'Hello';

  alert(message); // Hello

})();
```
함수 표현식이 만들어지고 바로 호출되면서, 해당 함수가 바로 실행되었다. 이 함수는 자신만의 변수를 갖는다.

괄호를 사용하는 방법 말고도 자바스크립트가 함수 표현식이라고 인식하게 해주는 다른 방법들이 있다.
```js
// IIFE를 만드는 방법

(function() {
  alert('함수를 괄호로 둘러싸기');
})();

(function() {
  alert('전체를 괄호로 둘러싸기');
}());

!function() {
  alert('표현식 앞에 비트 NOT 연산자 붙이기');
}();

+function() {
  alert('표현식 앞에 단항 덧셈 연산자 붙이기');
}();
```

# 5. 전역 객체
전역 객체를 사용하면 어디서나 사용 가능한 변수나 함수를 만들 수 있다. 전역 객체는 언어 자체나 호스트 환경에 기본 내장되어 있는 경우가 많다.

전역 객체에는 `Array`와 같은 내장 객체, `window.innerHeight`(뷰포트의 높이를 반환함)같은 브라우저 환경 전용 변수 등이 저장되어 있다.

전역 객체는 `globalThis`라는 보편적인 이름으로 불린다. 하지만 '관습’에 따라 브라우저에서는 `window`, Node.js에서는 `global`이라는 이름으로 불릴 때가 많다. `globalThis`는 제안 목록에 추가 된 지 얼마 안 된 기능이기 때문에, 비 크로미움 기반 브라우저에서는 지원하지 않다(폴리필을 구현하면 사용할 수 있다).

전역 객체의 모든 프로퍼티는 아래와 같이 직접 접근할 수 있다.
```js
alert('Hello');
// 위와 동일하게 동작한다.
window.alert('Hello');
```
브라우저에서 `let`이나 `const`가 아닌 `var`로 선언한 전역 함수나 전역 변수는 전역 객체의 프로퍼티가 된다.
```js
var gVar = 5;

alert(window.gVar); // 5(var로 선언한 변수는 전역 객체 window의 프로퍼티가 된다.)
```
`let`을 사용하면 위 예시와는 달리 전역 객체를 통해 변수에 접근할 수 없다.
```js
let gLet = 5;

alert(window.gLet); // undefined(let으로 선언한 변수는 전역 객체의 프로퍼티가 되지 않는다.)
```
아래와 같이 전역 객체에 직접 프로퍼티를 추가하면 모든 곳에서 사용할 수 있다.
```js
// 모든 스크립트에서 현재 사용자(current user)에 접근할 수 있게 이를 전역 객체에 추가한다.
window.currentUser = {
  name: 'John'
};

// 아래와 같은 방법으로 모든 스크립트에서 currentUser에 접근할 수 있다.
alert(currentUser.name);  // John

// 지역 변수 'currentUser'가 있다면
// 지역 변수와 충돌 없이 전역 객체 window에서 이를 명시적으로 가져올 수 있다.
alert(window.currentUser.name); // John
```
**전역 변수는 되도록 사용하지 않는 것이 좋다.** 함수를 만들 때 외부 변수나 전역 변수를 사용하는 것보다, ‘인풋’ 변수를 받고 이를 이용해 '아웃풋’을 만들어내게 해야 한다. 이 방법이 테스트도 쉽고, 에러도 덜 만들어낸다.

## 폴리필 사용하기
전역 객체를 이용해 현재 사용중인 브라우저가 최신 자바스크립트 기능을 지원하는지 여부를 확인할 수 있다.

예를 들어 내장 객체 `Promise`를 지원하는지 여부를 아래와 같이 확인할 수 있다.
```js
if (!window.Promise) {
  alert('구식 브라우저를 사용 중이시군요!');
}
```
명세에는 있는 기능이지만 해당 기능을 지원하지 않는 오래된 브라우저를 사용하고 있다면 직접 함수를 만들어 전역 객체에 추가하는 방식으로 '폴리필'을 만들 수 있다.
```js
if (!window.Promise) {
  window.Promise = ... // 모던 자바스크립트에서 지원하는 기능을 직접 구현한다.
}
```

# 6. 객체로서의 함수와 기명 함수 표현식
**함수는 객체이다.**

함수는 호출이 가능한(callable) '행동 객체’라고 이해하면 쉽다. 우리는 함수를 호출 할 수 있을 뿐만 아니라 객체처럼 함수에 프로퍼티를 추가·제거하거나 참조를 통해 전달할 수도 있다.

함수 객체에는 몇 가지 쓸만한 프로퍼티가 존재한다.

## 'name' 프로퍼티
`name` 프로퍼티를 사용하면 함수의 이름을 가져올 수 있다.
```js
function sayHi() {
  alert('Hi');
}

alert(sayHi.name); // sayHi
```
익명 함수도 자동으로 이름이 할당된다.
```js
let sayHi = function() {
  alert('Hi');
};

alert(sayHi.name); // sayHi(익명 함수이지만 이름이 있다.)
```
기본값을 사용한 경우도 자동으로 이름이 할당된다.
```js
function f(sayHi = function() {}) {
  alert(sayHi.name); // sayHi
}

f();
```
자바스크립트 명세서에서는 이 기능을 'contextual name’이라고 부른다. 이름이 없는 함수의 이름을 지정할 때 컨텍스트에서 이름을 가져온다.

객체 메서드의 이름도 `name` 프로퍼티를 이용해 가져올 수 있다.
```js
let user = {

  sayHi() {
    // ...
  },

  sayBye: function() {
    // ...
  }

}

alert(user.sayHi.name); // sayHi
alert(user.sayBye.name); // sayBye
```
그런데 객체 메서드 이름은 함수처럼 자동 할당이 되지 않는다. 적절한 이름을 추론하는 것이 불가능한 상황이 있는데, 이때 name 프로퍼티에는 빈 문자열이 저장된다.
```js
// 배열 안에서 함수를 생성한다.
let arr = [function() {}];

alert(arr[0].name); // <빈 문자열>
// 엔진이 이름을 설정할 수 없어서 name 프로퍼티의 값이 빈 문자열이 되었다.
```
위와 같은 상황은 특수한 경우로 실무에서는 만나기 힘들다.

## 'length' 프로퍼티
내장 프로퍼티 `length`는 함수 매개변수의 개수를 반환한다.
```js
function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}

alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length); // 2
```
위 예시에서 나머지 매개변수는 개수에 포함되지 않는다는 사실 또한 확인할 수 있다.

한편, `length` 프로퍼티는 다른 함수 안에서 동작하는 함수의 타입을 검사(type introspection) 할 때도 종종 사용된다.
```js
function ask(question, ...handlers) {
  let isYes = confirm(question);

  for(let handler of handlers) {
    if (handler.length == 0) {
      if (isYes) handler();
    } else {
      handler(isYes);
    }
  }

}

// 사용자가 OK를 클릭한 경우, 핸들러 두 개를 모두 호출한다.
// 사용자가 Cancel을 클릭한 경우, 두 번째 핸들러만 호출한다.
ask('질문 있으신가요?', () => alert('OK를 선택하셨습니다.'), result => alert(result));
```
인수의 종류에 따라(위 예시에서는 인수의 `length` 프로퍼티 값에 따라) 인수를 다르게 처리하는 방식을 프로그래밍 언어에서 <strong>다형성(polymorphism)</strong>이라고 부른다. 자바스크립트 라이브러리에서 다형성이 종종 사용되는 것을 확인할 수 있다.

## 커스텀 프로퍼티
함수에 자체적으로 만든 프로퍼티를 추가할 수도 있다.
```js
function sayHi() {
  alert('Hi');
  
  // 함수를 몇 번 호출했는지 센다.
  sayHi.counter++;
}
sayHi.counter = 0; // 초깃값

sayHi(); // Hi
sayHi(); // Hi

alert(`호출 횟수: ${sayHi.counter}회`); // 호출 횟수: 2회
```
---
:warning: **프로퍼티는 변수가 아니다.**

`sayHi.counter = 0`와 같이 함수에 프로퍼티를 할당해도 함수 내에 지역변수 `counter`가 만들어지지 않는다. `counter` 프로퍼티와 변수 `let counter`는 전혀 관계가 없다.

프로퍼티를 저장하는 것처럼 함수를 객체처럼 다룰 수 있지만, 이는 실행에 아무 영향을 끼치지 않는다. 변수는 함수 프로퍼티가 아니고 함수 프로퍼티는 변수가 아니기 때문이다. 둘 사이에는 공통점이 없다.

---

**클로저는 함수 프로퍼티로 대체할 수 있다.**

[변수의 유효범위와 클로저](https://github.com/autroshot/studyroom/blob/main/01-javascript/01-%EC%BD%94%EC%96%B4%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/06-%ED%95%A8%EC%88%98%20%EC%8B%AC%ED%99%94%ED%95%99%EC%8A%B5.md#3-%EB%B3%80%EC%88%98%EC%9D%98-%EC%9C%A0%ED%9A%A8%EB%B2%94%EC%9C%84%EC%99%80-%ED%81%B4%EB%A1%9C%EC%A0%80) 챕터에서 살펴본 바 있는 counter 함수를 함수 프로퍼티를 사용해 다음과 같이 바꿀 수 있다.
```js
function makeCounter() {
  // let count = 0 대신 아래 메서드(프로퍼티)를 사용한다.
  
  function counter() {
    return counter.count++;
  };

  counter.count = 0;

  return counter;
}

let counter = makeCounter();
alert(counter()); // 0
alert(counter()); // 1
```
클로저를 사용하는 방법과 함수 프로퍼티를 사용하는 방법의 차이는 **외부에서 접근이 가능한가**의 여부이다.
```js run
function makeCounter() {
  function counter() {
    return counter.count++;
  };

  counter.count = 0;

  return counter;
}

let counter = makeCounter();

counter.count = 10; // 외부에서 값을 수정할 수 있다.
alert(counter()); // 10
```
따라서 구현 방법은 목적에 따라 선택하면 된다.

## 기명 함수 표현식
<strong>기명 함수 표현식(Named Function Expression, NFE)</strong>은 이름이 있는 함수 표현식이다.

일반적인 함수 표현식은 다음과 같다.
```js
let sayHi = function(who) {
  alert(`Hello, ${who}`);
};
```
여기에 이름을 붙인 것이 기명 함수 표현식이다.
```js
let sayHi = function func(who) {
  alert(`Hello, ${who}`);
};
```
기명 함수 표현식은 다음과 같은 특성을 가진다.
1.  이름을 사용해 함수 표현식 내부에서 자기 자신을 참조할 수 있다.
2.  기명 함수 표현식 외부에서는 그 이름을 사용할 수 없다.

이 기능은 다음과 같이 재귀에서 활용할 수 있다.
```js
let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func('Guest'); // func를 사용해서 자신을 호출한다.
  }
};

sayHi(); // Hello, Guest

// 하지만 아래와 같이 func를 호출하는 건 불가능하다.
func(); // Error, func is not defined(기명 함수 표현식 밖에서는 그 이름에 접근할 수 없다.)
```
대부분의 개발자는 아래와 같이 코드를 작성하곤 한다.
```js
let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    sayHi('Guest');
  }
};
```
하지만 이렇게 코드를 작성하면 외부 코드에 의해 `sayHi`가 변경될 수 있다는 문제가 생긴다.
```js
let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    sayHi('Guest'); // TypeError: sayHi is not a function
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // 에러가 발생한다. 중첩 sayHi 호출은 더 이상 불가능하다.
```
함수가 `sayHi`를 자신의 외부 렉시컬 환경에서 가지고 오기 때문에 에러가 발생한다.

기명 함수 표현식을 이용하면 이 문제를 해결할 수 있다.
```js
let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func('Guest');
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // Hello, Guest(중첩 호출이 제대로 동작한다.)
```
`func`라는 이름은 함수 지역 수준(function-local)에 존재하므로 외부 렉시컬 환경에서 찾지 않아도 된다. 물론 외부 렉시컬 환경에서는 보이지 않는다.

---
:information_source: **함수 선언문에서는 내부 이름을 지정할 수 없다.**

함수 선언문에는 ‘내부’ 이름을 지정할 수 있는 문법이 없다.

개발을 하다 보면 믿을만한 내부 이름이 필요할 때가 생기곤 한다. 이 때 바로 함수 선언문을 기명 함수 표현식으로 다시 정의하면 된다.

---
