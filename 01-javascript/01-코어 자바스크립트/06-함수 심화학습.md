# 1. 재귀와 스택
**함수가 자기 자신을 호출하는 것을 재귀라고 부른다.**

함수가 자신을 호출하는 단계를 <strong>재귀 단계(recursion step)</strong>라고 부른다. basis라고도 불리는 재귀의 <strong>베이스(base)</strong>는 작업을 아주 간단하게 만들어서 함수가 더 이상은 서브 호출을 만들지 않게 해주는 인수이다.

재귀적으로 정의된 자료 구조는 자기 자신을 이용해 자료 구조를 정의한다. 재귀적 구조의 대표적인 예는 <strong>연결 리스트(linked list)</strong>이다.

모든 재귀 함수는 반복문을 사용한 함수로 다시 작성할 수 있다. 최적화를 위해 반복문으로 다시 작성해야 할 수도 있다. 그러나 상당수 작업은 재귀를 사용해도 만족할 만큼 빠르게 동작한다. 재귀를 사용하면 구현과 유지보수가 쉽다는 장점도 있다.

자세한 설명과 예시는 [원본](https://ko.javascript.info/recursion)을 확인한다.

# 2. 나머지 매개변수와 스프레드 문법
상당수의 자바스크립트 내장 함수는 인수의 개수에 제약을 두지 않는다.

## 나머지 매개변수 ...
함수 정의 방법과 상관없이 함수에 넘겨주는 인수의 개수에는 제약이 없다.
```js
function sum(a, b) {
  return a + b;
}

alert(sum(1, 2, 3, 4, 5)); // 에러가 발생하지 않는다.
```
여분의 값들을 담을 배열의 이름 뒤에 `...`을 붙여서 함수 선언부에 넣으면 나머지 매개변수가 된다.
```js
function showName(firstName, lastName, ...titles) {
  alert( firstName + ' ' + lastName ); // Bora Lee

  // 나머지 인수들은 배열 titles의 요소가 된다.
  // titles = ['Software Engineer', 'Researcher']
  alert(titles[0]); // Software Engineer
  alert(titles[1]); // Researcher
  alert(titles.length); // 2
}

showName('Bora', 'Lee', 'Software Engineer', 'Researcher');
```
모든 인수를 나머지 매개변수에 모으는 것도 가능하다.
```js
function sumAll(...args) { // args 배열에 모든 인수가 들어간다.
  let sum = 0;

  for (let arg of args) sum += arg;

  return sum;
}

alert(sumAll(1)); // 1
alert(sumAll(1, 2)); // 3
alert(sumAll(1, 2, 3)); // 6
```
---
:warning: **나머지 매개변수는 항상 마지막에 있어야 한다.**

나머지 매개변수가 마지막에 있지 않으면 에러가 발생한다.
```js
function f(arg1, ...rest, arg2) { // ...rest 후에 arg2가 있으면 안 된다.
  // 에러
}
```
---

## arguments 객체
유사 배열 객체(array-like object)인 `arguemnts`를 사용하면 인덱스를 사용해 인수에 접근할 수 있다.
```js
function showName() {
  alert(arguments.length);
  alert(arguments[0]);
  alert(arguments[1]);

  // arguments는 이터러블 객체이기 때문에
  // for(let arg of arguments) alert(arg);를 사용해 인수를 펼칠 수 있다.
}

// 2, Bora, Lee가 출력된다.
showName('Bora', 'Lee');

// 1, Bora, undefined가 출력된다(두 번째 인수는 없다).
showName('Bora');
```
나머지 매개변수는 비교적 최근 나온 문법으로 이전에는 함수의 인수 전체를 얻어내는 방법이 `arguemnts`를 사용하는 것뿐이었다.

`arguments`는 유사 배열 객체이면서 이터러블(반복 가능한) 객체이다. 배열은 아니므로 배열 메서드는 사용할 수 없다는 단점이 존재한다. 또한 `arguments`는 인수 전체를 담기 때문에 나머지 매개변수처럼 인수의 일부만 사용할 수 없다는 단점도 있다.

따라서 배열 메서드를 사용하거나 인수 일부만 사용할 때는 나머지 매개변수를 사용하는 것이 좋다.

---
:information_source: **화살표 함수는 `arguments` 객체를 지원하지 않는다.**

앞서 배웠듯이 화살표 함수는 고유한 `this`를 가지지 않는다.

`this`와 마찬가지로 화살표 함수에서 `arguments` 객체에 접근하면, 외부에 있는 ‘일반’ 함수의 `arguments` 객체를 가져온다.
```js
function f() {
  let showArg = () => alert(arguments[0]);
  showArg();
}

f(1); // 1
```
---

## 스프레드 문법
전개 문법이라고도 불리는 <strong>스프레드 문법(spread syntax)</strong>은 `...`를 사용하기 때문에 나머지 매개변수와 똑같아 보이지만 정반대의 기능을 한다.

함수를 호출할 때 `...arr`를 사용하면, 이터러블 객체 `arr`이 인수 목록으로 '확장’된다.
```js
let arr = [3, 5, 1];

alert(Math.max(...arr)); // 5, 스프레드 문법이 배열을 인수 목록으로 바꿔주었다.
```
이터러블 객체 여러 개를 전달하는 것도 가능하다.
```js
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert(Math.max(...arr1, ...arr2)); // 8
```
스프레드 문법은 배열을 합칠 때 활용할 수 있다.
```js
let arr = [3, 5, 1];
let arr2 = [8, 9, 15];

let merged = [0, ...arr, 2, ...arr2];

alert(merged); // 0,3,5,1,2,8,9,15
```
배열뿐만 아니라 이터러블 객체이면 스프레드 문법을 사용할 수 있다.

문자열은 이터러블이므로 스프레드 문법을 사용할 수 있다.
```js
let str = 'Hello';

alert([...str]); // H,e,l,l,o
```
`Array.from`을 사용해도 동일한 작업을 할 수 있는데 `Array.from(obj)`와 `[...obj]`는 다음과 같은 미묘한 차이가 있다.
-   `Array.from`은 유사 배열 객체와 이터러블 객체 둘 다에 사용할 수 있다.
-   스프레드 문법은 이터러블 객체에만 사용할 수 있다.
따라서 무언가를 배열로 바꿀 때는 스프레드 문법보다 `Array.from`을 많이 사용한다.

## 배열과 객체의 복사본 만들기
이전 챕터에서 객체를 복사할 때 `Object.assign()`을 사용한다고 배웠던 적이 있다.

`Object.assign()` 말고도 스프레드 문법을 사용하면 배열과 객체를 복사할 수 있다.
```js
let arr = [1, 2, 3];
let arrCopy = [...arr]; // 배열을 펼쳐서 각 요소를 분리해 매개변수 목록으로 만든 다음에
                        // 매개변수 목록을 새로운 배열에 할당한다.

// 배열 복사본의 요소가 기존 배열 요소와 같은지 확인한다.
alert(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true

// 두 배열이 같은지 확인한다.
alert(arr === arrCopy); // false, 참조가 다르다.

// 참조가 다르므로 기존 배열을 수정해도 복사본은 영향을 받지 않는다.
arr.push(4);
alert(arr); // 1, 2, 3, 4
alert(arrCopy); // 1, 2, 3
```
```js
let obj = { a: 1, b: 2, c: 3 };
let objCopy = { ...obj }; // 객체를 펼쳐서 각 요소를 분리해 매개변수 목록으로 만든 다음에
                          // 매개변수 목록을 새로운 객체에 할당한다.

// 객체 복사본의 프로퍼티들이 기존 객체의 프로퍼티들과 같은지 확인한다.
alert(JSON.stringify(obj) === JSON.stringify(objCopy)); // true

// 두 객체는 같은지 확인한다.
alert(obj === objCopy); // false, 참조가 다르다.

// 참조가 다르므로 기존 객체를 수정해도 복사본은 영향을 받지 않는다.
obj.d = 4;
alert(JSON.stringify(obj)); // {"a":1,"b":2,"c":3,"d":4}
alert(JSON.stringify(objCopy)); // {"a":1,"b":2,"c":3}
```
이렇게 스프레드 문법을 사용하는 것이 `Object.assign()`을 사용하는 것보다 코드가 간단하므로 우리는 가능하면 스프레드 문법을 사용하도록 한다.

# 3. 변수의 유효범위와 클로저
---
:information_source: **이 챕터에서는 `let`, `const`로 선언한 변수만 다룬다.**

-   이번 주제의 모든 예시에서는  `let`으로 선언한 변수를 사용할 예정이다.
-   `const`로 선언한 변수 역시  `let`  변수와 동일하게 동작한다. 따라서 예시의  `let`을  `const`로 바꿔도 동일한 동작을 기대할 수 있다.
-   `var`는  `let`과  `const`로 선언한 변수와 몇 가지 중요한 차이가 있다. 자세한 내용은 뒤의 챕터에서 다룰 것이다.
---

## 코드 블록
코드 블록 `{...}` 안에서 선언한 변수는 블록 안에서만 사용할 수 있다.
```js
{
  // 지역 변수를 선언하고 몇 가지 조작을 했지만 그 결과를 밖에서 볼 수 없다.

  let message = '안녕하세요.'; // 블록 내에서만 변숫값을 얻을 수 있다.

  alert(message); // 안녕하세요.
}

alert(message); // ReferenceError: message is not defined
```
이런 블록의 특징은 특정 작업을 수행하는 코드를 한데 묶어두는 용도로 활용할 수 있다. 블록 안에는 작업 수행에 필요한 변수만 들어가는 것이다.
```js
{
  // 메시지 출력
  let message = '안녕하세요.';
  alert(message);
}

{
  // 또 다른 메시지 출력
  let message = '안녕히 가세요.';
  alert(message);
}
```
---
:information_source: **블록이 없으면 에러가 발생한다.**

이미 선언된 변수와 동일한 이름을 가진 변수를 별도의 블록 없이 `let`으로 선언하면 에러가 발생한다.
```js
// 메시지 출력
let message = '안녕하세요.';
alert(message);

// 또 다른 메시지 출력
let message = '안녕히 가세요.'; // SyntaxError: Identifier 'message' has already been declared
alert(message);
```
---

`if`, `for`, `while` 등에서도 마찬가지로 `{...}` 안에서 선언한 변수는 오직 블록 안에서만 접근이 가능하다.

참고로 `for`의 소괄호 안에서 선언한 변수(`let i`)는 `{...}` 밖에 있지만 `{...}`에 속한 코드로 취급된다.

## 중첩 함수
함수 내부에서 선언한 함수를 **중첩(nested) 함수**라고 부른다. 자바스크립트에서는 손쉽게 중첩 함수를 만들 수 있다.

중첩 함수는 다음과 같이 코드를 정돈할 때 사용할 수 있다.
```js
function sayHiBye(firstName, lastName) {
  // 헬퍼(helper) 중첩 함수
  function getFullName() {
    return firstName + ' ' + lastName;
  }

  alert('Hello, ' + getFullName());
  alert('Bye, ' + getFullName());
}
```
다음 함수 `makeCounter`는 호출될 때마다 다음 숫자를 반환해주는 ‘카운터’ 함수를 만든다.
```js
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();

alert(counter()); // 0
alert(counter()); // 1
alert(counter()); // 2
```

## 렉시컬 환경
자바스크립트에서는 실행 중인 함수, 코드 블록 `{...}`, 스크립트 전체는 <strong>렉시컬 환경(Lexical Environment)</strong>이라고 불리는 내부 숨김 연관 객체(internal hidden associated object)를 갖는다.

렉시컬 환경 객체는 두 부분으로 구성된다.
1. <strong>환경 레코드(Environment Record)</strong> – 모든 지역 변수를 프로퍼티로 저장하고 있는 객체이다. `this` 값과 같은 기타 정보도 여기에 저장된다.
2. <strong>외부 렉시컬 환경(Outer Lexical Environment)</strong>에 대한 참조 – 외부 코드와 연관된다.

’변수’는 특수 내부 객체인  환경 레코드의 프로퍼티일 뿐이다. '변수를 가져오거나 변경’하는 것은 '환경 레코드의 프로퍼티를 가져오거나 변경’함을 의미한다.

스크립트 전체와 관련된 렉시컬 환경은 전역 렉시컬 환경(global Lexical Environment)이라고 한다.

스크립트가 시작되면 스크립트 내에서 선언한 변수 전체가 렉시컬 환경에 올라간다(pre-populated). 이때 변수의 상태는 특수 내부 상태(special internal state)인 'uninitialized’가 된다. 자바스크립트 엔진은 uninitialized 상태의 변수를 인지하긴 하지만, let을 만나기 전까진 이 변수를 참조할 수 없다. 일시적으로 변수를 사용할 수 없는 구간, 코드 블록 시작부터 let을 만나기 전까지의 구간을 'dead zone'이라고도 부른다.

함수를 호출해 실행하면 새로운 렉시컬 환경이 자동으로 만들어진다. 이 렉시컬 환경에는 함수 호출 시 넘겨받은 매개변수와 함수의 지역 변수가 저장된다.

코드에서 변수에 접근할 때, 먼저 내부 렉시컬 환경을 검색 범위로 잡는다. 내부 렉시컬 환경에서 원하는 변수를 찾지 못하면 검색 범위를 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 확장한다. 이 과정은 검색 범위가 전역 렉시컬 환경으로 확장될 때까지 반복된다.

모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억한다. 함수는 `[[Environment]]`라 불리는 숨김 프로퍼티를 갖는데, 여기에 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장된다. `[[Environment]]`는 함수가 생성될 때 값이 정해지고 영원히 변하지 않는다.

자세한 설명과 예시는 [본문](https://ko.javascript.info/closure#ref-3654)을 참고한다.

---
:information_source: **클로저**

클로저는 **외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수**를 의미한다.

자바스크립트에서는 모든 함수가 자연스럽게 클로저가 된다. 예외가 하나 있는데 이는 [new Function 문법](https://github.com/autroshot/studyroom/blob/main/01-javascript/01-%EC%BD%94%EC%96%B4%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/06-%ED%95%A8%EC%88%98%20%EC%8B%AC%ED%99%94%ED%95%99%EC%8A%B5.md#7-new-function-%EB%AC%B8%EB%B2%95) 챕터에서 다룰 것이다.

자바스크립트의 함수는 숨김 프로퍼티인 `[[Environment]]`를 이용해 자신이 어디서 만들어졌는지를 기억한다. 함수 본문에서는 `[[Environment]]`를 사용해 외부 변수에 접근한다.

---

## 가비지 컬렉션
함수 호출이 끝나면 함수에 대응하는 렉시컬 환경이 메모리에서 제거된다. 함수와 관련된 변수들은 이때 모두 사라진다.

호출이 끝난 후에도 여전히 도달 가능한 중첩 함수가 있을 수 있다. 이때는 이 중첩함수의 `[[Environment]]` 프로퍼티에 외부 함수 렉시컬 환경에 대한 정보가 저장된다. 도달 가능한 상태가 되는 것이다. 함수 호출은 끝났지만 렉시컬 환경이 메모리에 유지되는 이유는 바로 이것 때문이다.
```js
function f() {
  let value = 123;

  return function() {
    alert(value);
  }
}

let g = f(); // g.[[Environment]]에 f() 호출 시 만들어지는 렉시컬 환경 정보가 저장된다.
```
렉시컬 환경 객체는 다른 객체와 마찬가지로 도달할 수 없을 때 메모리에서 삭제된다. 해당 렉시컬 환경 객체를 참조하는 중첩 함수가 하나라도 있으면 사라지지 않는다.
```js
function f() {
  let value = 123;

  return function() {
    alert(value);
  }
}

let g = f(); // g가 살아있는 동안엔 연관 렉시컬 환경도 메모리에 살아있다.

g = null; // 도달할 수 없는 상태가 되었으므로 메모리에서 삭제된다.
```

### 최적화 프로세스
이론상으로는 함수가 살아있는 동안에 모든 외부 변수가 메모리에 유지된다.

그러나 실제로는 자바스크립트 엔진이 이를 지속해서 최적화한다. 자바스크립트 엔진은 변수 사용을 분석하고 외부 변수가 사용되지 않는다고 판단되면 이를 메모리에서 제거한다.

**디버깅 시, 최적화 과정에서 제거된 변수를 사용할 수 없다는 점은 V8 엔진(Chrome, Opera에서 쓰임)의 주요 부작용이다.**

이러한 부작용 때문에 생길 수 있는 상황 중 하나는 다음과 같다.
```js
let value = '이름이 같은 다른 변수';

function f() {
  let value = '가장 가까운 변수';

  function g() {
    debugger; // 콘솔에 alert(value);를 입력하면 '이름이 같은 다른 변수'가 출력된다.
  }

  return g;
}

let g = f();
g();
```

# 4. 오래된 var
---
:information_source: **오래된 스크립트를 읽는 데 도움을 주는 챕터이다.**

이번 주제에서는 작성된 지 오래된 스크립트를 읽는 데 도움을 줄 만한 내용을 다룬다.

새로운 코드를 작성할 때는 이 방법을 쓰면 안 된다.

---
`var`로 선언한 변수는 `let`으로 선언한 변수와 유사하다. 대부분의 경우에는 `let`을 `var`로, `var`를 `let`으로 바꿔도 큰 문제 없이 동작하지만 몇 가지 차이가 존재한다.

## var는 블록 스코프가 없다.
`var`로 선언한 변수의 스코프는 함수 스코프이거나 전역 스코프이다. 블록 기준으로 스코프가 생기지 않기 때문에 블록 밖에서 접근 가능하다.
```js
if (true) {
  var test = true; // 'let' 대신 'var'를 사용했다.
}

alert(test); // true(if 문이 끝났어도 변수에 여전히 접근할 수 있다)
```
코드 블록이 함수 안에 있다면, `var`는 함수 레벨 변수가 된다.
```js
function sayHi() {
  if (true) {
    var phrase = 'Hello';
  }

  alert(phrase); // 제대로 출력된다.
}

sayHi();
alert(phrase); // Error: phrase is not defined
```
`var`는 `if`, `for` 등의 코드 블록을 관통한다. 아주 오래전의 자바스크립트에서는 블록 수준 렉시컬 환경이 만들어지지 않았기 때문이다. `var`는 구식 자바스크립트의 잔재이다.

## var는 재선언을 허용한다.
`let`을 이용해 동일한 스코프에서 재선언을 하면 에러가 발생한다.
```js
let user;
let user; // SyntaxError: 'user' has already been declared
```
`var`는 몇 번이고 재선언이 가능하다.
```js
var user = 'Pete';

var user = 'John'; // 이 'var'는 아무 기능도 하지 않는다.
// 에러가 발생하지 않는다.

alert(user); // John
```

## var는 선언하기 전에 사용이 가능하다.
`var` 선언은 함수가 시작될 때 처리된다. 전역에서 선언한 변수라면 스크립트가 시작될 때 처리된다.

아래 두 예제는 동일하게 동작한다.
```js
function sayHi() {
  phrase = 'Hello';

  alert(phrase);

  var phrase;
}
sayHi();
```
```js
function sayHi() {
  var phrase;

  phrase = 'Hello';

  alert(phrase);
}
sayHi();
```
코드 블록은 무시되기 때문에 아래 코드 역시 동일하게 동작한다.
```js
function sayHi() {
  phrase = 'Hello';

  if (false) { // 이 코드 블록 안은 절대 실행되지 않지만, 이는 호이스팅에 영향을 주지 않는다.
    var phrase;
  }

  alert(phrase);
}
sayHi();
```
이렇게 변수가 끌어올려 지는 현상을 <strong>호이스팅(hoisting)</strong>이라고 부른다. `var`로 선언한 모든 변수는 함수의 최상위로 ‘끌어 올려지기(hoisted)’ 때문이다.

**선언은 호이스팅 되지만 할당은 호이스팅 되지 않는다.**

따라서 아래 두 코드는 동일하게 동작한다.
```js
function sayHi() {
  alert(phrase);  

  var phrase = 'Hello';
}

sayHi(); // undefined
```
```js
function sayHi() {
  var phrase; // 선언은 함수 시작 시 처리된다.

  alert(phrase);

  phrase = 'Hello'; // 할당은 실행 흐름이 해당 코드에 도달했을 때 처리된다.
}

sayHi(); // undefined
```

### 즉시 실행 함수 표현식
`let`, `const`가 없던 과거에는 `var`가 블록 레벨 스코프를 가질 수 있게 여러가지 방안을 고려했다. 이때 만들어진 것이 '즉시 실행 함수 표현식(immediately-invoked function expressions)'이다. 즉시 실행 함수 표현식은 `IIFE`라고 부르기도 한다.
```js
(function() {

  let message = 'Hello';

  alert(message); // Hello

})();
```
함수 표현식이 만들어지고 바로 호출되면서, 해당 함수가 바로 실행되었다. 이 함수는 자신만의 변수를 갖는다.

괄호를 사용하는 방법 말고도 자바스크립트가 함수 표현식이라고 인식하게 해주는 다른 방법들이 있다.
```js
// IIFE를 만드는 방법

(function() {
  alert('함수를 괄호로 둘러싸기');
})();

(function() {
  alert('전체를 괄호로 둘러싸기');
}());

!function() {
  alert('표현식 앞에 비트 NOT 연산자 붙이기');
}();

+function() {
  alert('표현식 앞에 단항 덧셈 연산자 붙이기');
}();
```

# 5. 전역 객체
전역 객체를 사용하면 어디서나 사용 가능한 변수나 함수를 만들 수 있다. 전역 객체는 언어 자체나 호스트 환경에 기본 내장되어 있는 경우가 많다.

전역 객체에는 `Array`와 같은 내장 객체, `window.innerHeight`(뷰포트의 높이를 반환함)같은 브라우저 환경 전용 변수 등이 저장되어 있다.

전역 객체는 `globalThis`라는 보편적인 이름으로 불린다. 하지만 '관습’에 따라 브라우저에서는 `window`, Node.js에서는 `global`이라는 이름으로 불릴 때가 많다. `globalThis`는 제안 목록에 추가 된 지 얼마 안 된 기능이기 때문에, 비 크로미움 기반 브라우저에서는 지원하지 않다(폴리필을 구현하면 사용할 수 있다).

전역 객체의 모든 프로퍼티는 아래와 같이 직접 접근할 수 있다.
```js
alert('Hello');
// 위와 동일하게 동작한다.
window.alert('Hello');
```
브라우저에서 `let`이나 `const`가 아닌 `var`로 선언한 전역 함수나 전역 변수는 전역 객체의 프로퍼티가 된다.
```js
var gVar = 5;

alert(window.gVar); // 5(var로 선언한 변수는 전역 객체 window의 프로퍼티가 된다.)
```
`let`을 사용하면 위 예시와는 달리 전역 객체를 통해 변수에 접근할 수 없다.
```js
let gLet = 5;

alert(window.gLet); // undefined(let으로 선언한 변수는 전역 객체의 프로퍼티가 되지 않는다.)
```
아래와 같이 전역 객체에 직접 프로퍼티를 추가하면 모든 곳에서 사용할 수 있다.
```js
// 모든 스크립트에서 현재 사용자(current user)에 접근할 수 있게 이를 전역 객체에 추가한다.
window.currentUser = {
  name: 'John'
};

// 아래와 같은 방법으로 모든 스크립트에서 currentUser에 접근할 수 있다.
alert(currentUser.name);  // John

// 지역 변수 'currentUser'가 있다면
// 지역 변수와 충돌 없이 전역 객체 window에서 이를 명시적으로 가져올 수 있다.
alert(window.currentUser.name); // John
```
**전역 변수는 되도록 사용하지 않는 것이 좋다.** 함수를 만들 때 외부 변수나 전역 변수를 사용하는 것보다, ‘인풋’ 변수를 받고 이를 이용해 '아웃풋’을 만들어내게 해야 한다. 이 방법이 테스트도 쉽고, 에러도 덜 만들어낸다.

## 폴리필 사용하기
전역 객체를 이용해 현재 사용중인 브라우저가 최신 자바스크립트 기능을 지원하는지 여부를 확인할 수 있다.

예를 들어 내장 객체 `Promise`를 지원하는지 여부를 아래와 같이 확인할 수 있다.
```js
if (!window.Promise) {
  alert('구식 브라우저를 사용 중이시군요!');
}
```
명세에는 있는 기능이지만 해당 기능을 지원하지 않는 오래된 브라우저를 사용하고 있다면 직접 함수를 만들어 전역 객체에 추가하는 방식으로 '폴리필'을 만들 수 있다.
```js
if (!window.Promise) {
  window.Promise = ... // 모던 자바스크립트에서 지원하는 기능을 직접 구현한다.
}
```

# 6. 객체로서의 함수와 기명 함수 표현식
**함수는 객체이다.**

함수는 호출이 가능한(callable) '행동 객체’라고 이해하면 쉽다. 우리는 함수를 호출 할 수 있을 뿐만 아니라 객체처럼 함수에 프로퍼티를 추가·제거하거나 참조를 통해 전달할 수도 있다.

함수 객체에는 몇 가지 쓸만한 프로퍼티가 존재한다.

## 'name' 프로퍼티
`name` 프로퍼티를 사용하면 함수의 이름을 가져올 수 있다.
```js
function sayHi() {
  alert('Hi');
}

alert(sayHi.name); // sayHi
```
익명 함수도 자동으로 이름이 할당된다.
```js
let sayHi = function() {
  alert('Hi');
};

alert(sayHi.name); // sayHi(익명 함수이지만 이름이 있다.)
```
기본값을 사용한 경우도 자동으로 이름이 할당된다.
```js
function f(sayHi = function() {}) {
  alert(sayHi.name); // sayHi
}

f();
```
자바스크립트 명세서에서는 이 기능을 'contextual name’이라고 부른다. 이름이 없는 함수의 이름을 지정할 때 컨텍스트에서 이름을 가져온다.

객체 메서드의 이름도 `name` 프로퍼티를 이용해 가져올 수 있다.
```js
let user = {

  sayHi() {
    // ...
  },

  sayBye: function() {
    // ...
  }

}

alert(user.sayHi.name); // sayHi
alert(user.sayBye.name); // sayBye
```
그런데 객체 메서드 이름은 함수처럼 자동 할당이 되지 않는다. 적절한 이름을 추론하는 것이 불가능한 상황이 있는데, 이때 name 프로퍼티에는 빈 문자열이 저장된다.
```js
// 배열 안에서 함수를 생성한다.
let arr = [function() {}];

alert(arr[0].name); // <빈 문자열>
// 엔진이 이름을 설정할 수 없어서 name 프로퍼티의 값이 빈 문자열이 되었다.
```
위와 같은 상황은 특수한 경우로 실무에서는 만나기 힘들다.

## 'length' 프로퍼티
내장 프로퍼티 `length`는 함수 매개변수의 개수를 반환한다.
```js
function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}

alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length); // 2
```
위 예시에서 나머지 매개변수는 개수에 포함되지 않는다는 사실 또한 확인할 수 있다.

한편, `length` 프로퍼티는 다른 함수 안에서 동작하는 함수의 타입을 검사(type introspection) 할 때도 종종 사용된다.
```js
function ask(question, ...handlers) {
  let isYes = confirm(question);

  for(let handler of handlers) {
    if (handler.length == 0) {
      if (isYes) handler();
    } else {
      handler(isYes);
    }
  }

}

// 사용자가 OK를 클릭한 경우, 핸들러 두 개를 모두 호출한다.
// 사용자가 Cancel을 클릭한 경우, 두 번째 핸들러만 호출한다.
ask('질문 있으신가요?', () => alert('OK를 선택하셨습니다.'), result => alert(result));
```
인수의 종류에 따라(위 예시에서는 인수의 `length` 프로퍼티 값에 따라) 인수를 다르게 처리하는 방식을 프로그래밍 언어에서 <strong>다형성(polymorphism)</strong>이라고 부른다. 자바스크립트 라이브러리에서 다형성이 종종 사용되는 것을 확인할 수 있다.

## 커스텀 프로퍼티
함수에 자체적으로 만든 프로퍼티를 추가할 수도 있다.
```js
function sayHi() {
  alert('Hi');
  
  // 함수를 몇 번 호출했는지 센다.
  sayHi.counter++;
}
sayHi.counter = 0; // 초깃값

sayHi(); // Hi
sayHi(); // Hi

alert(`호출 횟수: ${sayHi.counter}회`); // 호출 횟수: 2회
```
---
:warning: **프로퍼티는 변수가 아니다.**

`sayHi.counter = 0`와 같이 함수에 프로퍼티를 할당해도 함수 내에 지역변수 `counter`가 만들어지지 않는다. `counter` 프로퍼티와 변수 `let counter`는 전혀 관계가 없다.

프로퍼티를 저장하는 것처럼 함수를 객체처럼 다룰 수 있지만, 이는 실행에 아무 영향을 끼치지 않는다. 변수는 함수 프로퍼티가 아니고 함수 프로퍼티는 변수가 아니기 때문이다. 둘 사이에는 공통점이 없다.

---

**클로저는 함수 프로퍼티로 대체할 수 있다.**

[변수의 유효범위와 클로저](https://github.com/autroshot/studyroom/blob/main/01-javascript/01-%EC%BD%94%EC%96%B4%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/06-%ED%95%A8%EC%88%98%20%EC%8B%AC%ED%99%94%ED%95%99%EC%8A%B5.md#3-%EB%B3%80%EC%88%98%EC%9D%98-%EC%9C%A0%ED%9A%A8%EB%B2%94%EC%9C%84%EC%99%80-%ED%81%B4%EB%A1%9C%EC%A0%80) 챕터에서 살펴본 바 있는 counter 함수를 함수 프로퍼티를 사용해 다음과 같이 바꿀 수 있다.
```js
function makeCounter() {
  // let count = 0 대신 아래 메서드(프로퍼티)를 사용한다.
  
  function counter() {
    return counter.count++;
  };

  counter.count = 0;

  return counter;
}

let counter = makeCounter();
alert(counter()); // 0
alert(counter()); // 1
```
클로저를 사용하는 방법과 함수 프로퍼티를 사용하는 방법의 차이는 **외부에서 접근이 가능한가**의 여부이다. 함수 프로퍼티는 외부에서 접근이 가능하다.
```js run
function makeCounter() {
  function counter() {
    return counter.count++;
  };

  counter.count = 0;

  return counter;
}

let counter = makeCounter();

counter.count = 10; // 외부에서 값을 수정할 수 있다.
alert(counter()); // 10
```
따라서 구현 방법은 목적에 따라 선택하면 된다.

## 기명 함수 표현식
<strong>기명 함수 표현식(Named Function Expression, NFE)</strong>은 이름이 있는 함수 표현식이다.

일반적인 함수 표현식은 다음과 같다.
```js
let sayHi = function(who) {
  alert(`Hello, ${who}`);
};
```
여기에 이름을 붙인 것이 기명 함수 표현식이다.
```js
let sayHi = function func(who) {
  alert(`Hello, ${who}`);
};
```
기명 함수 표현식은 다음과 같은 특성을 가진다.
1.  이름을 사용해 함수 표현식 내부에서 자기 자신을 참조할 수 있다.
2.  기명 함수 표현식 외부에서는 그 이름을 사용할 수 없다.

이 기능은 다음과 같이 재귀에서 활용할 수 있다.
```js
let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func('Guest'); // func를 사용해서 자신을 호출한다.
  }
};

sayHi(); // Hello, Guest

// 하지만 아래와 같이 func를 호출하는 건 불가능하다.
func(); // Error, func is not defined(기명 함수 표현식 밖에서는 그 이름에 접근할 수 없다.)
```
대부분의 개발자는 아래와 같이 코드를 작성하곤 한다.
```js
let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    sayHi('Guest');
  }
};
```
하지만 이렇게 코드를 작성하면 외부 코드에 의해 `sayHi`가 변경될 수 있다는 문제가 생긴다.
```js
let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    sayHi('Guest'); // TypeError: sayHi is not a function
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // 에러가 발생한다. 중첩 sayHi 호출은 더 이상 불가능하다.
```
함수가 `sayHi`를 자신의 외부 렉시컬 환경에서 가지고 오기 때문에 에러가 발생한다.

기명 함수 표현식을 이용하면 이 문제를 해결할 수 있다.
```js
let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func('Guest');
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // Hello, Guest(중첩 호출이 제대로 동작한다.)
```
`func`라는 이름은 함수 지역 수준(function-local)에 존재하므로 외부 렉시컬 환경에서 찾지 않아도 된다. 물론 `func`는 외부 렉시컬 환경에서 보이지도 않는다.

---
:information_source: **함수 선언문에서는 내부 이름을 지정할 수 없다.**

함수 선언문에는 ‘내부’ 이름을 지정할 수 있는 문법이 없다.

개발을 하다 보면 믿을만한 내부 이름이 필요할 때가 생기곤 한다. 이 때 바로 함수 선언문을 기명 함수 표현식으로 다시 정의하면 된다.

---

# 7. new Function 문법
함수를 만들 수 있는 방법이 함수 표현식과 함수 선언문 이외에 하나 더 존재한다. 잘 사용하는 방법은 아니지만, 이 방법 외에는 대안이 없을 때 사용한다.

## 문법
```js
let func = new Function([arg1, arg2, ...argN], functionBody);
```
함수는 인수 `arg1...argN`과 함수 본문 `functionBody`로 구성된다.

이 문법을 사용해 다음과 같이 함수를 만들 수 있다.
```js
// 인수가 두 개인 함수이다.
let sum = new Function('a', 'b', 'return a + b');

alert(sum(1, 2)); // 3
```
```js
// 인수가 없는 함수이다.
let sayHi = new Function('alert("Hello")');

sayHi(); // Hello
```
```js
// 인수를 쉼표로 구분해 전달할 수 있다.
let sum = new Function('a,b', 'return a + b');

alert(sum(1, 2)); // 3
```
기존에 사용하던 방법과 `new Function`을 사용해 함수를 만드는 방법의 가장 큰 차이는 런타임에 받은 문자열을 사용해 함수를 만들 수 있다는 것이다.
```js
let str = ...서버에서 동적으로 전달받은 문자열(코드 형태)...

let func = new Function(str);
func();
```
서버에서 코드를 받거나 템플릿을 사용해 함수를 동적으로 컴파일해야 하는 경우, 복잡한 웹 애플리케이션을 구현할 때와 같이 아주 특별한 경우에 `new Function`을 사용할 수 있다.

## 클로저
함수는 특별한 프로퍼티 `[[Environment]]`에 저장된 정보를 이용해 자기 자신이 태어난 곳을 기억한다.

그런데 `new Function`을 이용해 함수를 만들면 함수의 `[[Environment]]` 프로퍼티가 현재 렉시컬 환경이 아닌 전역 렉시컬 환경을 참조하게 된다. 따라서 `new Function`을 이용해 만든 함수는 외부 변수에 접근할 수 없고, 오직 전역 변수에만 접근할 수 있다.
```js
function getFunc() {
  let value = 'test';

  let func = new Function('alert(value)');

  return func;
}

getFunc()(); // ReferenceError: value is not defined
```
`new Function`으로 만든 함수에 무언가를 넘겨주고 싶다면 인수를 사용한다.

# 8. setTimeout과 setInterval을 이용한 호출 스케줄링
일정 시간이 지난 후에 원하는 함수를 예약 실행(호출)할 수 있게 하는 것을 <strong>호출 스케줄링(scheduling a call)</strong>이라고 한다.

호출 스케줄링을 구현하는 방법은 두 가지가 있다.
-   `setTimeout`을 이용해 일정 시간이 지난 후에 함수를 실행하는 방법
-   `setInterval`을 이용해 일정 시간 간격을 두고 함수를 실행하는 방법

자바스크립트 명세서에는 `setTimeout`과 `setInterval`가 명시되어 있지 않다. 하지만 모든 브라우저, Node.js를 포함한 자바스크립트 호스트 환경 대부분이 이와 유사한 메서드와 내부 스케줄러를 지원한다.

## setTimeout
```js
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
```
### func|code
실행하고자 하는 코드로 함수 또는 문자열이 들어간다. 문자열은 하위 호환성을 위한 것이고 보통은 함수를 넣는다.

### delay
실행 전 대기 시간이다. 단위는 밀리초(millisecond)이며 기본값은 0이다.

### arg1, arg2…
함수에 전달할 인수들이다. IE9 이하에서는 지원하지 않는다.

사용법은 다음 예시들을 참고한다.
```js run
function sayHi() {
  alert('안녕하세요.');
}

setTimeout(sayHi, 1000);
```
```js
function sayHi(who, phrase) {
  alert(who + ' 님, ' + phrase);
}

setTimeout(sayHi, 1000, '홍길동', '안녕하세요.'); // 홍길동 님, 안녕하세요.
```
첫 번째 인수에 문자열 대신 다음과 같이 익명 화살표 함수를 사용하는 것을 추천한다.
```js
setTimeout(() => alert('안녕하세요.'), 1000);
```
---
:information_source: **함수를 실행하지 말고 넘겨야 한다.**

`setTimeout`에 함수를 넘길 때, 함수 뒤에 `()` 을 붙이는 실수를 자주 한다.
```js
// 잘못된 코드
setTimeout(sayHi(), 1000);
```
`setTimeout`은 함수의 참조 값을 받도록 정의되어 있는데 `sayHi()`를 인수로 전달하면 '함수 실행 결과'가 전달되어 버린다.

---

### clearTimeout으로 스케줄링 취소하기
`setTimeout`을 호출하면 <strong>타이머 식별자(timer identifier)</strong>가 반환된다. 스케줄링을 취소하고 싶을 때는 이 식별자를 사용하면 된다.
```js
let timerId = setTimeout(...);
clearTimeout(timerId);
```
```js run no-beautify
let timerId = setTimeout(() => alert('아무 일도 일어나지 않습니다.'), 1000);
alert(timerId); // 타이머 식별자

clearTimeout(timerId);
alert(timerId); // 위 타이머 식별자와 동일함(취소 후에도 식별자의 값은 null이 되지 않는다.)
```
브라우저 환경에서는 식별자가 숫자이다. 다른 호스트 환경에서는 타이머 식별자가 숫자형 이외의 자료형일 수 있다. 참고로 Node.js에서 `setTimeout`을 실행하면 타이머 객체가 반환된다.

## setInterval
```js
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)
```
사용법은 `setTimeout`과 동일하다.

`setTimeout`이 함수를 단 한 번만 실행하는 것과 달리 `setInterval`은 함수를 주기적으로 실행한다.

함수 호출을 중단하려면 `clearInterval(timerId)`을 사용하면 된다.
```js
// 2초 간격으로 메시지를 보여준다.
let timerId = setInterval(() => alert('째깍'), 2000);

// 5초 후에 정지한다.
setTimeout(() => { clearInterval(timerId); alert('정지'); }, 5000);
```
위 예시를 실행하면 메시지가 2초 간격으로 보이다가 5초 이후에는 더 이상 메시지가 보이지 않는다.

---
:information_source: **`alert` 창이 떠 있더라도 타이머는 멈추지 않는다.**

대부분의 브라우저는 `alert/confirm/prompt` 창이 떠 있는 동안에도 내부 타이머가 멈추지 않는다.

---

## 중첩 setTimeout
무언가를 일정 간격을 두고 실행할 때 `setInterval` 대신 중첩 `setTimeout`을 이용할 수 있다.
```js
/** setInterval을 이용하지 않고 아래와 같이 중첩 setTimeout을 사용한다.
let timerId = setInterval(() => alert('째깍'), 2000);
*/

let timerId = setTimeout(function tick() {
  alert('째깍');
  timerId = setTimeout(tick, 2000);
}, 2000);
```
중첩 `setTimeout`을 이용하는 방법은 `setInterval`을 사용하는 방법보다 유연하다. 호출 결과에 따라 다음 호출을 원하는 방식으로 조정해 스케줄링 할 수 있기 때문이다.

5초 간격으로 서버에 요청을 보내 데이터를 얻는다고 가정해 본다. 서버가 과부하 상태라면 요청 간격을 10초, 20초, 40초 등으로 증가시켜주는 게 좋을 것이다.

아래는 이를 구현한 의사 코드이다.
```js
let delay = 5000;

let timerId = setTimeout(function request() {
  ...요청 보내기...

  if (서버 과부하로 인한 요청 실패) {
    // 요청 간격을 늘립니다.
    delay *= 2;
  }

  timerId = setTimeout(request, delay);

}, delay);
```
`setInterval`과 중첩 `setTimeout`은 다음과 같은 차이가 존재한다. 

**중첩  `setTimeout`을 이용하는 방법은 지연 간격을 보장하지만  `setInterval`은 이를 보장하지 않는다.**

중첩  `setTimeout`은 함수 실행이 끝나고 타이머가 흐르기 때문에 지연 간격이 보장된다.

![settimeout-interval](https://user-images.githubusercontent.com/95019875/166169631-fab25e58-f5c9-4925-a3a1-c870101f7656.svg)

반면 `setInterval`의 타이머는 함수 실행과 동시에 흐르기 때문에 지연 간격이 보장되지 않는다. 함수 실행 시간이 `delay`보다 길어지는 경우도 존재한다.

![setinterval-interval](https://user-images.githubusercontent.com/95019875/166169671-50f9a30f-c06d-446f-9a59-7a4b91237270.svg)

다음과 같은 상황에서 브라우저 내 타이머가 느려지면 지연 간격이 보장되지 않는다.
-   CPU가 과부하 상태인 경우
-   브라우저 탭이 백그라운드 모드인 경우
-   노트북이 배터리에 의존해서 구동 중인 경우

이런 상황에서 타이머의 최소 지연 시간은 300밀리초에서 심하면 1,000밀리초까지 늘어난다.

---
:information_source: **가비지 컬렉션과 setInterval·setTimeout**

`setInterval`과 `setTimeout`에 넘긴 함수는 가비지 컬렉션의 대상이 되지 않는다.

이런 동작 방식에는 부작용이 하나 존재한다. 외부 렉시컬 환경을 참조하는 함수가 있다면,  이 함수가 메모리에 남아있는 동안에는 외부 변수 역시 메모리에 남아있게 되어서 메모리가 낭비된다. 이런 부작용을 막기 위해 스케줄링할 필요가 없어진 함수는 아무리 작더라도 취소할 필요가 있다.

---

## 대기 시간이 0인 setTimeout
`setTimeout(func, 0)`이나 `setTimeout(func)`을 사용하면 `setTimeout`의 대기 시간을 0으로 설정할 수 있다.

이렇게 대기 시간을 0으로 설정하면 `func`을 ‘가능한 한’ 빨리 실행할 수 있다. 다만, 이때 스케줄러는 현재 실행 중인 스크립트의 처리가 종료된 이후에 스케줄링한 함수를 실행한다.

예시를 실행하면 얼럿창에 'Hello’와 'World’가 순서대로 출력되는 것을 확인할 수 있다.
```js
setTimeout(() => alert('World'));

alert('Hello');
```
예시에서 첫 번째 줄은 '0밀리초 후에 함수 호출하기’라는 할 일을 '계획표에 기록’해주는 역할을 한다. 스케줄러는 현재 스크립트의 실행이 종료되고 나서야 '계획표에 어떤 할 일이 적혀있는지 확인’하므로, `Hello`가 먼저 출력되고 `World`가 그 이후에 출력된다.

대기 시간이 0인 `setTimeout`을 활용한 브라우저 환경에서의 유스 케이스는 '이벤트 루프와 매크로태스크, 마이크로태스크' 챕터에서 자세히 다룰 것이다.

---
:information_source: **브라우저 환경에서 실제 대기 시간은 0이 아니다.**

HTML5 표준에는 "다섯 번째 중첩 타이머 이후에는 대기 시간을 최소 4밀리초 이상으로 강제해야 한다."라는 제약이 명시되어있다.

이런 제약은 `setTimeout`뿐만 아니라 `setInterval`에도 적용된다. `setInterval(f)`도 처음 몇 번은 함수 `f`를 지연 없이 실행하지만, 나중엔 지연 간격을 4밀리초 이상으로 늘려버린다.

이는 오래전부터 있던 제약인데, 구식 스크립트 중 일부는 아직 이 제약에 의존하는 경우가 있어서 명세서를 변경하지 못하고 있는 상황이다.

한편, 서버 측에는 이런 제약이 없다. Node.js의 [process.nextTick](https://nodejs.org/api/process.html)과 [setImmediate](https://nodejs.org/api/timers.html)를 이용하면 비동기 작업을 지연 없이 실행할 수 있다. 위에서 언급된 제약은 브라우저에 한정된다.

---

# 9. call/apply와 데코레이터, 포워딩
## 코드 변경 없이 캐싱 기능 추가하기
연산이 오래 걸리지만 결과는 안정적인 함수  `slow(x)`가 있다고 가정해 본다. 결과가 안정적이라는 것은 인풋이 같으면 아웃풋도 같다는 것을 의미한다.

`slow(x)`가 자주 호출된다면, 결과를 어딘가에 저장(캐싱)해 재연산에 걸리는 시간을 줄이고 싶을 것이다.

`slow` 함수 내부에 캐싱 관련 코드를 추가하는 대신, 다음과 같이 래퍼 함수를 만들어 캐싱 기능을 추가할 수 있다.
```js
function slow(x) {
  // CPU 집약적인 작업이 여기에 올 수 있다.
  alert(`slow(${x})을/를 호출함`);
  return x;
}

function cachingDecorator(func) {
  let cache = new Map();

  return function(x) {
    if (cache.has(x)) {    // cache에 해당 키가 있으면
      return cache.get(x); // 대응하는 값을 cache에서 읽어온다.
    }

    let result = func(x);  // 그렇지 않은 경우에는 func를 호출하고,

    cache.set(x, result);  // 그 결과를 캐싱(저장)한다.
    return result;
  };
}

slow = cachingDecorator(slow);

alert(slow(1)); // slow(1)이 저장되었다.
alert('다시 호출: ' + slow(1)); // 동일한 결과

alert(slow(2)); // slow(2)가 저장되었다.
alert('다시 호출: ' + slow(2)); // 윗줄과 동일한 결과
```
`cachingDecorator` 같이 인수로 받은 함수의 행동을 변경시켜주는 함수를 <strong>데코레이터(decorator)</strong>라고 부른다.

래퍼 함수 `cachingDecorator`를 사용할 때의 이점은 다음과 같다.
-   `cachingDecorator`를 재사용 할 수 있다. 원하는 함수 어디에든  `cachingDecorator`를 적용할 수 있다.
-   캐싱 로직이 분리되어  `slow`  자체의 복잡성이 증가하지 않는다.
-   필요하다면 여러 개의 데코레이터를 조합해서 사용할 수도 있다(추가 데코레이터는  `cachingDecorator`  뒤를 따른다).

## 'func.call’를 사용해 컨텍스트 지정하기
위에서 구현한 캐싱 데코레이터는 객체 메서드에 사용하기에는 적합하지 않다.
```js run
// worker.slow에 캐싱 기능을 추가해본다.
let worker = {
  someMethod() {
    return 1;
  },

  slow(x) {
    // CPU 집약적인 작업이라 가정
    alert(`slow(${x})을/를 호출함`);
    return x * this.someMethod(); // this가 undefined이기 때문에 접근에 실패한다.
  }
};

// 이전과 동일한 코드이다.
function cachingDecorator(func) {
  let cache = new Map();
  return function(x) {
    if (cache.has(x)) {
      return cache.get(x);
    }

    let result = func(x);

    cache.set(x, result);
    return result;
  };
}

alert(worker.slow(1)); // 기존 메서드는 잘 동작한다.

worker.slow = cachingDecorator(worker.slow); // 캐싱 데코레이터 적용

alert(worker.slow(2)); // 에러가 발생한다, Error: Cannot read property 'someMethod' of undefined
```
문제를 해결하기 위해 [func.call(context, …args)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/call)을 이용한다.
```js
func.call(context, arg1, arg2, ...)
```
첫 번째 인수가 `this`, 이어지는 인수가 `func`의 인수가 되고 `func` 함수가 호출된다.

다음은 다른 컨텍스트(다른 객체) 하에 함수를 호출하는 예시이다.
```js
function sayHi() {
  alert(this.name);
}

let user = { name: 'John' };
let admin = { name: 'Admin' };

// call을 사용해 원하는 객체가 'this'가 되도록 한다.
sayHi.call(user); // this = John
sayHi.call(admin); // this = Admin
```
`func.call`를 이용하면 객체 메서드에 데코레이터를 적용해도 오류가 발생하지 않는다.
```js
let worker = {
  someMethod() {
    return 1;
  },

  slow(x) {
    alert(`slow(${x})을/를 호출함`);
    return x * this.someMethod();
  }
};

function cachingDecorator(func) {
  let cache = new Map();
  return function(x) {
    if (cache.has(x)) {
      return cache.get(x);
    }

    let result = func.call(this, x); // 이제 'this'가 제대로 전달된다.

    cache.set(x, result);
    return result;
  };
}

worker.slow = cachingDecorator(worker.slow); // 캐싱 데코레이터 적용

alert(worker.slow(2)); // 제대로 동작한다.
alert(worker.slow(2)); // 제대로 동작한다. 다만, 원본 함수가 호출되지 않고 캐시 된 값이 출력된다.
```
`this`가 전달되는 자세한 과정은 다음과 같다.
1.  데코레이터를 적용한 후에  `worker.slow`는 래퍼  `function (x) { ... }`가 된다.
2.  `worker.slow(2)`를 실행하면 래퍼는  `2`를 인수로 받고,  `this=worker`가 된다(점 앞의 객체).
3.  결과가 캐시되지 않은 상황이라면  `func.call(this, x)`에서 현재  `this`(`=worker`)와 인수(`=2`)를 원본 메서드에 전달한다.

## 여러 인수 전달하기
지금의 데코레이터는 인수가 하나인 함수에만 적용할 수 있다. 인수가 여러 개인 함수에는 적용할 수 없다는 문제가 있다.

이 문제를 해결하는 방법은 여러 가지가 있다.
1.  복수 키를 지원하는 맵과 유사한 자료 구조를 구현한다(서드 파티 라이브러리 등을 사용해도 됨).
2.  중첩 맵을 사용한다.  `(max, result)` 쌍 저장은 `cache.set(min)`으로, `result`는  `cache.get(min).get(max)`을 사용해 얻는다.
3.  두 값을 하나로 합친다. 맵의 키로 문자열  `'min,max'`를 사용한다. 여러 값을 하나로 합치는 코드는 <strong>해싱 함수(hashing function)</strong>에 구현해 유연성을 높인다.

우리는 세 번째 방법을 사용할 것이다.

여기에 더하여 `func.call(this, x)`를 `func.call(this, ...arguments)`로 교체해, 래퍼 함수로 감싼 함수가 호출될 때 복수 인수를 넘길 수 있게 한다.

더 강력해진 `cachingDecorator`는 다음과 같다.
```js
let worker = {
  slow(min, max) {
    alert(`slow(${min},${max})을/를 호출함`);
    return min + max;
  }
};

function cachingDecorator(func, hash) {
  let cache = new Map();
  return function() {
    let key = hash(arguments);

    if (cache.has(key)) {
      return cache.get(key);
    }

    let result = func.call(this, ...arguments);

    cache.set(key, result);
    return result;
  };
}

function hash(args) {
  return args[0] + ',' + args[1];
}

worker.slow = cachingDecorator(worker.slow, hash);

alert(worker.slow(3, 5)); // 제대로 동작한다.
alert('다시 호출: ' + worker.slow(3, 5)); // 동일한 결과 출력된다(캐시된 결과).
```

## func.apply
`func.call` 대신 `func.apply`를 사용할 수 있다.
```js
func.apply(context, args)
```
`apply`는 `func`의 `this`를 `context`로 고정해주고, 유사 배열 객체인 `args`를 인수로 사용할 수 있게 해준다.

`call`과 `apply`의 문법적 차이는 `call`이 복수 인수를 따로따로 받는 대신 `apply`는 인수를 유사 배열 객체로 받는다는 점뿐이다.

다음 코드 두 줄은 거의 같은 역할을 한다.
```js
func.call(context, ...args); // 전개 문법을 사용해 인수가 담긴 배열을 전달하는 것과
func.apply(context, args);   // call을 사용하는 것은 동일하다.
```
받아들이는 인수에 약간의 차이가 있다.
-   전개 문법  `...`은 **이터러블** `args`을 분해 해  `call`에 전달할 수 있도록 해준다.
-   `apply`는 오직 **유사 배열** 형태의  `args`만 받는다.

인수가 이터러블 형태라면 `call`을, 유사 배열 형태라면 `apply`를 사용하면 된다.

배열 같이 이터러블이면서 유사 배열인 객체에는 둘 다 사용할 수 있는데, 대부분의 자바스크립트 엔진은 내부에서 `apply`를 최적화 하기 때문에 `apply`를 사용하는 것이 좀 더 빠르다.

이렇게 컨텍스트와 함께 인수 전체를 다른 함수에 전달하는 것을 <strong>콜 포워딩(call forwarding)</strong>이라고 한다.

가장 간단한 형태의 콜 포워딩은 다음과 같다.
```js
let wrapper = function() {
  return func.apply(this, arguments);
};
```

## 메서드 빌리기
이제 위에서 구현한 해싱 함수를 개선해보겠다.
```js
function hash(args) {
  return args[0] + ',' + args[1];
}
```
`args`에 배열 메서드 `join`을 사용하면 에러가 발생한다. `args`가 유사 배열 객체이기 때문이다.

다음과 같은 방법을 사용하면 `join`을 사용할 수 있다.
```js run
function hash() {
  alert([].join.call(arguments)); // 1,2
}

hash(1, 2);
```
이 방법은 **메서드 빌리기**라고 부른다.

일반 배열에서 `join` 메서드를 빌려오고(`[].join`), `[].join.call`를 사용해 `arguments`를 컨텍스트로 고정한 후 `join`메서드를 호출하는 것이다.

## 데코레이터와 함수 프로퍼티
함수 또는 메서드를 데코레이터로 감싸 대체하는 것은 대체적으로 안전하다. 그런데 원본 함수에 `func.calledCount` 등의 커스텀 프로퍼티가 있으면 데코레이터를 적용한 함수에서는 프로퍼티를 사용할 수 없으므로 안전하지 않다. 함수에 프로퍼티가 있는 경우에는 데코레이터 사용에 주의해야 한다.

몇몇 데코레이터는 자신만의 프로퍼티를 갖기도 한다. 데코레이터는 함수가 얼마나 많이 호출되었는지 세거나 호출 시 얼마나 많은 시간이 소모되었는지 등의 정보를 래퍼의 프로퍼티에 저장할 수 있다.

함수 프로퍼티에 접근할 수 있게 해주는 데코레이터를 만드는 방법도 있다. 그런데 이걸 구현하려면 `Proxy`라는 특별한 객체를 사용해 함수를 감싸야 한다. `Proxy`에 대해서는 'Proxy와 Reflect' 챕터에서 다룰 것이다.

# 10. 함수 바인딩
## 사라진 ‘this’
객체 메서드가 객체 내부가 아닌 다른 곳에 전달되어 호출되면 `this`가 사라진다.
```js
let user = {
  firstName: 'John',
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};

setTimeout(user.sayHi, 1000); // Hello, undefined!
```
이렇게 된 이유는 `setTimeout`에 객체에서 분리된 함수인 `user.sayHi`가 전달되어 `this`가 `undefined`가 되기 때문이다.

객체 메서드를 실제 메서드가 호출되는 곳으로 전달하는 것은 흔한 일이다. 이렇게 메서드를 전달할 때, 컨텍스트도 제대로 유지하려면 다음과 같은 방법을 사용할 수 있다.

## 방법 1: 래퍼
가장 간단한 해결책은 래퍼 함수를 사용하는 것이다.
```js
let user = {
  firstName: 'John',
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};

setTimeout(() => user.sayHi(), 1000);
```
위 예시가 의도한 대로 동작하는 이유는 외부 렉시컬 환경에서 `user`를 받아서 보통 때처럼 메서드를 호출했기 때문이다.

이렇게 코드를 작성하면 간결해져서 보기는 좋지만, 약간의 취약성이 생긴다. `setTimeout`이 트리거 되기 전에(1초가 지나기 전에) `user`가 변경되면, 변경된 객체의 메서드를 호출하게 된다.
```js
let user = {
  firstName: 'John',
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};

setTimeout(() => user.sayHi(), 1000);

// 1초가 지나기 전에 user의 값이 바뀐다.
user = { sayHi() { alert('또 다른 사용자!'); } };

// setTimeout에 또 다른 사용자!
```
두 번째 방법을 사용하면 이런 문제가 발생하지 않는다.

## 방법 2: bind
모든 함수는 `this`를 수정하게 해주는 내장 메서드 [bind](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)를 제공한다.
```js
// 더 복잡한 문법은 뒤에 나온다.
let boundFunc = func.bind(context);
```
`func.bind(context)`는 함수처럼 호출 가능한 '특수 객체(exotic object)'를 반환한다. 이 객체를 호출하면 `this`가 `context`로 고정된 함수 `func`가 반환된다.
```js
let user = {
  firstName: 'John'
};

function func() {
  alert(this.firstName);
}

let funcUser = func.bind(user);
funcUser(); // John  
```
인수는 '그대로' 전달된다.
```js
let user = {
  firstName: 'John'
};

function func(phrase) {
  alert(phrase + ', ' + this.firstName);
}

// this를 user로 바인딩한다.
let funcUser = func.bind(user);

funcUser('Hello'); // Hello, John (인수 'Hello'가 넘겨지고 this는 user로 고정된다.)
```
이제 객체 메서드에 `bind`를 적용하면 다음과 같다.
```js
let user = {
  firstName: 'John',
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};

let sayHi = user.sayHi.bind(user); // (*)

// 이제 객체 없이도 객체 메서드를 호출할 수 있다.
sayHi(); // Hello, John!

setTimeout(sayHi, 1000); // Hello, John!

// 1초 이내에 user 값이 변화해도
// sayHi는 기존 값을 사용한다.
user = {
  sayHi() { alert('또 다른 사용자!'); }
};
```
---
:information_source: **bindAll로 메서드 전체 바인딩하기**

객체에 복수의 메서드가 있고 이 메서드 전체를 전달하려 할 때는 반복문을 사용해 메서드를 바인딩할 수 있다.
```js
for (let key in user) {
  if (typeof user[key] == 'function') {
    user[key] = user[key].bind(user);
  }
}
```
자바스크립트 라이브러리를 사용해도 대규모 바인딩을 할 수 있습니다. lodash 라이브러리의 [_.bindAll(object, methodNames)](http://lodash.com/docs#bindAll)이 그 예이다.

---

## 부분 적용
`this`뿐만 아니라 인수도 바인딩이 가능하다. 인수 바인딩은 잘 쓰이지 않지만 가끔 유용할 때가 있다.

`bind`의 전체 문법은 다음과 같다.
```js
let bound = func.bind(context, [arg1], [arg2], ...);
```
`bind`는 컨텍스트를 `this`로 고정하는 것뿐만 아니라 함수의 인수도 고정해준다.

이 기능을 다음과 같이 활용할 수 있다.
```js
function mul(a, b) {
  return a * b;
}

let double = mul.bind(null, 2); // 컨텍스트가 'null', 첫 번째 인수가 '2'로 고정된 함수가 전달된다.

alert(double(3)); // = mul(2, 3) = 6
alert(double(4)); // = mul(2, 4) = 8
alert(double(5)); // = mul(2, 5) = 10
```
같은 방식으로 `triple` 함수도 만들 수 있을 것이다.

이런 방식을 <strong>부분 적용(partial application)</strong>이라고 부른다. 부분 적용을 사용하면 기존 함수의 매개변수를 고정하여 새로운 함수를 만들 수 있다.

기존 함수의 인수 일부를 고정한 함수를 부분 적용(partially applied) 함수 또는 부분(partial) 함수라고 부른다.

부분 적용을 이용하면 가독성이 좋은 이름(`double`, `triple`)을 가진 독립 함수를 만들 수 있다는 이점이 있다. `bind`를 사용해 일부 인수를 고정할 수 있기 때문에 매번 인수를 전달할 필요가 없어진다.

**부분 적용은 매우 포괄적인 함수를 기반으로 덜 포괄적인 변형 함수를 만들수 있다는 점에서 유용하다.**

함수 `send(from, to, text)`가 있다고 가정해 보자. 객체 `user` 안에서 부분 적용을 활용하면, 전송 주체가 현재 사용자인 함수 `sendTo(to, text)`를 구현할 수 있다.

---
:information_source: **bind 두 번 적용하기**

```js
function f() {
  alert(this.name);
}

f = f.bind({ name: 'John' }).bind({ name: 'Pete' });

f(); // John
```
`bind`가 반환하는 특수 객체인 묶인 함수(bound function)는 함수 생성 시점의 컨텍스트만 기억한다. bind를 사용해 컨텍스트를 다시 정의할 수 없다.

---

## 컨텍스트 없는 부분 적용
네이티브 `bind`만으로는 컨텍스트를 생략하고 인수로 바로 뛰어넘을 수 없다.

인수만 바인딩해주는 헬퍼 함수 `partial`를 다음과 같이 구현할 수 있다.
```js
function partial(func, ...argsBound) {
  return function(...args) { // (*)
    return func.call(this, ...argsBound, ...args);
  }
}

// 사용법:
let user = {
  firstName: 'John',
  say(time, phrase) {
    alert(`[${time}] ${this.firstName}: ${phrase}!`);
  }
};

// 시간을 고정한 부분 메서드를 추가한다.
user.sayNow = partial(user.say, new Date().getHours() + ':' + new Date().getMinutes());

user.sayNow('Hello');
// 출력값 예시:
// [10:00] John: Hello!
```
lodash 라이브러리의 [_.partial](https://lodash.com/docs#partial)을 사용하면 컨텍스트 없는 부분 적용을 직접 구현하지 않아도 된다.

# 11. 화살표 함수 다시 살펴보기
화살표 함수는 단순히 함수를 ‘짧게’ 쓰기 위한 용도로 사용되지 않는다. 화살표 함수는 몇 가지 독특하고 유용한 기능을 제공한다.

자바스크립트를 사용하다 보면 멀리 떨어진 곳에서 실행될 작은 함수를 작성해야 하는 상황을 자주 만나게 된다.

그런데 어딘가에 함수를 전달하게 되면 함수의 컨텍스트를 잃을 수 있다. 이럴 때 **화살표 함수를 사용하면 현재 컨텍스트를 잃지 않아 편리하다.**

## 화살표 함수에는 'this’가 없다.
[메서드와 this](https://github.com/autroshot/studyroom/blob/main/01-javascript/01-%EC%BD%94%EC%96%B4%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/04-%EA%B0%9D%EC%B2%B4:%20%EA%B8%B0%EB%B3%B8.md#04-%EB%A9%94%EC%84%9C%EB%93%9C%EC%99%80-this) 챕터에서 화살표 함수에는 `this`가 없다는 것을 배웠다. 화살표 함수 본문에서 `this`에 접근하면 외부에서 값을 가져온다.

이런 특징은 객체의 메서드 안에서 동일 객체의 프로퍼티를 대상으로 순회를 할 때 사용할 수 있다.
```js
let group = {
  title: '1모둠',
  students: ['보라', '호진', '지민'],

  showList() {
    this.students.forEach(
      student => alert(this.title + ': ' + student)
    );
  }
};

group.showList();
```
화살표 함수를 사용했기 때문에 함수의 `this`는 메서드의 `this`와 동일하게 객체를 가리킨다.

위 예시에서 화살표 함수 대신 ‘일반’ 함수를 사용하면 에러가 발생한다.
```js
let group = {
  title: '1모둠',
  students: ['보라', '호진', '지민'],

  showList() {
    this.students.forEach(function(student) {
      // TypeError: Cannot read property 'title' of undefined
      alert(this.title + ': ' + student)
    });
  }
};

group.showList();
```
---
:warning: **화살표 함수는 new와 함께 실행할 수 없다.**

`this`가 없기 때문에 화살표 함수는 생성자 함수로 사용할 수 없다.

---
:information_source: **화살표 함수 vs. bind**

화살표 함수를 사용하는 것과 일반 함수에 `.bind(this)`를 사용해서 호출하는 것 사이에는 미묘한 차이가 있다.
-   `.bind(this)`는 함수의 '한정된 버전(bound version)'을 만든다.
-   화살표 함수는 어떤 것도 바인딩시키지 않는다. 화살표 함수에는 단지  `this`가 없을 뿐이다. 화살표 함수에서  `this`를 사용하면 일반 변수 서칭과 마찬가지로  `this`의 값을 외부 렉시컬 환경에서 찾는다.
---

## 화살표 함수에는 'arguments’가 없다.
화살표 함수는 일반 함수와는 다르게 모든 인수에 접근할 수 있게 해주는 유사 배열 객체 `arguments`를 지원하지 않는다.

이런 특징은 현재 `this` 값과 `arguments` 정보를 함께 실어 호출을 포워딩해 주는 데코레이터를 만들 때 유용하게 사용된다.

다음 예시에서 데코레이터 `defer(f, ms)`는 함수를 인자로 받고 이 함수를 래퍼로 감싸 반환하는데, 함수 `f`는 `ms`밀리초 후에 호출된다.
```js
function defer(f, ms) {
  return function() {
    setTimeout(() => f.apply(this, arguments), ms)
  };
}

function sayHi(who) {
  alert('안녕, ' + who);
}

let sayHiDeferred = defer(sayHi, 2000);
sayHiDeferred("철수"); // 2초 후 "안녕, 철수"가 출력된다.
```
화살표 함수를 사용하지 않고 동일한 기능을 하는 데코레이터를 만드는 것은 가능하나 코드가 훨씬 복잡해진다.
