# 1. 재귀와 스택
**함수가 자기 자신을 호출하는 것을 재귀라고 부른다.**

함수가 자신을 호출하는 단계를 <strong>재귀 단계(recursion step)</strong>라고 부른다. basis라고도 불리는 재귀의 <strong>베이스(base)</strong>는 작업을 아주 간단하게 만들어서 함수가 더 이상은 서브 호출을 만들지 않게 해주는 인수이다.

재귀적으로 정의된 자료 구조는 자기 자신을 이용해 자료 구조를 정의한다. 재귀적 구조의 대표적인 예는 <strong>연결 리스트(linked list)</strong>이다.

모든 재귀 함수는 반복문을 사용한 함수로 다시 작성할 수 있다. 최적화를 위해 반복문으로 다시 작성해야 할 수도 있다. 그러나 상당수 작업은 재귀를 사용해도 만족할 만큼 빠르게 동작한다. 재귀를 사용하면 구현과 유지보수가 쉽다는 장점도 있다.

자세한 설명과 예시는 [원본](https://ko.javascript.info/recursion)을 확인한다.

# 2. 나머지 매개변수와 스프레드 문법
상당수의 자바스크립트 내장 함수는 인수의 개수에 제약을 두지 않는다.

## 나머지 매개변수 ...
함수 정의 방법과 상관없이 함수에 넘겨주는 인수의 개수에는 제약이 없다.
```js
function sum(a, b) {
  return a + b;
}

alert(sum(1, 2, 3, 4, 5)); // 에러가 발생하지 않는다.
```
나머지 매개변수를 사용하려면 여분의 값들을 담을 배열의 이름 뒤에 `...`을 붙여서 함수 선언부에 넣는다.
```js
function showName(firstName, lastName, ...titles) {
  alert( firstName + ' ' + lastName ); // Bora Lee

  // 나머지 인수들은 배열 titles의 요소가 된다.
  // titles = ['Software Engineer', 'Researcher']
  alert(titles[0]); // Software Engineer
  alert(titles[1]); // Researcher
  alert(titles.length); // 2
}

showName('Bora', 'Lee', 'Software Engineer', 'Researcher');
```
모든 인수를 나머지 매개변수에 모으는 것도 가능하다.
```js
function sumAll(...args) { // args 배열에 모든 인수가 들어간다.
  let sum = 0;

  for (let arg of args) sum += arg;

  return sum;
}

alert(sumAll(1)); // 1
alert(sumAll(1, 2)); // 3
alert(sumAll(1, 2, 3)); // 6
```
---
:warning: **나머지 매개변수는 항상 마지막에 있어야 한다.**

나머지 매개변수가 마지막에 있지 않으면 에러가 발생한다.
```js
function f(arg1, ...rest, arg2) { // ...rest 후에 arg2가 있으면 안 된다.
  // 에러
}
```
---

## arguments 객체
유사 배열 객체(array-like object)인 `arguemnts`를 사용하면 인덱스를 사용해 인수에 접근할 수 있다.
```js
function showName() {
  alert(arguments.length);
  alert(arguments[0]);
  alert(arguments[1]);

  // arguments는 이터러블 객체이기 때문에
  // for(let arg of arguments) alert(arg);를 사용해 인수를 펼칠 수 있다.
}

// 2, Bora, Lee가 출력된다.
showName('Bora', 'Lee');

// 1, Bora, undefined가 출력된다(두 번째 인수는 없다).
showName('Bora');
```
나머지 매개변수는 비교적 최근 나온 문법으로 이전에는 함수의 인수 전체를 얻어내는 방법이 `arguemnts`를 사용하는 것뿐이었다.

`arguments`는 유사 배열 객체이면서 이터러블(반복 가능한) 객체이다. 배열은 아니므로 배열 메서드는 사용할 수 없다는 단점이 존재한다. 또한 `arguments`는 인수 전체를 담기 때문에 나머지 매개변수처럼 인수의 일부만 사용할 수 없다는 단점도 있다.

따라서 배열 메서드를 사용하거나 인수 일부만 사용할 때는 나머지 매개변수를 사용하는 것이 좋다.

---
:information_source: **화살표 함수는 `arguments` 객체를 지원하지 않는다.**

앞서 배웠듯이 화살표 함수는 고유한 `this`를 가지지 않는다.

`this`와 마찬가지로 화살표 함수에서 `arguments` 객체에 접근하면, 외부에 있는 ‘일반’ 함수의 `arguments` 객체를 가져온다.
```js
function f() {
  let showArg = () => alert(arguments[0]);
  showArg();
}

f(1); // 1
```
---

## 스프레드 문법
전개 문법이라고도 불리는 <strong>스프레드 문법(spread syntax)</strong>은 `...`를 사용하기 때문에 나머지 매개변수와 똑같아 보이지만 정반대의 기능을 한다.

함수를 호출할 때 `...arr`를 사용하면, 이터러블 객체 `arr`이 인수 목록으로 '확장’된다.
```js
let arr = [3, 5, 1];

alert(Math.max(...arr)); // 5, 스프레드 문법이 배열을 인수 목록으로 바꿔주었다.
```
이터러블 객체 여러 개를 전달하는 것도 가능하다.
```js
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert(Math.max(...arr1, ...arr2)); // 8
```
스프레드 문법은 배열을 합칠 때 활용할 수 있다.
```js
let arr = [3, 5, 1];
let arr2 = [8, 9, 15];

let merged = [0, ...arr, 2, ...arr2];

alert(merged); // 0,3,5,1,2,8,9,15
```
배열뿐만 아니라 이터러블 객체이면 스프레드 문법을 사용할 수 있다.

문자열은 이터러블이므로 스프레드 문법을 사용할 수 있다.
```js
let str = 'Hello';

alert([...str]); // H,e,l,l,o
```
`Array.from`을 사용해도 동일한 작업을 할 수 있는데 `Array.from(obj)`와 `[...obj]`는 다음과 같은 미묘한 차이가 있다.
-   `Array.from`은 유사 배열 객체와 이터러블 객체 둘 다에 사용할 수 있다.
-   스프레드 문법은 이터러블 객체에만 사용할 수 있다.
따라서 무언가를 배열로 바꿀 때는 스프레드 문법보다 `Array.from`을 많이 사용한다.

## 배열과 객체의 복사본 만들기
이전 챕터에서 객체를 복사할 때 `Object.assign()`을 사용한다고 배웠던 적이 있다.

`Object.assign()` 말고도 스프레드 문법을 사용하면 배열과 객체를 복사할 수 있다.
```js
let arr = [1, 2, 3];
let arrCopy = [...arr]; // 배열을 펼쳐서 각 요소를 분리해 매개변수 목록으로 만든 다음에
                        // 매개변수 목록을 새로운 배열에 할당한다.

// 배열 복사본의 요소가 기존 배열 요소와 같은지 확인한다.
alert(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true

// 두 배열이 같은지 확인한다.
alert(arr === arrCopy); // false, 참조가 다르다.

// 참조가 다르므로 기존 배열을 수정해도 복사본은 영향을 받지 않는다.
arr.push(4);
alert(arr); // 1, 2, 3, 4
alert(arrCopy); // 1, 2, 3
```
```js
let obj = { a: 1, b: 2, c: 3 };
let objCopy = { ...obj }; // 객체를 펼쳐서 각 요소를 분리해 매개변수 목록으로 만든 다음에
                          // 매개변수 목록을 새로운 객체에 할당한다.

// 객체 복사본의 프로퍼티들이 기존 객체의 프로퍼티들과 같은지 확인한다.
alert(JSON.stringify(obj) === JSON.stringify(objCopy)); // true

// 두 객체는 같은지 확인한다.
alert(obj === objCopy); // false, 참조가 다르다.

// 참조가 다르므로 기존 객체를 수정해도 복사본은 영향을 받지 않는다.
obj.d = 4;
alert(JSON.stringify(obj)); // {"a":1,"b":2,"c":3,"d":4}
alert(JSON.stringify(objCopy)); // {"a":1,"b":2,"c":3}
```
이렇게 스프레드 문법을 사용하는 것이 `Object.assign()`을 사용하는 것보다 코드가 간단하므로 우리는 가능하면 스프레드 문법을 사용하도록 한다.

# 3. 변수의 유효범위와 클로저
---
:information_source: **이 챕터에서는 `let`, `const`로 선언한 변수만 다룬다.**

-   이번 주제의 모든 예시에서는  `let`으로 선언한 변수를 사용할 예정이다.
-   `const`로 선언한 변수 역시  `let`  변수와 동일하게 동작한다. 따라서 예시의  `let`을  `const`로 바꿔도 동일한 동작을 기대할 수 있다.
-   `var`는  `let`과  `const`로 선언한 변수와 몇 가지 중요한 차이가 있다. 자세한 내용은 뒤의 챕터에서 다룰 것이다.
---

## 코드 블록
코드 블록 `{...}` 안에서 선언한 변수는 블록 안에서만 사용할 수 있다.
```js
{
  // 지역 변수를 선언하고 몇 가지 조작을 했지만 그 결과를 밖에서 볼 수 없다.

  let message = '안녕하세요.'; // 블록 내에서만 변숫값을 얻을 수 있다.

  alert(message); // 안녕하세요.
}

alert(message); // ReferenceError: message is not defined
```
이런 블록의 특징은 특정 작업을 수행하는 코드를 한데 묶어두는 용도로 활용할 수 있다. 블록 안에는 작업 수행에 필요한 변수만 들어가는 것이다.
```js
{
  // 메시지 출력
  let message = '안녕하세요.';
  alert(message);
}

{
  // 또 다른 메시지 출력
  let message = '안녕히 가세요.';
  alert(message);
}
```
---
:information_source: **블록이 없으면 에러가 발생한다.**

이미 선언된 변수와 동일한 이름을 가진 변수를 별도의 블록 없이 `let`으로 선언하면 에러가 발생한다.
```js
// 메시지 출력
let message = '안녕하세요.';
alert(message);

// 또 다른 메시지 출력
let message = '안녕히 가세요.'; // SyntaxError: Identifier 'message' has already been declared
alert(message);
```
---

`if`, `for`, `while` 등에서도 마찬가지로 `{...}` 안에서 선언한 변수는 오직 블록 안에서만 접근이 가능하다.

참고로 `for`의 소괄호 안에서 선언한 변수(`let i`)는 `{...}` 밖에 있지만 `{...}`에 속한 코드로 취급된다.

## 중첩 함수
함수 내부에서 선언한 함수를 **중첩(nested) 함수**라고 부른다. 자바스크립트에서는 손쉽게 중첩 함수를 만들 수 있다.

중첩 함수는 다음과 같이 코드를 정돈할 때 사용할 수 있다.
```js
function sayHiBye(firstName, lastName) {
  // 헬퍼(helper) 중첩 함수
  function getFullName() {
    return firstName + ' ' + lastName;
  }

  alert('Hello, ' + getFullName());
  alert('Bye, ' + getFullName());

}
```
다음 함수 `makeCounter`는 호출될 때마다 다음 숫자를 반환해주는 ‘카운터’ 함수를 만든다.
```js
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();

alert(counter()); // 0
alert(counter()); // 1
alert(counter()); // 2
```

## 렉시컬 환경
자바스크립트에서는 실행 중인 함수, 코드 블록 `{...}`, 스크립트 전체는 <strong>렉시컬 환경(Lexical Environment)</strong>이라고 불리는 내부 숨김 연관 객체(internal hidden associated object)를 갖는다.

렉시컬 환경 객체는 두 부분으로 구성된다.
1. <strong>환경 레코드(Environment Record)</strong> – 모든 지역 변수를 프로퍼티로 저장하고 있는 객체이다. `this` 값과 같은 기타 정보도 여기에 저장된다.
2. <strong>외부 렉시컬 환경(Outer Lexical Environment)</strong>에 대한 참조 – 외부 코드와 연관된다.

’변수’는 특수 내부 객체인  환경 레코드의 프로퍼티일 뿐이다. '변수를 가져오거나 변경’하는 것은 '환경 레코드의 프로퍼티를 가져오거나 변경’함을 의미한다.

스크립트 전체와 관련된 렉시컬 환경은 전역 렉시컬 환경(global Lexical Environment)이라고 한다.

함수를 호출해 실행하면 새로운 렉시컬 환경이 자동으로 만들어진다. 이 렉시컬 환경에는 함수 호출 시 넘겨받은 매개변수와 함수의 지역 변수가 저장된다.

코드에서 변수에 접근할 때, 먼저 내부 렉시컬 환경을 검색 범위로 잡는다. 내부 렉시컬 환경에서 원하는 변수를 찾지 못하면 검색 범위를 내부 렉시컬 환경이 참조하는 외부 렉시컬 환경으로 확장한다. 이 과정은 검색 범위가 전역 렉시컬 환경으로 확장될 때까지 반복된다.

모든 함수는 함수가 생성된 곳의 렉시컬 환경을 기억한다. 함수는 `[[Environment]]`라 불리는 숨김 프로퍼티를 갖는데, 여기에 함수가 만들어진 곳의 렉시컬 환경에 대한 참조가 저장된다. `[[Environment]]`는 함수가 생성될 때 값이 정해지고 영원히 변하지 않는다.

자세한 설명과 예시는 [본문](https://ko.javascript.info/closure#ref-3654)을 참고한다.

---
:information_source: **클로저**

클로저는 **외부 변수를 기억하고 이 외부 변수에 접근할 수 있는 함수**를 의미한다.

자바스크립트에서는 모든 함수가 자연스럽게 클로저가 된다. 예외가 하나 있는데 이는 new Function 문법 챕터에서 다룰 것이다.

자바스크립트의 함수는 숨김 프로퍼티인 `[[Environment]]`를 이용해 자신이 어디서 만들어졌는지를 기억한다. 함수 본문에서는 `[[Environment]]`를 사용해 외부 변수에 접근한다.

---

## 가비지 컬렉션
함수 호출이 끝나면 함수에 대응하는 렉시컬 환경이 메모리에서 제거된다. 함수와 관련된 변수들은 이때 모두 사라진다.

호출이 끝난 후에도 여전히 도달 가능한 중첩 함수가 있을 수 있다. 이때는 이 중첩함수의 `[[Environment]]` 프로퍼티에 외부 함수 렉시컬 환경에 대한 정보가 저장된다. 도달 가능한 상태가 되는 것이다. 함수 호출은 끝났지만 렉시컬 환경이 메모리에 유지되는 이유는 바로 이것 때문이다.
```js
function f() {
  let value = 123;

  return function() {
    alert(value);
  }
}

let g = f(); // g.[[Environment]]에 f() 호출 시 만들어지는 렉시컬 환경 정보가 저장된다.
```
렉시컬 환경 객체는 다른 객체와 마찬가지로 도달할 수 없을 때 메모리에서 삭제된다. 해당 렉시컬 환경 객체를 참조하는 중첩 함수가 하나라도 있으면 사라지지 않는다.
```js
function f() {
  let value = 123;

  return function() {
    alert(value);
  }
}

let g = f(); // g가 살아있는 동안엔 연관 렉시컬 환경도 메모리에 살아있다.

g = null; // 도달할 수 없는 상태가 되었으므로 메모리에서 삭제된다.
```

## 최적화 프로세스
이론상으로는 함수가 살아있는 동안에 모든 외부 변수가 메모리에 유지된다.

그러나 실제로는 자바스크립트 엔진이 이를 지속해서 최적화한다. 자바스크립트 엔진은 변수 사용을 분석하고 외부 변수가 사용되지 않는다고 판단되면 이를 메모리에서 제거한다.

**디버깅 시, 최적화 과정에서 제거된 변수를 사용할 수 없다는 점은 V8 엔진(Chrome, Opera에서 쓰임)의 주요 부작용이다.**

이러한 부작용 때문에 생길 수 있는 상황 중 하나는 다음과 같다.
```js
let value = '이름이 같은 다른 변수';

function f() {
  let value = '가장 가까운 변수';

  function g() {
    debugger; // 콘솔에 alert(value);를 입력하면 '이름이 같은 다른 변수'가 출력된다.
  }

  return g;
}

let g = f();
g();
```

