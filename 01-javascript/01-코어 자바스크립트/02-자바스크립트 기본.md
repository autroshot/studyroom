# [02] 자바스크립트 기본
## 01. Hello, world!
- \<script\>의 속성(attribute)
  - type: 모듈에 사용된다.
  - language: 현재는 사용되지 않는다.
  - **src: 외부 스크립트의 경로를 나타낸다.**
- 외부 스크립트를 사용할 경우, 여러 페이지에서 동일한 스크립트를 사용했을 때 성능 상의 이점이 있다.
- src 속성이 있으면 태그 내부의 코드는 무시된다.
<br><br/>
## 02. 코드 구조
### 문(statement)
어떤 작업을 수행하는 <strong>문법 구조(syntax structure)</strong>와 **명령어(command)**
- 문은 세미콜론(;)으로 구분된다.
- 세미콜론을 생략해도 '세미콜론 자동 삽입'이 되지만 넣는 것이 규칙이다.

### 주석
주석은 다음과 같이 두 가지가 있다.
```javascript
// 한 줄 주석
/*
여러 줄 주석
*/
```
<br><br/>
## 03. 엄격 모드
엄격 모드는 `'use strict'`로 활성화한다. 이후의 스크립트는 **“모던한”** 방식으로 작동한다.
```javascript
<script>
  'use strict';
  ...
</script>
```
- 엄격 모드는 취소가 불가능하다.
- 코드에 클래스와 모듈이 있다면 엄격 모드가 자동으로 적용된다.
- ***엄격 모드를 사용하면 개발자의 삶의 질이 좋아진다.***
<br><br/>
## 04. 변수와 상수
### 변수
데이터를 저장할 때 쓰이는 **이름이 붙은 저장소**이다.
```javascript
let message = 'Hello!';
alert(message);
```
- 가독성을 위해 한 줄에 하나의 변수를 작성하는 것을 권장한다.
- 같은 변수명으로 여러 번 선언하면 에러가 발생한다.
- 변수명은 문자, 숫자, $, \_만 가능하다. 숫자는 변수명의 첫 글자로 올 수 없다.
- 여러 단어가 조합된 변수명을 만들 때는 카멜 표기법을 사용한다.
- 카멜 표기법: 첫 단어를 제외한 각 단어의 첫 글자를 대문자로 작성한다.
```javascript
let myVeryLongName = 'HongGilDong';
```
- 예약어 목록에 있는 단어는 변수명으로 사용할 수 없다.
  - let, class, return, function, ...
- [예약어 목록](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#keywords)

### 상수
변화하지 않는 변수이다. 재할당이 불가능하다.
```javascript
const myBirthDay = '2022.01.01';
```
- 대문자 상수명은 하드 코딩한(데이터를 직접 입력하는 것) 값의 별칭을 만들 때 사용한다. 일반 상수명은 런타임 과정에서 계산되지만, 최초 할당 이후에는 값이 변하지 않을 때 사용한다.
```javascript
const COLOR_RED = '#F00';
const pageLoadTime = /* 웹페이지를 로드하는데 걸린 시간 */;
```
### 변수명 규칙
- 변수명은 간결하고 명확해야 한다. 최대한 서술적이여야 한다. 자신만의 규칙이나 팀의 규칙을 따라야 한다.
- 새로운 변수 선언을 두려워하지 말자. 기존 변수 재사용보다는 새로운 변수 선언을 권장한다.
<br><br/>
## 05. 자료형
Number, BigInt, String, Boolean, Null, Undefined, 객체, Symbol
- 자바스크립트는 동적 타입 언어이다.
- 동적 타입(dynamically typed) 언어: 변수에 저장되는 값의 타입은 언제든지 바꿀 수 있는 언어이다.

### 숫자형
정수, 부동소수점 숫자, `Infinity`, `-Infinity`, `NaN`
```javascript
alert('문자형' / 2); // NaN
```
- 자바스크립트는 말이 안 되는 수학 연산을 하더라도 치명적인 에러를 내뿜으며 죽지 않는다. `NaN`을 반환하며 연산이 종료될 뿐이다.

### BigInt
숫자형의 범위를 넘어서는 (2^53-1)(9007199254740991) 보다 큰 값 혹은 -(2^53-1) 보다 작은 정수를 다룰 때 필요하다.
암호 관련 작업같이 아주 큰 숫자가 필요한 상황이거나 아주 높은 정밀도로 작업을 해야 할 때 사용된다.

### 문자형
자바스크립트에선 문자열(string)을 따옴표로 묶는다.
- `"Hello"`, `'Hello'`, <code>&#96;Hello&#96;</code>(역 따옴표, backtick)
- 역 따옴표 안에 ${…}을 사용하면 원하는 변수나 표현식을 문자열 중간에 쉽게 넣을 수 있다.
```javascript
alert(`Hello, ${name}!`);
alert(`the result is ${1 + 2}`);
```

### 불린형
`true`와 `false` 두 가지 값밖에 없는 자료형이다.

### null
‘존재하지 않는(**nothing**)’ 값, ‘비어 있는(**empty**)’ 값, ‘알 수 없는(**unknown**)’ 값을 나타내는 데 사용한다.

### undefined
값이 할당되지 않은 상태이다. 변수는 선언했지만 값을 할당하지 않았다면 `undefined`가 자동으로 할당된다.
```javascript
let age;
alert(age); // 'undefined'가 출력된다.
```

### 객체형
복잡한 데이터 구조를 표현할 때 사용한다. 객체형을 제외한 다른 자료형은 원시(primitive) 자료형으로 분류된다. 객체는 특별한 취급을 받는다.

### 심볼형
객체의 고유 식별자를 만들 때 사용한다.

### typeof 연산자
인수의 자료형을 나타내는 문자열을 반환한다.
```javascript
typeof 'foo' // 'string'
typeof Math // 'object'
typeof null // 'object'
typeof alert // 'function'
```
<br><br/>
## 06. alert, prompt, confirm을 이용한 상호작용
### alert
메시지를 보여주는 모달 창을 띄운다.

### prompt
```javascript
result = prompt(title, [default]);
```
입력 필드가 있는 모달 창을 띄운다. 사용자가 확인 버튼을 누르면 함수는 입력 필드의 문자열을, 그 외의 경우는 `null`을 반환한다.
```javascript
let age = prompt('나이를 입력해주세요.', 100);
alert(`당신의 나이는 ${age}살 입니다.`); // 당신의 나이는 100살입니다.
```

### confirm
```javascript
result = confirm(question);
```
사용자가 모달 창의 확인 버튼을 누르면 `true`, 그 외의 경우는 `false`를 반환한다.
<br><br/>
## 07. 형 변환
함수와 연산자에 전달되는 값은 대부분 적절한 자료형으로 자동 변환된다.
### 문자형으로 변환
```javascript
let value = true;
value = String(value);
alert(typeof value); // string
```

### 숫자형으로 변환
```javascript
let str = '123';
let num = Number(str);
alert(typeof num); // number
```
- 숫자형으로의 변환은 수학과 관련된 함수와 표현식에서 자동으로 일어난다.
```javascript
alert( "6" / "2" ); // 3
```
- 숫자형으로 변환할 때의 규칙은 다음과 같다.

|전달받은 값|형 변환 후|
|-|-|
|`undefined`|`NaN`|
|`null`|`0`|
|`true` and `false`|`1`과 `0`|
|`string`|문자열의 처음과 끝 공백이 제거된다. 공백 제거 후 남아있는 문자열이 없다면 `0`, 그렇지 않다면 문자열에서 숫자를 읽는다. 변환에 실패하면 `NaN`이 된다.|

### 불린형으로 변환
```javascript
alert(Boolean(1)); // true
```
- 불린형으로 변환할 때의 규칙은 다음과 같다.

|전달받은 값|형 변환 후|
|-|-|
|`0`, `NaN`, `“”`, `null`, `undefined`|`false`|
|그 이외의 값|`true`|

### 헷갈리기 쉬운 규칙
- `undefined`는 숫자형으로 변환 시 `0`이 아니라 `NaN`이 된다.
- 문자열 `"0"`과 `" "`같은 공백은 불린형으로 변환 시 `true`가 된다.
<br><br/>
## 08. 기본 연산자와 수학
+, -, \*, /, %(나머지 연산자), \**(거듭제곱 연산자, 제곱근도 가능)
- 피연산자(인수): 연산자가 연산을 수행하는 대상이다.
- 피연산자 개수에 따라 **단항 연산자**, **이항 연산자**, **삼항 연산자**로 나뉜다.

### 이항 연산자 '+'의 문자열 연결
이항 연산자 +의 피연산자 중 하나가 문자열이면 두 피연산자를 **문자형**으로 형 변환해서 병합한다. +만이 이러한 기능이 존재하며, 나머지 산술 연산자는 피연산자를 **숫자형**으로 형 변환해서 계산한다.
```javascript
alert(2 + 2 + '1'); // '221'이 아니라 '41'이 출력된다.
```

### 단항 연산자 '+'의 형 변환
단항 연산자 +는 피연산자를 **숫자형**으로 변환해준다. Number(value)와 동일한 일을 하며 코드의 길이를 줄일 수 있다. 숫자에 붙이면 아무 일도 안 일어난다.
```javascript
alert(+true); // 1
alert(+''); // 0
```

### 연산자 우선순위
- 단항 연산자는 이항 연산자보다 우선순위가 더 높다.
- [우선순위 테이블](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table)

### 할당 연산자 '='
- 할당 연산자는 우선순위가 아주 낮다.
- 할당 연산자는 값을 반환한다. 라이브러리에서 이 방법이 사용되곤 한다. 가독성이 떨어지기 때문에 코드 작성 시에는 권장되지 않는다.
```javascript
let a = 1;
let b = 2;

let c = 3 - (a = b + 1); // a에 b의 값을 할당하고 그 값을 반환한다.

alert(a); // 3
alert(c); // 0
```
- 할당 연산자 체이닝이 가능하지만 가독성이 떨어지기 때문에 코드 작성 시에는 권장되지 않는다.
```javascript
a = b = c = 2 + 2; // a, b, c는 모두 4가 된다.
```

### 복합 할당 연산자
+=, -=, *=, /=, ...
- 복합 할당 연산자는 할당 연산자와 우선순위가 동일하다.
```javascript
let n = 2;
n *= 3 + 5; 
alert(n); // 16
```

### 증가/감소 연산자
`++`와 `--`
- 증가/감소 연산자는 변수에만 쓸 수 있다.
- 증가/감소 연산자는 **후위형**(counter++)과 **전위형**(++counter)으로 나뉜다. 후위형은 **기존값**을 반환하는 반면, 전위형은 **변화된 값**을 반환한다.
```javascript
let counter = 0;
alert(++counter); // 1
```
```javascript
let counter = 0;
alert(counter++); // 0
```
- 코드 가독성을 위해 증가/감소 연산자는 별도의 줄에서 사용하는 것을 권장한다.
- ***코드 한 줄에 동작 하나***

### 비트 연산자
- 주로 암호를 다룰 때 사용된다.
- 필요시 공부하자.

### 쉼표 연산자
- 할당 연산자보다도 우선순위가 낮다. 프레임워크에서 사용되는 것을 볼 수 있다. 가독성이 떨어지기 때문에 코드 작성 시에는 권장되지 않는다.
```javascript
// 한 줄에서 세 개의 연산이 수행된다.
for (a = 1, b = 3, c = a*b; a < 10; a++) {
  ...
}
```
<br><br/>
## 09. 비교 연산자
`>`, `<`, `>=`, `<=`, `==`, `!=`
- 비교 연산자는 불린형을 반환한다.
- 문자열을 비교할 때는 **사전 순**으로 비교한다. 사전에서 뒤에 있는 문자열이 더 크다고 판단한다. 정확히는 사전 순이 아닌 **유니코드 순**이다. 소문자 `‘a’`가 대문자 `‘A’`보다 크다.
- 비교하려는 값의 자료형이 다르면 해당 값들은 **숫자형**으로 형 변환된 후 비교된다.
```javascript
let a = 0;
alert(Boolean(a)); // false
   
let b = "0";
alert(Boolean(b)); // true
   
alert(a == b); // true! 비교 연산자는 피연산자들을 숫자형으로 형 변환해서 비교하기 때문에 이러한 모순이 일어난다.
```

### 일치 연산자
일치 연산자(===)와 불일치 연산자(!==)를 사용하면 형 변환 없이 값을 비교할 수 있다. 해당 연산자들을 사용하면 에러가 발생할 확률을 줄일 수 있다.
```javascript
alert(0 == false); // true
alert(0 === false); // false
```

### null/undefined에 적용되는 특수한 규칙
1. 동등 연산자(`==`)는 `null`과 `undefined`를 ‘**각별한 커플**’처럼 취급한다. 둘을 비교하는 경우에만 `true`를 반환하고 이외의 경우에는 `false`를 반환한다.
```javascript
alert(null === undefined); // false
alert(null == undefined); // true
alert(null == 0); // false
```
2. 비교 연산자(`<`, `>`, `<=`, `>=`)에서는 `null`은 `0`, `undefined`는 `NaN`으로 변환된다. `NaN`가 피연산자인 경우에는 항상 `false`를 반환한다.
```javascript
alert(null > 0);  // false
alert(null >= 0); // true
alert(undefined > 0); // false
alert(undefined == 0); // false
```
3. 위와 같이 특수한 경우를 피하기 위해, 일치 연산자(`===`)를 제외한 비교 연산자의 피연산자에 **`null`/`undefined`가 오지 않도록** 특별히 주의한다. 만약 변수가 `null`/`undefined`가 될 가능성이 있다면 이를 **처리하는 로직을 따로 추가**한다.
<br><br/>
## 10. if와 ‘?’를 사용한 조건 처리
### 'if’문
`if(...)`문은 괄호 안에 들어가는 조건을 평가하며 그 결과가 `true`이면 코드 블록이 실행됩니다.
```javascript
if (year == 2015) {
  alert( "정답입니다!" );
  alert( "아주 똑똑하시네요!" );
}
```
- `if`문을 쓸 때는 실행 구문이 단 한 줄이더라도 코드 가독성을 위해 중괄호`{…}`를 쓰는 것을 권장한다.
- `if`문 뒤에는 `else`절이나 `else if`문을 붙일 수 있다.
```javascript
if (year < 2015) {
  alert('숫자를 좀 더 올려보세요.');
} else if (year > 2015) {
  alert('숫자를 좀 더 내려보세요.');
} else {
  alert('정답입니다!');
}
```

### 조건부 연산자 ‘?’
유일한 삼항 연산자로 조건에 따라 변수에 다른 값을 할당해줘야 할 때 사용된다.
```javascript
// 괄호가 없어도 동일한 결과가 나오지만 코드 가독성을 위해 괄호를 사용하는 것을 권장한다.
let accessAllowed = (age > 18) ? true : false;
```
- 다중 `?`는 다중 `else if`문과 동일하다.
```javascript
let message = (age < 3) ? '아기야 안녕?' :
  (age < 18) ? '안녕!' :
  (age < 100) ? '환영합니다!' :
  '나이가 아주 많으시거나, 나이가 아닌 값을 입력하셨군요!';
```
```javascript
if (age < 3) {
  message = '아기야 안녕?';
} else if (age < 18) {
  message = '안녕!';
} else if (age < 100) {
  message = '환영합니다!';
} else {
  message = '나이가 아주 많으시거나, 나이가 아닌 값을 입력하셨군요!';
}
```
- 조건부 연산자를 결과에 따라 실행되는 로직이 달라질 때 사용하는 것은 부적절하다. 다음과 같은 경우에는 `if`를 사용하는 것이 더 적절하다.
```javascript
(company == 'Netscape') ? alert('정답입니다!') : alert('오답입니다!');
```
```javascript
if (company == 'Netscape') {
  alert('정답입니다!');
} else {
  alert('오답입니다!');
}
```
- ***코드를 읽을 때 우리의 눈은 수직으로 움직인다. 수평으로 길게 늘어진 코드보단 여러 줄로 나뉘어 작성된 코드 블록이 더 읽기 쉽다.***
<br><br/>
## 11. 논리 연산자
`||`, `&&`, `!`
### || (OR)
인수 중 하나라도 `true`이면 `true`를 반환하고, 그 외에는 `false`를 반환한다.
```javascript
alert(true || true);   // true
alert(false || true);  // true
alert(true || false);  // true
alert(false || false); // false
```
- OR 연산자 추가 기능
1. 여러 피연산자 중에서 **첫 번째 truthy**를 반환하는데 형 변환 전의 값을 반환한다. **truthy가 없다면 마지막 피연산자**를 반환한다.
```javascript
let firstName = "";
let lastName = "";
let nickName = "바이올렛";

alert(firstName || lastName || nickName || '익명'); // 바이올렛
```
2. 단락 평가(short circuit evaluation): OR 연산자가 truthy를 만나면 나머지 값들은 건드리지 않은 채 평가를 멈춘다. 연산자 왼쪽 조건이 falsy인 경우에만 명령어가 실행되는 것을 원할 때 자주 쓰인다.
```javascript
true || alert('not printed'); not printed는 출력되지 않는다.
false || alert('printed'); printed가 출력된다.
```

### && (AND)
AND 연산자(`&&`)는 OR 연산자와 반대로 작동한다.
```javascript
alert(true && true);   // true
alert(false && true);  // false
alert(true && false);  // false
alert(false && false); // false
```
- AND 연산자 추가 기능: **첫 번째 falsy**를 얻을 때 사용할 수 있다. 연산자 왼쪽 조건이 truthy인 경우에만 명령어가 실행되는 것을 원할 때 쓰이기도 한다.
```javascript
alert( 1 && 2 && null && 3 ); // null
```
- AND 연산자는 OR 연산자보다 우선순위가 높다.
- `if`를 AND 연산자나 OR 연산자로 대체하는 것은 코드 가독성을 떨어뜨린다.

### ! (NOT)
피연산자를 불린형으로 변환하고 그 값의 역을 반환한다.
```javascript
alert(!true); // false
alert(!0); // true
```
- NOT 연산자를 두 번 연달아 사용하면(!!) 값을 불린형으로 변환할 수 있다. Boolean 함수를 사용한 것과 같다.
```
alert(!!null); // false
alert(Boolean(null)); // false
```
- NOT 연산자는 AND 연산자나 OR 연산자보다 우선순위가 높다.
<br><br/>
## 12. nullish 병합 연산자 ‘??’
여러 피연산자 중 **값이 할당된 변수**를 찾는다. 즉, null이나 undefined가 아닌 변수를 찾는다. 변수에 **기본값을 할당하는 용도**로 사용할 수 있다.
```javascript
let firstName = null;
let lastName = null;
let nickName = '바이올렛';
    
alert(firstName ?? lastName ?? nickName ?? '익명의 사용자'); // 바이올렛
```
- `??`, `||`의 차이: 기능은 비슷하나 변수에 `0`이 할당될 수 있으면 `??`가 더 적합하다.
- `??`의 우선순위는 꽤 낮다. 따라서 `??`를 사용할 때는 **괄호를 사용**하는 것이 좋다.
- 괄호 없이 `??`를 `||`나 `&&`와 함께 사용하면 에러가 발생한다.
<br><br/>
## 13. while과 for 반복문
### ‘while’ 반복문
`condition`이 truthy이면 반복문 본문(body)의 코드가 실행된다.
```javascript
while (condition) {
  // 반복문 본문
}
```

### ‘do…while’ 반복문
**본문을 최소 한 번은 실행**하고 싶을 때 사용한다. 이외에는 대부분 `while`문을 사용한다.
```javascript
do {
  // 반복문 본문
} while (condition);
```

### ‘for’ 반복문
```javascript
for (begin; condition; step) {
  // 반복문 본문
}
```
- 작동 방식은 다음과 같다.
```javascript
begin을 실행함
→ (condition이 truthy이면 → body를 실행한 후, step을 실행함)
→ (condition이 truthy이면 → body를 실행한 후, step을 실행함)
→ ...
```
- `for`문의 구성 요소는 필요에 따라 생략이 가능하다.
- `break`를 사용하면 원하는 때에 반복문을 빠져나갈 수 있다.
- `continue`을 사용하면 현재 반복을 멈추고 다음 반복으로 넘어간다. 중첩을 줄이는 데 도움을 준다.
- `break`나 `continue` 같이 표현식이 아닌 문법 구조는 삼항 연산자 `?`에 사용할 수 없다.
```javascript
(i > 5) ? alert(i) : continue; // continue 때문에 에러가 발생한다.
```

### 레이블
반복문에 식별자를 붙일 수 있다.
```javascript
labelName: for (...) {...}
```
- `break <labelName>`을 사용하면 해당하는 반복문을 빠져나올 수 있다. 레이블은 **중첩 반복문을 빠져나오는 유일한 방법**이다. `continue`의 사용법도 동일하다. 
- 레이블은 사용되는 `break/continue` 위에 있어야 한다.
<br><br/>
## switch문
복수의 `if`문은 `switch`문으로 바꿀 수 있다. `switch`문은 하나 이상의 `case`문으로 구성된다. `default`문은 생략 가능하다.
```javascript
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]
  case 'value2':  // if (x === 'value2')
    ...
    [break]
  default:
    ...
    [break]
}
```
- `case`문 안에 `break`문이 없으면 뒤의 `case`문도 실행된다. 이것을 이용해 여러 개의 `case`문을 묶는 것이 가능하다.
- `switch`문은 일치 비교(`===`)로 조건을 확인하기 때문에 자료형을 확인하는 것이 중요하다.
- 다중 `else if`문은 `switch`문으로 바꾸는 것이 가독성이 좋다.
- `case`문이 추가될 것을 대비해 마지막 `case`문에도 `break`문을 작성하는 것이 좋다.
<br><br/>
