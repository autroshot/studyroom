# 01. Hello, world!
\<script\>의 속성(attribute)은 다음과 같다.
- type: 모듈에 사용된다.
- language: 현재는 사용되지 않는다.
- **src: 외부 스크립트의 경로를 나타낸다.**

```html
<script src="/path/to/script.js"></script>
```
외부 스크립트를 사용하면 여러 페이지에서 동일한 스크립트를 사용했을 때 성능 상의 이점이 있다.

---
:warning: **src 속성이 있으면 태그 내부의 코드는 무시된다.**

\<script\> 태그는 src 속성과 내부 코드를 동시에 가질 수 없다.
```html
<script src="file.js">
  alert(1); // src 속성이 사용되었으므로 이 코드는 무시된다.
</script>
```
---
<br></br>
# 02. 코드 구조
## 문
문(statement)은 어떤 작업을 수행하는 <strong>문법 구조(syntax structure)</strong>와 <strong>명령어(command)</strong>를 의미한다. 서로 다른 문은 <strong>세미콜론(;)</strong>으로 구분된다.

세미콜론을 생략해도 '세미콜론 자동 삽입'이 되지만 세미콜론은 반드시 넣는 것이 규칙이다.

## 주석
주석은 한 줄 주석과 여러 줄 주석이 있다.
```js
// 한 줄 주석

/*
여러 줄 주석
여러 줄 주석
여러 줄 주석
*/
```
<br></br>
# 03. 엄격 모드
엄격 모드는 `'use strict'`로 활성화한다. 엄격 모드가 적용되면 스크립트는 '**모던한**' 방식으로 동작한다.
```js
<script>
  'use strict';
  ...
</script>
```
- `'use strict'`는 반드시 스크립트 최상단에 위치해야 한다.
- 엄격 모드는 취소가 불가능하다.
- 코드에 클래스와 모듈이 있다면 엄격 모드가 자동으로 적용된다.
- ***엄격 모드를 사용하면 개발자의 삶의 질이 좋아진다.***
<br></br>
# 04. 변수와 상수
## 변수
변수는 데이터를 저장할 때 쓰이는 **이름이 붙은 저장소**이다. `let` 키워드를 사용해서 변수를 만든다.
```js
let message = 'Hello!';
alert(message);
```
- 가독성을 위해 **한 줄에 하나의 변수를 선언**하는 것을 권장한다.
- 중복되는 변수명으로 변수를 선언하면 에러가 발생한다.
- 변수명은 문자, 숫자, $, \_만 가능하다. 숫자는 변수명의 첫 글자로 올 수 없다.
- 여러 단어가 조합된 변수명을 만들 때는 **카멜 표기법**을 사용한다. 카멜 표기법은 첫 단어를 제외한 각 단어의 첫 글자를 대문자로 작성하는 것이다.
```js
let myVeryLongName = 'HongGilDong';
```

---
:warning: **예약어**

[예약어(reserved name) 목록](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Lexical_grammar#ecmascript_2015_%EA%B8%B0%EC%A4%80_%EC%98%88%EC%95%BD_%ED%82%A4%EC%9B%8C%EB%93%9C)에 있는 단어는 변수명으로 사용할 수 없다.
- let, class, return, function, ...

---

## 상수
상수는 **변화하지 않는 변수**이다. `const`로 상수를 만든다. 상수는 **재할당이 불가능하다.**
```js
const myBirthDay = '2022.01.01';
```

## 대문자 상수
대문자와 밑줄 `_`을 사용하는 대문자 상수명은 하드 코딩한(데이터를 직접 입력한) 값의 상수명에 사용한다. 카멜 표기법을 사용하는 일반적인 상수명은 런타임 과정에서 계산되지만 최초 할당 이후에는 값이 변하지 않을 때 사용한다.
```js
const COLOR_RED = '#F00'; // 대문자 상수명

const pageLoadTime = /* 웹페이지를 로드하는데 걸린 시간 */; // 일반 상수명
```
### 바람직한 변수명
- 변수명은 간결하고 명확해야 한다.
- 최대한 서술적이여야 한다.
- 자신만의 규칙이나 소속된 팀의 규칙을 따라야 한다.

---
:information_source: **변수 재사용보다는 새로운 변수 선언이 훨씬 좋다.**

새로운 변수를 선언하는 것에 거리낌이 없어야 한다. 변수를 재사용하면 변수 선언에 쏟는 노력을 조금 줄일 수 있겠지만, 디버깅에 열 배 더 많은 시간을 쏟아야 할 것이다.

모던 자바스크립트 압축기(minifier)와 브라우저는 코드 최적화를 잘해준다. 변수를 추가한다고 해서 성능 이슈가 생기지 않는다.

---
<br></br>
# 05. 자료형
자바스크립트에는 8가지의 기본 자료형이 있다.
- Number, BigInt, String, Boolean, Null, Undefined, 객체, Symbol

자바스크립트는 동적 타입(dynamically typed) 언어이다. 동적 타입 언어는 변수에 저장되는 값의 타입을 언제든지 바꿀 수 있는 언어이다.

## 숫자형
<strong>숫자형(number type)</strong>에는 정수, 부동소수점 숫자, `Infinity`, `-Infinity`, `NaN`가 포함된다.
```js
alert('문자형' / 2); // NaN
```
자바스크립트는 말이 안 되는 수학 연산을 하더라도 치명적인 에러를 내뿜으며 죽지 않는다. `NaN`을 반환하며 연산이 종료될 뿐이다.

## BigInt
BigInt형은 숫자형의 범위를 넘어서는 값인 <code>(2<sup>53</sup>-1)</code>(9007199254740991) 보다 큰 값 혹은 <code>-(2<sup>53</sup>-1)</code>보다 작은 값을 다룰 때 필요하다.

암호 관련 작업처럼 아주 큰 숫자나 아주 높은 정밀도가 필요한 작업을 할 때 사용된다.

`BigInt`형 값은 정수 리터럴 끝에 `n`을 붙이면 만들 수 있다.
```js
// 끝에 'n'이 붙으면 BigInt형이다.
const bigInt = 1234567890123456789012345678901234567890n;
```

## 문자형
자바스크립트에서는 문자열(string)을 따옴표로 묶는다.
```js
let str = "Hello";
let str2 = 'Single quotes are ok too';
let phrase = `can embed another ${str}`;
```
역 따옴표 안에 ${...}을 사용하면 원하는 변수나 표현식을 문자열 중간에 쉽게 넣을 수 있다.
```js
alert(`Hello, ${name}!`);
alert(`the result is ${1 + 2}`);
```

---
:information_source: **글자형은 없다.**

자바스크립트는 글자형을 지원하지 않는다. 문자형만 있을 뿐이다.

---

## 불린형
불린형(논리 타입)은 `true`/`false` 두 가지 값밖에 없는 자료형이다.

## null
‘존재하지 않는(**nothing**)’ 값, ‘비어 있는(**empty**)’ 값, ‘알 수 없는(**unknown**)’ 값을 나타낼 때 사용한다.

## undefined
**값이 할당되지 않은 상태**이다. 변수는 선언했지만 값을 할당하지 않았다면 `undefined`가 자동으로 할당된다.
```js
let age;

alert(age); // 'undefined'가 출력된다.
```
변수에 `undefined`를 직접 할당하는 것은 권장하지 않는다. 변수가 ‘비어있거나’ ‘알 수 없는’ 상태라는 것을 나타내려면 `null`을 사용해야 한다.

## 객체형
객체(object)형은 복잡한 데이터 구조를 표현할 때 사용한다. 객체형을 제외한 다른 자료형은 원시(primitive) 자료형으로 분류된다. 객체는 특별한 취급을 받는다.

## 심볼형
객체의 고유 식별자(unique identifier)를 만들 때 사용한다.

## typeof 연산자
`typeof` 연산자는 인수의 자료형을 나타내는 문자열을 반환한다.
```js
typeof 'foo' // 'string'
typeof Math // 'object'
typeof null // 'object'
typeof undefined // 'undefined'
typeof alert // 'function'
```
`typeof null`의 결과가 `object`인 것을 주의해야 한다.
<br></br>
# 06. alert, prompt, confirm을 이용한 상호작용
## alert
`alert` 함수는 메시지를 보여주는 모달 창을 띄운다.
```js
alert('Hello');
```

## prompt
`prompt` 함수는 입력 필드가 있는 모달 창을 띄운다. 사용자가 확인 버튼을 누르면 함수는 입력 필드의 문자열을, 그 외의 경우는 `null`을 반환한다.
```js
result = prompt(title, [default]);
```
```js
let age = prompt('나이를 입력해주세요.', 100);

alert(`당신의 나이는 ${age}살 입니다.`); // 당신의 나이는 100살입니다.
```

## confirm
`confirm` 함수는 사용자가 모달 창의 확인 버튼을 누르면 `true`를, 그 외의 경우는 `false`를 반환한다.
```js
result = confirm(question);
```
<br></br>
# 07. 형 변환
함수와 연산자에 전달되는 값은 적절한 자료형으로 자동 변환된다.

## 문자형으로 변환
```js
let value = true;

value = String(value);
alert(typeof value); // string
```

## 숫자형으로 변환
```js
let str = '123';

let num = Number(str);
alert(typeof num); // number
```
숫자형으로의 변환은 수학과 관련된 함수와 표현식에서 자동으로 일어난다.
```js
alert('6' / '2'); // 3
```
숫자형으로 변환할 때의 규칙은 다음과 같다.
|전달받은 값|형 변환 후|
|---|---|
|`undefined`|`NaN`|
|`null`|`0`|
|`true` / `false`|`1` / `0`|
|`string`|문자열의 처음과 끝 공백이 제거된다. 공백 제거 후 남아있는 문자열이 없다면 `0`, 그렇지 않다면 문자열에서 숫자를 읽는다. 변환에 실패하면 `NaN`이 된다.|

## 불린형으로 변환
```js
alert(Boolean(1)); // true
```
불린형으로 변환할 때의 규칙은 다음과 같다.
|전달받은 값|형 변환 후|
|---|---|
|`0`, `NaN`, `''`, `null`, `undefined`|`false`|
|그 이외의 값|`true`|

## 헷갈리기 쉬운 규칙
- `undefined`는 숫자형으로 변환 시 `0`이 아니라 `NaN`이 된다.
- 문자열 `'0'`과 `' '`같은 공백은 불린형으로 변환 시 `true`가 된다.
<br></br>
# 08. 기본 연산자와 수학
자바스크립트의 기본 연산자는 다음과 같다.
- `+`, `-`, `*`, `/`, `%`(나머지 연산자), `**`(거듭제곱 연산자, 제곱근도 가능)

피연산자(operand)는 연산자가 연산을 수행하는 대상이다. 연산자는 피연산자 개수에 따라 **단항 연산자**, **이항 연산자**, **삼항 연산자**로 나뉜다.

## 이항 연산자 '+'의 문자열 연결
이항 연산자 `+`의 피연산자 중 하나가 문자열이면 두 피연산자를 **문자형**으로 형 변환해서 병합한다. `+`에만 이런 기능이 존재하며, 나머지 산술 연산자는 피연산자를 **숫자형**으로 형 변환해서 계산한다.
```js
alert(2 + 2 + '1'); // '221'이 아니라 '41'이 출력된다.
```

## 단항 연산자 '+'의 형 변환
단항 연산자 +는 피연산자를 **숫자형**으로 변환해준다. Number(value)와 동일한 일을 하며 코드의 길이를 줄일 수 있다. 숫자에 붙이면 아무 일도 안 일어난다.
```js
alert(+true); // 1
alert(+''); // 0
```

## 연산자 우선순위
단항 연산자는 이항 연산자보다 우선순위가 더 높다. 자세한 우선순위는 [우선순위 테이블](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#%ED%91%9C)에서 확인할 수 있다.

## 할당 연산자 '='
무언가를 할당할 때 쓰이는 `=`도 연산자로 할당(assignment) 연산자라고 부른다. 할당 연산자는 우선순위가 아주 낮다.

할당 연산자는 값을 반환하는데 라이브러리에서 이것이 활용되곤 한다. 하지만 가독성이 떨어지기 때문에 코드 작성 시에는 사용하지 말아야 한다.
```js
let a = 1;
let b = 2;

let c = 3 - (a = b + 1); // a에 b + 1의 값을 할당하고 그 값인 3을 반환한다.

alert(a); // 3
alert(c); // 0
```

할당 연산자는 체이닝이 가능하지만 가독성이 떨어지기 때문에 코드 작성 시에는 사용하지 말아야 한다.
```js
a = b = c = 2 + 2; // a, b, c는 모두 4가 된다.
```

## 복합 할당 연산자
`+=`, `-=`, `*=`, `/=` 등을 복합 할당 연산자라고 한다. 복합 할당 연산자는 할당 연산자와 우선순위가 동일하다.
```js
let n = 2;

n *= 3 + 5; 

alert(n); // 16
```

## 증가·감소 연산자
- **증가(increment) 연산자** `++`는 변수를 1 증가시킨다.
- **감소(decrement) 연산자** `--`는 변수를 1 감소시킨다.

증가·감소 연산자는 변수에만 사용할 수 있다.

증가·감소 연산자는 **후위형**(counter++)과 **전위형**(++counter)으로 나뉜다. 후위형은 **기존값**을 반환하는 반면, 전위형은 **변화된 값**을 반환한다.
```js
let counter = 0;
alert(++counter); // 1
```
```js
let counter = 0;
alert(counter++); // 0
```

코드 가독성을 위해 증가/감소 연산자는 별도의 줄에서 사용하는 것을 권장한다.

***코드 한 줄에 동작 하나***

## 비트 연산자
주로 암호를 다룰 때 사용된다.

필요 시 공부하자.

## 쉼표 연산자
쉼표 연산자(comma operator) `,`는 좀처럼 보기 힘들고 특이한 연산자이다. 쉼표 연산자는 할당 연산자보다도 우선순위가 낮다.
```js
// 한 줄에서 세 개의 연산이 수행된다.
for (a = 1, b = 3, c = a * b; a < 10; a++) {
  ...
}
```
주로 프레임워크에서 사용되는 것을 볼 수 있다. 가독성이 떨어지기 때문에 코드 작성 시에는 사용하지 않는다.
<br></br>
# 09. 비교 연산자
자바스크립트의 비교 연산자는 다음과 같다.
- `>`, `<`, `>=`, `<=`, `==`, `!=`, `===`, `!==`

## 불린형 반환
비교 연산자는 불린형을 반환한다.
```js
alert(2 > 1);  // true
alert(2 == 1); // false
alert(2 != 1); // true
```

## 문자열 비교
자바스크립트는 문자열을 비교할 때 **사전 순**으로 비교한다. 사전에서 뒤에 있는 문자열이 더 크다고 판단한다.
```js
alert('Z' > 'A'); // true
alert('Glow' > 'Glee'); // true
alert('Bee' > 'Be'); // true
```
정확히는 사전 순이 아닌 **유니코드 순**이다. 소문자 `‘a’`가 대문자 `‘A’`보다 크다고 판단한다.

## 다른 형을 가진 값의 비교
비교하려는 값의 자료형이 다르면 해당 값들은 **숫자형**으로 형 변환된 후 비교된다.
```js
let a = 0;
alert(Boolean(a)); // false
   
let b = '0';
alert(Boolean(b)); // true
   
alert(a == b); // true, 비교 연산자는 피연산자들을 숫자형으로 형 변환해서 비교하기 때문에 이러한 모순이 일어난다.
```

## 일치 연산자
일치 연산자 `===`와 불일치 연산자 `!==`를 사용하면 형 변환 없이 값을 비교할 수 있다. 이 연산자를 사용하면 에러가 발생할 확률을 줄일 수 있으므로, 특별한 경우가 아니면 `==`, `!=` 대신 이 연산자를 사용해야 한다.
```js
alert(0 == false); // true
alert(0 === false); // false
```

## null/undefined에 적용되는 특수한 규칙
1. 동등 연산자(`==`)는 `null`과 `undefined`를 ‘**각별한 커플**’처럼 취급한다. 둘을 비교하는 경우에만 `true`를 반환하고 이외의 경우에는 `false`를 반환한다.
```js
alert(null === undefined); // false
alert(null == undefined); // true
alert(null == 0); // false
```
2. 비교 연산자(`<`, `>`, `<=`, `>=`)에서 `null`은 `0`, `undefined`는 `NaN`으로 변환된다. `NaN`가 피연산자인 경우에는 항상 `false`를 반환한다.
```js
alert(null > 0);  // false
alert(null >= 0); // true
alert(undefined > 0); // false
alert(undefined == 0); // false
```
3. 위와 같이 특수한 경우를 피하기 위해, 일치 연산자(`===`)를 제외한 비교 연산자의 피연산자에 **`null`/`undefined`가 오지 않도록** 특별히 주의한다. 만약 변수가 `null`/`undefined`가 될 가능성이 있다면 이를 **처리하는 로직을 따로 추가**한다.
<br></br>
# 10. if와 ‘?’를 사용한 조건 처리
## 'if’문
`if(...)`문은 괄호 안에 들어가는 조건을 평가하며 그 결과가 `true`이면 코드 블록이 실행된다.
```js
if (year == 2015) {
  alert('정답입니다!');
  alert('아주 똑똑하시네요!');
}
```

`if`문을 쓸 때는 실행 구문이 단 한 줄이더라도 코드 가독성을 위해 중괄호 `{...}`를 쓰는 것을 권장한다.

`if`문 뒤에는 `else`절이나 `else if`문을 붙일 수 있다.
```js
if (year < 2015) {
  alert('숫자를 좀 더 올려보세요.');
} else if (year > 2015) {
  alert('숫자를 좀 더 내려보세요.');
} else {
  alert('정답입니다!');
}
```

## 조건부 연산자 ‘?’
<strong>조건부(conditional) 연산자</strong>는 유일한 삼항 연산자로 **조건에 따라 변수에 다른 값을 할당해줘야 할 때** 사용된다.
```js
// 괄호가 없어도 동일한 결과가 나오지만 코드 가독성을 위해 괄호를 사용하는 것을 권장한다.
let accessAllowed = (age > 18) ? true : false;
```

다중 `?`는 다중 `else if`문으로 바꿀 수 있다.
```js
let message = (age < 3) ? '아기야 안녕?' :
  (age < 18) ? '안녕!' :
  (age < 100) ? '환영합니다!' :
  '나이가 아주 많으시거나, 나이가 아닌 값을 입력하셨군요!';
```
```js
if (age < 3) {
  message = '아기야 안녕?';
} else if (age < 18) {
  message = '안녕!';
} else if (age < 100) {
  message = '환영합니다!';
} else {
  message = '나이가 아주 많으시거나, 나이가 아닌 값을 입력하셨군요!';
}
```

## 부적절한 ‘?’
조건에 따라 실행되는 로직이 달라질 때는 조건부 연산자를 사용하지 말아야 한다. 다음과 같은 경우에는 `if`를 사용하는 것이 더 적절하다.
```js
(company == 'Netscape') ? alert('정답입니다!') : alert('오답입니다!');
```
```js
if (company == 'Netscape') {
  alert('정답입니다!');
} else {
  alert('오답입니다!');
}
```
***코드를 읽을 때 우리의 눈은 수직으로 움직인다. 수평으로 길게 늘어진 코드보단 여러 줄로 나뉘어 작성된 코드 블록이 더 읽기 쉽다.***
<br></br>
# 11. 논리 연산자
자바스크립트의 논리 연산자는 다음 세 가지이다.
- `||`, `&&`, `!`

## || (OR)
인수 중 하나라도 `true`이면 `true`를 반환하고, 그 외에는 `false`를 반환한다.
```js
alert(true || true);   // true
alert(false || true);  // true
alert(true || false);  // true
alert(false || false); // false
```

### OR 연산자의 추가 기능
1. 여러 피연산자 중에서 **첫 번째 truthy**를 반환하는데 형 변환 전의 값을 반환한다. **truthy가 없다면 마지막 피연산자**를 반환한다.
```js
let firstName = '';
let lastName = '';
let nickName = '바이올렛';

alert(firstName || lastName || nickName || '익명'); // 바이올렛
```
2. 단락 평가(short circuit evaluation): OR 연산자가 truthy를 만나면 나머지 값들은 건드리지 않은 채 평가를 멈춘다. 연산자 왼쪽 조건이 falsy인 경우에만 명령어가 실행되는 것을 원할 때 자주 쓰인다.
```js
true || alert('not printed'); not printed는 출력되지 않는다.
false || alert('printed'); printed가 출력된다.
```

## && (AND)
AND 연산자(`&&`)는 OR 연산자와 반대로 작동한다.
```js
alert(true && true);   // true
alert(false && true);  // false
alert(true && false);  // false
alert(false && false); // false
```

### AND 연산자의 추가 기능
AND 연산자는 **첫 번째 falsy**를 얻을 때 사용할 수 있다. 연산자 왼쪽 조건이 truthy인 경우에만 명령어가 실행되는 것을 원할 때 쓰이기도 한다.
```js
alert(1 && 2 && null && 3); // null
```

---
:information_source: **`&&`의 우선순위가 `||`보다 높다.**

`a && b || c && d`는 `(a && b) || (c && d)`와 동일하게 동작한다.

---
:warning: **`if`를 `||`나 `&&`로 대체해서는 안 된다.**

`if`를 AND 연산자나 OR 연산자로 대체하는 것은 코드 가독성을 떨어뜨린다.

---

## ! (NOT)
논리 연산자 NOT은 피연산자를 불린형으로 변환하고 그 값의 역을 반환한다.
```js
alert(!true); // false
alert(!0); // true
```
NOT 연산자를 두 번 연달아 사용하면(!!) 값을 불린형으로 변환할 수 있다. Boolean 함수를 사용한 것과 같다.
```
alert(!!null); // false
alert(Boolean(null)); // false
```
NOT 연산자는 AND 연산자나 OR 연산자보다 우선순위가 높다.
<br></br>
# 12. nullish 병합 연산자 ‘??’
---
:warning: **최근에 추가됨**

스펙에 추가된 지 얼마 안 된 문법이다. 구식 브라우저는 폴리필이 필요하다.

---

<strong>nullish 병합 연산자(nullish coalescing operator)</strong> `??`는 여러 피연산자 중 **값이 할당된 변수**를 찾는다. 즉, `null`이나 `undefined`가 아닌 변수를 찾는다. 변수에 **기본값을 할당하는 용도**로 사용할 수 있다.
```js
let firstName = null;
let lastName = null;
let nickName = '바이올렛';
    
alert(firstName ?? lastName ?? nickName ?? '익명의 사용자'); // 바이올렛
```
- `??`와 `||`의 차이: 기능은 비슷하나 변수에 `0`이 할당될 수 있으면 `??`가 더 적합하다.
- `??`의 우선순위는 꽤 낮다. 따라서 `??`를 사용할 때는 **괄호를 사용**하는 것이 좋다.
- `??`를 괄호 없이 `||`나 `&&`와 함께 사용하면 에러가 발생한다.
```js
let x = 1 && 2 ?? 3; // SyntaxError: Unexpected token '??'
```
<br></br>
# 13. while과 for 반복문
반복문 본문이 한 번 실행되는 것을 <strong>반복(iteration, 이터레이션)</strong>이라고 부른다.

## ‘while’ 반복문
`while` 반복문의 문법은 다음과 같다.
```js
while (condition) {
  // 반복문 본문
}
```
`condition`이 truthy이면 반복문 본문(body)의 코드가 실행된다.

본문이 한 줄이면 대괄호를 생략할 수 있다.
```js
let i = 3;
while (i) alert(i--);
```

## ‘do...while’ 반복문
**본문을 최소 한 번은 실행**하고 싶을 때 사용한다. 대부분의 상황에서는 `while`문을 사용한다.
```js
do {
  // 반복문 본문
} while (condition);
```

## ‘for’ 반복문
```js
for (begin; condition; step) {
  // 반복문 본문
}
```
작동 방식은 다음과 같다.
```js
begin을 실행함
→ (condition이 truthy이면 → body를 실행한 후, step을 실행함)
→ (condition이 truthy이면 → body를 실행한 후, step을 실행함)
→ ...
```
- `for`문의 구성 요소는 필요에 따라 생략이 가능하다.
- `break`를 사용하면 원하는 때에 반복문을 빠져나갈 수 있다.
- `continue`을 사용하면 현재 반복을 멈추고 다음 반복으로 넘어간다. 중첩을 줄이는 데 도움을 준다.
```js
for (let i = 0; i < 10; i++) {
  // 조건이 참이라면 남아있는 본문은 실행되지 않습니다.
  if (i % 2 == 0) continue;

  alert(i); // 1, 3, 5, 7, 9가 차례대로 출력됨
}
```
- `break`나 `continue` 같이 표현식이 아닌 문법 구조는 삼항 연산자 `?`에 사용할 수 없다.
```js
(i > 5) ? alert(i) : continue; // continue 때문에 에러가 발생한다.
```

## break/continue와 레이블
반복문에 식별자를 붙일 수 있다.
```js
labelName: for (...) {...}
```
`break <labelName>`을 사용하면 해당하는 반복문을 빠져나올 수 있다. 레이블은 **중첩 반복문을 빠져나오는 유일한 방법**이다. `continue`의 사용법도 동일하다.
```js
outer: for (let i = 0; i < 3; i++) {
  for (let j = 0; j < 3; j++) {
    let input = prompt(`(${i},${j})의 값`, '');
    
    // 사용자가 아무것도 입력하지 않거나 Cancel 버튼을 누르면 두 반복문 모두를 빠져나온다.
    if (!input) break outer;

    // 입력받은 값을 가지고 무언가를 한다.
  }
}
alert('완료!');
```
레이블은 사용되는 `break/continue` 이전에 있어야 한다.
<br></br>
# 14. switch문
`switch`문은 하나 이상의 `case`문으로 구성되며 `default`문은 생략 가능하다.
```js
switch (x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]
  case 'value2':  // if (x === 'value2')
    ...
    [break]
  default:
    ...
    [break]
}
```
- 다중 `else if`문은 `switch`문으로 바꾸는 것이 가독성이 좋다.
- `case`문 안에 `break`문이 없으면 뒤의 `case`문도 실행된다. 이것을 이용해 여러 개의 `case`문을 묶는 것이 가능하다.
- `switch`문은 일치 비교(`===`)로 조건을 확인하기 때문에 자료형을 확인하는 것이 중요하다.
- `case`문이 추가될 것을 대비해 마지막 `case`문에도 `break`문을 작성하는 것이 좋다.
<br></br>
# 15. 함수
함수는 프로그램을 구성하는 주요 '구성 요소(building block)'이다. 함수를 이용하면 중복 없이 유사한 동작을 하는 코드를 여러 번 호출할 수 있다.
## 함수 선언
다음과 같이 함수를 만드는 방식을 <strong>함수 선언(function declaration)</strong>, 혹은 **함수 선언문** 방식이라고 부른다.
```js
function name(parameters) {
  ...함수 본문...
}
```

## 지역 변수와 전역 변수
- 지역 변수(local variable): 함수 내에서 선언한 변수로 함수 안에서만 접근할 수 있다.
- 전역 변수(global variable): 외부 변수라고도 불리며 함수 외부에서 선언된 변수이다.

함수 내부에 외부 변수와 동일한 이름을 가진 변수가 선언되었다면, 내부 변수는 외부 변수를 가린다.
```js
let userName = 'John';

function showMessage() {
  let userName = 'Bob'; // 같은 이름을 가진 지역 변수를 선언한다.

  let message = 'Hello, ' + userName; // Bob
  alert(message);
}

// 함수는 내부 변수인 userName만 사용합니다,
showMessage();

// 함수는 외부 변수에 접근하지 않는다. 따라서 값이 변경되지 않고 John이 출력된다.
alert(userName); 
```
***전역 변수 대신 지역 변수와 매개 변수를 활용하는 것이 좋다.***

## 매개 변수
<strong>매개변수(parameter)</strong>를 이용하면 임의의 데이터를 함수 안에 전달할 수 있다. 매개변수는 <strong>인수(argument)</strong>라고도 불린다.

함수는 매개변수에 전달된 값을 **복사**해서 사용한다. 원본은 변하지 않는다.
```js
function showMessage(from, text) {
  from = '*' + from + '*';
  
  alert( from + ': ' + text );
}

let from = "Ann";

showMessage(from, "Hello"); // *Ann*: Hello

// 함수는 복사된 값을 사용하기 때문에 바깥의 "from"은 값이 변경되지 않는다.
alert(from); // Ann
```

## 기본값
매개변수에 값을 전달하지 않으면 그 값은 `undefined`가 된다. `undefined`가 되지 않게 하려면 기본값(default value)을 설정해주면 된다.
```js
function showMessage(from, text = "no text given") {
  alert( from + ": " + text );
}

showMessage("Ann"); // Ann: no text given
```
기본값에 표현식도 넣을 수 있다.
```js
function showMessage(from, text = anotherFunction()) {
  // anotherFunction()은 text값이 없을 때만 호출된다.
  // anotherFunction()의 반환 값이 text의 값이 된다.
}
```
기본값을 함수 내부에서 설정하는 것도 가능하다.
```js
// 매개변수 'count'가 넘어오지 않으면 'unknown'을 출력해주는 함수이다.
function showCount(count) {
  alert(count ?? 'unknown');
}

showCount(0); // 0
showCount(null); // unknown
showCount(); // unknown
```

## 반환 값
함수를 호출했을 때 함수는 특정 값을 반환할 수 있으며 그 값을 <strong>반환 값(return value)</strong>이라고 부른다.
```js
function sum(a, b) {
  return a + b;
}

let result = sum(1, 2);
alert(result); // 3
```
- 지시자 `return`은 함수 내 어디서든 사용할 수 있다. 실행 흐름이 지시자 `return`을 만나면 함수는 즉시 중단되고 값을 반환한다.
- 함수 하나에 여러 개의 `return`문이 올 수도 있으며 값 없이 `return`만 명시하는 것도 가능하다.
- `return`문이 없거나 `return` 지시자만 있는 함수는 `undefined`를 반환한다.
- `return`과 값 사이에 절대 줄을 넣어서는 안 된다. 표현식을 여러 줄에 걸쳐 작성하고 싶다면 아래와 같이 작성할 수 있다.
```js
return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
```

## 함수 이름짓기
- 함수 이름은 함수가 어떤 동작을 하는지 설명할 수 있어야 한다. 함수 호출 코드만 보아도 해당 함수가 어떤 일을 하고 어떤 값을 반환하는지 바로 알 수 있어야 한다.
- 함수는 어떤 동작을 수행하기 위한 코드를 모아놓은 것이기 때문에 함수 이름은 대개 동사이다.
- 함수 이름은 가능한 간결하고 명확해야 한다.
- 아래와 같은 **접두어**를 사용할 수 있다.
  - "show...": 무언가를 보여줌
  - "get...": 값을 반환함
  - "calc...": 무언가를 계산함
  - "create...": 무언가를 생성함
  - "check...": 무언가를 확인하고 불린값을 반환함
- ***함수는 한 가지 동작만을 담당해야 한다.*** 함수는 이름에 언급되어 있는 동작 하나만을 정확히 수행해야 하며 그 이외의 동작은 수행해선 안 된다.
- 팀에서 합의한 규칙을 따라야 한다.

## 함수 == 주석
- 함수가 길어지면 함수를 잘게 나눌 때가 되었다는 신호이다.
- 함수를 간결하게 만들면 테스트와 디버깅이 쉬워진다. 그리고 **함수 그 자체로 주석의 역할**까지 한다.
- 이름만 보고도 어떤 동작을 하는지 알 수 있는 코드를 <strong>자기 설명적(self-describing) 코드</strong>라고 부른다.
<br></br>
# 16. 함수 표현식
자바스크립트는 함수를 **특별한 종류의 값**으로 취급한다. 다른 언어에서처럼 '특별한 동작을 하는 구조'로 취급되지 않는다.

따라서 '함수 선언문' 대신 <strong>함수 표현식(Function Expression)</strong>을 사용해서 함수를 만들 수 있다.
```js
// 함수를 만들고 그 함수를 변수 sayHi에 할당하기
let sayHi = function() {
  alert('Hello');
}; // 값의 역할을 하기 때문에 끝에 세미 콜론을 붙여야 한다.
```
함수는 값이기 때문에 `alert`를 이용하여 함수 코드를 출력할 수 있다.
```js
alert(sayHi); // 함수 코드가 출력된다.
```
함수는 값이기 때문에 변수를 복사해 다른 변수에 할당할 수 있다.
```js
let func = sayHi; // sayHi()를 넣으면 함수가 아닌 함수의 반환 값이 할당된다.

func(); // Hello     // 복사된 함수가 정상적으로 실행된다.
sayHi(); // Hello    // 원래 함수도 정상적으로 실행된다.
```
## 콜백 함수
함수를 함수의 인수로 전달하고, 필요하다면 인수로 전달한 함수를 '**나중에 호출(called back)**'하는 것이다. 매개변수로 **동작을 전해준다**고 할 수 있다.
```js
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert("동의하셨습니다.");
}

function showCancel() {
  alert("취소 버튼을 누르셨습니다.");
}

// 함수 showOk와 showCancel가 ask 함수의 인수로 전달된다.
// 사용자가 확인 버튼을 누르면 showOk 함수가 콜백되고, 그 외의 경우는 showCancel 함수가 콜백된다.
ask("동의하십니까?", showOk, showCancel);
```
***문자열이나 숫자와 같은 일반적인 값들은 데이터를 나타내고, 함수는 동작을 나타낸다.***

## 익명 함수
이름 없이 선언한 함수를 익명 함수(anonymous function)라고 부른다. 적절한 곳에서 익명 함수를 사용하면 코드의 길이를 줄일 수 있다.
```js
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "동의하십니까?",
  function() { alert("동의하셨습니다."); },
  function() { alert("취소 버튼을 누르셨습니다."); }
);
```

## 함수 표현식 vs 함수 선언문
함수 표현식과 선언문의 차이는 다음과 같다.
1. 문법
2. 함수의 생성 시기가 다르다. 함수 표현식은 실행 흐름이 해당 함수에 도달했을 때 함수를 생성한다. 반면 함수 선언문은 스크립트가 실행되기 전인 '초기화 단계'에서 함수가 생성된다. 따라서 함수 선언문의 위치에 상관없이 함수를 사용하는 것이 가능하다.
```js
sayHi('John'); // Hello, John

function sayHi(name) {
  alert(`Hello, ${name}`);
}
```
```js
sayHi("John"); // 오류가 발생한다.

let sayHi = function(name) {
  alert( `Hello, ${name}` );
};
```
3. 엄격 모드에서는 함수 선언문이 코드 블록 내에 위치하면 해당 함수는 블록 내 어디서든 접근할 수 있다. 하지만 블록 밖에서는 함수에 접근할 수 없다.
```js
let age = 16;

if (age < 18) {
  welcome();               // \   (실행)
                           //  |
  function welcome() {     //  |
    alert('안녕!');        //  |  함수 선언문은 함수가 선언된 블록 내
  }                        //  |  어디에서든 유효하다.
                           //  |
  welcome();               // /   (실행)

} else {
  function welcome() {
    alert('안녕하세요!');
  }
}

// 이곳은 중괄호 밖이기 때문에 중괄호 안에서 선언한 함수 선언문은 호출할 수 없다.
welcome(); // 에러가 발생한다.
```
다음과 같이 함수 표현식을 사용하면 `if`문 밖에서 `welcome` 함수를 호출하는 것이 가능하다.
```js
let age = prompt('나이를 알려주세요.', 18);
let welcome;

if (age < 18) {
  welcome = function() {
    alert('안녕!');
  };
} else {
  welcome = function() {
    alert('안녕하세요!');
  };
}

welcome(); // 제대로 동작한다.
```
물음표 연산자 `?`를 사용하면 코드를 더 단순화할 수 있다.
```js
let age = prompt('나이를 알려주세요.', 18);

let welcome = (age < 18) ?
  function() {alert('안녕!');} :
  function() {alert('안녕하세요!');};

welcome(); // 제대로 동작한다.
```
함수 선언문을 사용하는 것이 부적절할 때에만 함수 표현식을 사용하는 것이 좋다. 함수 선언문을 사용하는 것이 코드 구성이 더 자유롭고 가독성도 좋기 때문이다.
<br></br>
# 17. 화살표 함수 기본
화살표 함수(arrow function)를 사용하면 함수 표현식보다 더 단순하고 간결한 문법으로 함수를 만들 수 있다.
```js
let func = function(arg1, arg2, ...argN) {
  return expression;
};

let func = (arg1, arg2, ...argN) => expression
```
인수가 하나밖에 없다면 인수를 감싸는 괄호를 생략할 수 있다.
```js
let double = n => n * 2;
```
인수가 하나도 없을 때는 괄호 안을 비워놓으면 된다. 하지만 괄호를 생략할 수는 없다.
```js
let sayHi = () => alert('안녕하세요!');
```
본문이 한 줄이 아닌 여러 줄일 때는 중괄호와 `return` 지시자를 넣어주면 된다.
```js
let sum = (a, b) => {  // 중괄호는 본문이 여러 줄로 구성되어 있음을 알려준다.
  let result = a + b;
  return result; // 중괄호를 사용했다면, return 지시자로 결괏값을 반환해주어야 한다.
};

alert(sum(1, 2)); // 3
```
