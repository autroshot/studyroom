# 1. 클래스와 기본 문법
**클래스**는 객체 지향 프로그래밍에서 특정 객체를 생성하기 위해 변수와 메소드를 정의하는 일종의 틀로, 객체를 정의하기 위한 상태(멤버 변수)와 메서드(함수)로 구성된다.

실무에서는 사용자나 물건 같이 동일한 종류의 객체를 여러 개 생성해야 하는 경우가 자주 있다.

이때 [new 연산자와 생성자 함수](https://github.com/autroshot/studyroom/blob/main/01-javascript/01-%EC%BD%94%EC%96%B4%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/04-%EA%B0%9D%EC%B2%B4:%20%EA%B8%B0%EB%B3%B8.md#05-new-%EC%97%B0%EC%82%B0%EC%9E%90%EC%99%80-%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98)에서 배운  `new function`을 사용할 수 있다.

여기에 더하여 모던 자바스크립트에 도입된  `클래스(class)`라는 문법을 사용하면 객체 지향 프로그래밍에서 사용되는 다양한 기능을 자바스크립트에서도 사용할 수 있다.

## 기본 문법
```js
class MyClass {
  // 여러 메서드를 정의할 수 있다.
  constructor() { ... }
  method1() { ... }
  method2() { ... }
  method3() { ... }
  ...
}
```
이렇게 클래스를 만들고, `new MyClass()`를 호출하면 내부에서 정의한 메서드가 들어 있는 객체가 생성된다.

```js run
class User {
  constructor(name) {
    this.name = name;
  }

  sayHi() {
    alert(this.name);
  }

}

let user = new User('John');
user.sayHi();
```
`new User('John')`를 호출하면 다음과 같은 일이 일어난다.
1.  새로운 객체가 생성된다.
2.  넘겨받은 인수와 함께  `constructor`가 자동으로 실행된다. 이때 인수  `'John'`이  `this.name`에 할당된다.

---
:warning: **메서드 사이에는 쉼표가 없다.**

클래스 메서드 사이에 쉼표를 넣으면 문법 에러가 발생한다. 클래스와 관련된 표기법은 객체 리터럴 표기법과 차이가 있다.

---

## 클래스란
자바스크립트에서 ***클래스는 함수의 한 종류이다.***
```js
class User {
  constructor(name) { this.name = name; }
  sayHi() { alert(this.name); }
}

alert(typeof User); // function
```
`class User {...}` 문법 구조가 실제로 하는 일은 다음과 같다.
1.  `User`라는 이름을 가진 함수를 만든다. 함수 본문은 생성자 메서드  `constructor`에서 가져온다. 생성자 메서드가 없으면 본문이 비워진 채로 함수가 만들어진다.
2.  `sayHi`같은 클래스 내에서 정의한 메서드를  `User.prototype`에 저장한다.

`new User`를 호출해 객체를 만들고, 객체의 메서드를 호출하면 [함수의 prototype 프로퍼티](https://github.com/autroshot/studyroom/blob/main/01-javascript/01-%EC%BD%94%EC%96%B4%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/08-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EA%B3%BC%20%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%20%EC%83%81%EC%86%8D.md#2-%ED%95%A8%EC%88%98%EC%9D%98-prototype-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0)에서 설명한 것처럼 메서드를 prototype 프로퍼티를 통해 가져온다.

## 클래스는 단순한 편의 문법이 아니다
어떤 사람들은 `class`라는 키워드 없이도 클래스 역할을 하는 함수를 선언할 수 있기 때문에 클래스는 '편의 문법’에 불과하다고 이야기한다. 참고로 기능은 동일하나 기존 문법을 쉽게 읽을 수 있게 만든 문법을 <strong>편의 문법(syntactic sugar, 문법 설탕)</strong>이라고 한다.

생성자 함수로 클래스 역할을 하는 함수를 선언하는 방법과 `class` 키워드를 사용하는 방법의 결과는 거의 동일하다.

하지만 두 방법에는 중요한 차이가 몇 가지 있다.
1. `class`로 만든 함수에는 특수 내부 프로퍼티인 `[[IsClassConstructor]]: true`가 이름표처럼 붙는다.
  클래스 생성자를 `new`와 함께 호출하지 않으면 에러가 발생하는데 이때 `[[IsClassConstructor]]: true`가 사용된다. 이외에도 자바스크립트는 다양한 경우에 `[[IsClassConstructor]]: true`를 활용한다.
2. 클래스에 정의된 메서드는 열거할 수 없다(non-enumerable). 클래스의 `prototype` 프로퍼티에 추가된 메서드의 `enumerable` 플래그는 `false`이다.
  `for..in`으로 객체를 순회할 때, 메서드는 순회 대상에서 제외하고자 하는 경우가 많으므로 이 특징은 꽤 유용하다.
3. 클래스는 항상  '엄격 모드'로 실행된다(`use strict`). 클래스 생성자의 코드 전체에는 자동으로 엄격 모드가 적용된다.

## 클래스 표현식
클래스도 함수처럼 다른 표현식 내부에서 정의, 전달, 반환, 할당할 수 있다.

먼저 클래스 표현식은 다음과 같이 만들 수 있다.
```js
let User = class {
  sayHi() {
    alert('안녕하세요.');
  }
};
```
[객체로서의 함수와 기명 함수 표현식](https://github.com/autroshot/studyroom/blob/main/01-javascript/01-%EC%BD%94%EC%96%B4%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/06-%ED%95%A8%EC%88%98%20%EC%8B%AC%ED%99%94%ED%95%99%EC%8A%B5.md#6-%EA%B0%9D%EC%B2%B4%EB%A1%9C%EC%84%9C%EC%9D%98-%ED%95%A8%EC%88%98%EC%99%80-%EA%B8%B0%EB%AA%85-%ED%95%A8%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D)에서 배운 기명 함수 표현식(Named Function Expression)과 유사하게 클래스 표현식에도 이름을 붙일 수 있다.

클래스 표현식에 이름을 붙이면, 이 이름은 오직 클래스 내부에서만 사용할 수 있다.
```js
// 기명 클래스 표현식(Named Class Expression)
// (명세서에는 없는 용어지만, 기명 함수 표현식과 유사하게 동작한다.)
let User = class MyClass {
  sayHi() {
    alert(MyClass); // MyClass라는 이름은 오직 클래스 안에서만 사용할 수 있다.
  }
};

new User().sayHi(); // 원하는 대로 MyClass의 정의를 보여준다.

alert(MyClass); // ReferenceError: MyClass is not defined (MyClass는 클래스 밖에서 사용할 수 없다)
```
필요에 따라 클래스를 동적으로 생성하는 것도 가능하다.
```js
function makeClass(phrase) {
  // 클래스를 선언하고 이를 반환한다.
  return class {
    sayHi() {
      alert(phrase);
    };
  };
}

// 새로운 클래스를 만든다.
let User = makeClass('안녕하세요.');

new User().sayHi(); // 안녕하세요.
```

## getter와 setter
리터럴을 사용해 만든 객체처럼 클래스도 getter/setter를 지원한다.
```js
class User {
  constructor(name) {
    // setter를 활성화한다.
    this.name = name;
  }

  get name() {
    return this._name;
  }

  set name(value) {
    if (value.length < 4) {
      alert('이름이 너무 짧습니다.');
      return;
    }
    this._name = value;
  }
}

let user = new User('보라');
alert(user.name); // 보라

user = new User(''); // 이름이 너무 짧습니다.
```
참고로 getter와 setter는 `User.prototype`에 정의된다.

## 계산된 메서드 이름 […]
객체의 '계산된 프로퍼티'처럼, 클래스도 대괄호 `[...]`을 이용한 <strong>계산된 메서드 이름(computed method name)</strong>을 지원한다.
```js
class User {
  ['say' + 'Hi']() {
    alert('Hello');
  }
}

new User().sayHi();
```

## 클래스 필드
---
:warning: **구식 브라우저에서는 폴리필이 필요할 수 있다.**

클래스 필드는 최근에 더해진 기능이다.

---
<strong>클래스 필드(class field)</strong>라는 문법을 사용하면 어떤 종류의 프로퍼티도 클래스에 추가할 수 있다.
```js
class User {
  name = '보라';

  sayHi() {
    alert(`${this.name}님 안녕하세요!`);
  }
}

new User().sayHi(); // 보라님 안녕하세요!
```
클래스를 정의할 때 `<프로퍼티 이름> = <값>`을 써주면 간단히 클래스 필드를 만들 수 있다.

클래스 필드의 중요한 특징 중 하나는 `User.prototype`이 아닌 개별 객체에만 클래스 필드가 설정된다는 것이다.

클래스 필드에는 복잡한 표현식이나 함수 호출 결과를 사용할 수 있다.
```js
class User {
  name = prompt('이름을 알려주세요.', '보라');
}

let user = new User();
alert(user.name); // 보라
```

### 클래스 필드로 바인딩 된 메서드 만들기
[함수 바인딩](https://github.com/autroshot/studyroom/blob/main/01-javascript/01-%EC%BD%94%EC%96%B4%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/06-%ED%95%A8%EC%88%98%20%EC%8B%AC%ED%99%94%ED%95%99%EC%8A%B5.md#10-%ED%95%A8%EC%88%98-%EB%B0%94%EC%9D%B8%EB%94%A9) 챕터에서 살펴본 것처럼 `this`는 동적으로 결정된다.

따라서 객체 메서드를 다른 곳에 전달해 다른 컨텍스트에서 호출하게 되면 `this`는 메서드가 정의된 객체를 참조하지 않는다.
```js
class Button {
  constructor(value) {
    this.value = value;
  }

  click() {
    alert(this.value);
  }
}

let button = new Button('안녕하세요.');

setTimeout(button.click, 1000); // undefined
```
이 문제를 해결하기 위한 방법이 다음과 같이 두 가지가 있었다.
1.  `setTimeout(() => button.click(), 1000)`과  같이 래퍼 함수를 전달한다.
2.  생성자 내부 등에서 메서드를 객체에 바인딩한다.

위의 방법 대신 **클래스 필드**라는 꽤 우아한 문법을 사용할 수 있다.
```js
class Button {
  constructor(value) {
    this.value = value;
  }
  click = () => {
    alert(this.value);
  }
}

let button = new Button('안녕하세요.');

setTimeout(button.click, 1000); // 안녕하세요.
```
클래스 필드  `click = () => {...}`는 각  `Button`  객체마다 독립적인 함수를 만들어주고 이 함수의  `this`를 해당 객체에 바인딩시켜준다. 따라서 개발자는  `button.click`을 아무 곳에나 전달할 수 있고,  `this`에는 항상 의도한 값이 들어가게 된다.

클래스 필드의 이런 기능은 브라우저 환경에서 메서드를 이벤트 리스너로 설정해야 할 때 특히 유용하다.

## 요약
```js
class MyClass {
  prop = value; // 프로퍼티

  constructor(...) { // 생성자 메서드
    // ...
  }

  method(...) {} // 메서드

  get something(...) {} // getter 메서드
  set something(...) {} // setter 메서드

  [Symbol.iterator]() {} // 계산된 이름(computed name)을 사용해 만드는 메서드 (심볼)
  // ...
}
```
`MyClass`는 `constructor`의 코드를 본문으로 갖는 함수이다. `MyClass`에서 정의한 일반 메서드나 getter, setter는 `MyClass.prototype`에 쓰인다.

# 2. 클래스 상속
클래스 상속을 사용하면 클래스를 다른 클래스로 확장할 수 있다. 기존에 존재하던 기능을 토대로 새로운 기능을 만들 수 있다.

## ‘extends’ 키워드
먼저 클래스 `Animal`을 다음과 같이 만들었다.
```js
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  run(speed) {
    this.speed = speed;
    alert(`${this.name} 은/는 속도 ${this.speed}로 달립니다.`);
  }
  stop() {
    this.speed = 0;
    alert(`${this.name} 이/가 멈췄습니다.`);
  }
}

let animal = new Animal('동물');
```
객체 `animal`과 클래스 `Animal`의 관계를 그림으로 나타내면 다음과 같다.

![rabbit-animal-independent-animal](https://user-images.githubusercontent.com/95019875/166946251-9b455045-e0d1-4057-8cd3-b18242a1a6fe.svg)

클래스 확장 문법 `class Child extends Parent`를 사용해 클래스를 확장할 수 있다.
```js
class Rabbit extends Animal {
  hide() {
    alert(`${this.name} 이/가 숨었습니다!`);
  }
}

let rabbit = new Rabbit('흰 토끼');

rabbit.run(5); // 흰 토끼 은/는 속도 5로 달립니다.
rabbit.hide(); // 흰 토끼 이/가 숨었습니다!
```
키워드 `extends`는 프로토타입을 기반으로 동작한다. `extends`는 `Rabbit.prototype.[[Prototype]]`을 `Animal.prototype`으로 설정한다. 그렇기 때문에 `Rabbit.prototype`에서 메서드를 찾지 못하면 `Animal.prototype`에서 메서드를 가져온다.

![animal-rabbit-extends](https://user-images.githubusercontent.com/95019875/166946277-5c81d02a-5f02-41a3-838f-a2baf4d016bd.svg)

---
:information_source: **`extends` 뒤에 표현식이 올 수도 있다.**

다음 예시처럼 `extends` 뒤에서 부모 클래스를 만들어주는 함수를 호출할 수 있다.
```js
function f(phrase) {
  return class {
    sayHi() { alert(phrase) }
  }
}

class User extends f('Hello') {}

new User().sayHi(); // Hello
```
`class User`는  `f('Hello')`의 반환 값을 상속받는다.

이 방법은 조건에 따라 다른 클래스를 상속받고 싶을 때 유용하다.

---

## 메서드 오버라이딩
`Rabbit`에서 `stop()` 등의 메서드를 자체적으로 정의하면, 상속받은 메서드가 아닌 자체 메서드가 사용된다.
```js
class Rabbit extends Animal {
  stop() {
    // rabbit.stop()을 호출할 때 
    // Animal의 stop()이 아닌, 이 메서드가 사용된다.
  }
}
```
개발을 하다 보면 부모 메서드 전체를 교체하지 않고, 부모 메서드를 토대로 일부 기능만 변경하고 싶을 때가 생긴다. 부모 메서드의 기능을 확장하고 싶을 때도 있다. 이럴 때 커스텀 메서드를 만들어 작업하게 되는데, 이미 커스텀 메서드를 만들었더라도 이 과정 전·후에 부모 메서드를 호출하고 싶을 때가 있다.

키워드 `super`는 이 때 사용한다.
-   `super.method(...)`는 부모 클래스에 정의된 메서드,  `method`를 호출한다.
-   `super(...)`는 부모 생성자를 호출하는데, 자식 생성자 내부에서만 사용 할 수 있다.

이런 특징을 이용해 토끼가 멈추면 자동으로 숨도록 하는 코드를 만들어 보겠다.
```js
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  run(speed) {
    this.speed = speed;
    alert(`${this.name}가 속도 ${this.speed}로 달립니다.`);
  }

  stop() {
    this.speed = 0;
    alert(`${this.name}가 멈췄습니다.`);
  }
}

class Rabbit extends Animal {
  hide() {
    alert(`${this.name}가 숨었습니다!`);
  }

  stop() {
    super.stop(); // 부모 클래스의 stop을 호출해 멈추고,
    this.hide(); // 숨는다.
  }
}

let rabbit = new Rabbit('흰 토끼');

rabbit.run(5); // 흰 토끼가 속도 5로 달립니다.
rabbit.stop(); // 흰 토끼가 멈췄습니다. 흰 토끼가 숨었습니다!
```
---
:information_source: 화살표 함수에는 `super`가 없다.

`super`에 접근하면 다음 예시와 같이 `super`를 외부 함수에서 가져온다.
```js
class Rabbit extends Animal {
  stop() {
    setTimeout(() => super.stop(), 1000); // 1초 후에 부모 stop을 호출한다.
  }
}
```
화살표 함수의 `super`는 `stop()`의 `super`와 같아서 위 예시는 의도한 대로 동작한다. `setTimeout`안에서 ‘일반’ 함수를 사용하면 에러가 발생한다.
```js
// Unexpected super
setTimeout(function() { super.stop() }, 1000);
```
---

## 생성자 오버라이딩
클래스가 다른 클래스를 상속받고 `constructor`가 없는 경우에는 아래처럼 ‘비어있는’ `constructor`가 만들어진다.
```js
class Rabbit extends Animal {
  // 자체 생성자가 없는 클래스를 상속받으면 자동으로 만들어진다.
  constructor(...args) {
    super(...args);
  }
}
```
생성자는 기본적으로 부모 `constructor`를 호출한다. 이때 부모 `constructor`에도 인수를 모두 전달한다. 클래스에 자체 생성자가 없는 경우에는 이런 일이 모두 자동으로 일어난다.

이제 `Rabbit`에 커스텀 생성자를 추가해보겠다.
```js
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  // ...
}

class Rabbit extends Animal {
  constructor(name, earLength) {
    this.speed = 0;
    this.name = name;
    this.earLength = earLength;
  }

  // ...
}

// 동작하지 않는다.
let rabbit = new Rabbit('흰 토끼', 10); // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
```
에러가 발생하는 이유는 다음과 같다.
-   **상속 클래스의 생성자에서는 반드시  `super(...)`를 호출해야 한다.  `super(...)`는  `this`를 사용하기 전에 반드시 호출해야 한다.**

자바스크립트는 '상속 클래스의 생성자 함수(derived constructor)'와 그렇지 않은 생성자 함수를 구분한다. 상속 클래스의 생성자 함수에는 특수 내부 프로퍼티인 `[[ConstructorKind]]:"derived"`가 이름표처럼 붙는다.

일반 클래스와 상속 클래스의 생성자 함수 간 차이는  `new`와 함께 드러난다.
-   일반 클래스가  `new`와 함께 실행되면, 빈 객체가 만들어지고  `this`에 이 객체를 할당한다.
-   상속 클래스의 생성자 함수는 빈 객체를 만들고  `this`에 이 객체를 할당하는 일을 부모 클래스의 생성자가 처리해주길 기대한다.

이런 차이 때문에 상속 클래스의 생성자에서는 `super`를 호출해 부모 생성자를 실행해 주어야 한다. 그렇지 않으면 `this`가 될 객체가 만들어지지 않아 에러가 발생한다.
```js
class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  // ...
}

class Rabbit extends Animal {
  constructor(name, earLength) {
    super(name);
    this.earLength = earLength;
  }

  // ...
}

// 이제 에러가 발생하지 않는다.
let rabbit = new Rabbit('흰 토끼', 10);
alert(rabbit.name); // 흰 토끼
alert(rabbit.earLength); // 10
```

### 클래스 필드 오버라이딩: 까다로운 내용
오버라이딩은 메서드뿐만 아니라 클래스 필드를 대상으로도 적용할 수 있다.
```js
class Animal {
  name = 'animal'

  constructor() {
    alert(this.name);
  }
}

class Rabbit extends Animal {
  name = 'rabbit';
}

new Animal(); // animal
new Rabbit(); // animal
```
위 예시를 통해 우리는 **‘부모 생성자는 자식 클래스에서 오버라이딩한 값이 아닌, 부모 클래스 안의 필드 값을 사용한다’** 는 사실을 알 수 있다.

클래스 필드는 자식 클래스에서 필드를 오버라이딩해도 부모 생성자가 오버라이딩한 필드 값을 사용하지 않는다. 부모 생성자는 항상 부모 클래스에 있는 필드의 값을 사용한다.

이런 일이 생기는 이유는 필드 초기화 순서 때문이다. 클래스 필드는 다음과 같은 규칙에 따라 초기화 순서가 달라진다.
-   아무것도 상속받지 않는 베이스 클래스는 생성자 실행 이전에 초기화된다.
-   부모 클래스가 있는 경우에는  `super()`  실행 직후에 초기화된다.

`new Rabbit()`을 실행하면 `super()`가 호출되고 그 결과 부모 생성자가 실행된다. 그런데 이때 하위 클래스 필드 초기화 순서에 따라 하위 클래스 `Rabbit`의 필드는 `super()` 실행 후에 초기화된다. 부모 생성자가 실행되는 시점에 `Rabbit`의 필드는 아직 존재하지 않는다. 이런 이유로 필드를 오버라이딩 했을 때 `Animal`에 있는 필드가 사용된 것이다.

개발하다가 필드 오버라이딩이 문제가 되는 상황이 발생하면 필드 대신 메서드를 사용하거나 getter나 setter를 사용해 해결하면 된다.

## super 키워드와 [[HomeObject]]
클래스이거나 객체 메서드인 함수의 `[[HomeObject]]` 프로퍼티에는 해당 객체가 저장된다.

`super`는 `[[HomeObject]]`를 이용해 부모 프로토타입과 메서드를 찾는다.
```js run
let animal = {
  name: '동물',
  eat() {         // animal.eat.[[HomeObject]] == animal
    alert(`${this.name} 이/가 먹이를 먹습니다.`);
  }
};

let rabbit = {
  __proto__: animal,
  name: '토끼',
  eat() {         // rabbit.eat.[[HomeObject]] == rabbit
    super.eat();
  }
};

let longEar = {
  __proto__: rabbit,
  name: '귀가 긴 토끼',
  eat() {         // longEar.eat.[[HomeObject]] == longEar
    super.eat();
  }
};

// 이제 제대로 동작한다.
longEar.eat();  // 귀가 긴 토끼 이/가 먹이를 먹습니다.
```
`[[HomeObject]]`의 메커니즘 덕분에 메서드가 의도한 대로 동작하는 것을 확인해 보았다. 이렇게 `longEar.eat`같은 객체 메서드는 `[[HomeObject]]`를 알고 있기 때문에 `this` 없이도 프로토타입으로부터 부모 메서드를 가져올 수 있다.

### 메서드는 자유롭지 않다.
자바스크립트에서 함수는 대개 객체에 묶이지 않고 자유롭다. 이런 자유성 때문에  `this`가 달라도 객체 간 메서드를 복사하는 것이 가능하다.

그런데  `[[HomeObject]]`는 그 존재만으로도 함수의 자유도를 파괴한다. 메서드가 객체를 기억하기 때문이다. 개발자가  `[[HomeObject]]`를 변경할 방법은 없기 때문에 한 번 바인딩된 함수는 더이상 변경되지 않는다.

다행인 점은 `[[HomeObject]]`는 오직 `super` 내부에서만 유효하다는 것이다. 그렇기 때문에 메서드에서  `super`를 사용하지 않는 경우에는 메서드의 자유성이 보장된다. 객체 간 복사 역시 가능하다. 하지만 메서드에서 `super`를 사용하면 이야기가 달라진다.

객체 간 메서드를 잘못 복사한 경우에 `super`가 제대로 동작하지 않는 경우를 살펴보겠다.
```js run
let animal = {
  sayHi() {
    console.log(`나는 동물입니다.`);
  }
};

// rabbit은 animal을 상속받는다.
let rabbit = {
  __proto__: animal,
  sayHi() {
    super.sayHi();
  }
};

let plant = {
  sayHi() {
    console.log('나는 식물입니다.');
  }
};

// tree는 plant를 상속받는다.
let tree = {
  __proto__: plant,
  sayHi: rabbit.sayHi // (*)
};

tree.sayHi();  // 나는 동물입니다.
```
의도와 다른 결과가 나오는데 그 원인은 다음과 같다.
-   `(*)`로 표시한 줄에서 메서드  `tree.sayHi`는 중복 코드를 방지하기 위해  `rabbit`에서 메서드를 복사해왔다.
-   그런데 복사해온 메서드는  `rabbit`에서 생성했기 때문에 이 메서드의  `[[HomeObject]]`는  `rabbit`이다. `[[HomeObject]]`는 변경할 수 없다.
-   `tree.sayHi()`의 코드 내부에는  `super.sayHi()`가 있다.  `rabbit`의 프로토타입은  `animal`이므로  `super`는 체인 위에 있는  `animal`로 올라가  `sayHi`를 찾는다.

이 과정을 그림으로 나타내면 다음과 같다.

![super-homeobject-wrong](https://user-images.githubusercontent.com/95019875/166946342-0b73c40c-13fc-4f0b-95c0-84719e1ead0d.svg)

### 함수 프로퍼티가 아닌 메서드 사용하기
`[[HomeObject]]`는 클래스와 일반 객체의 메서드에서 정의된다. 그런데 객체 메서드의 경우 `[[HomeObject]]`가 제대로 동작하게 하려면 메서드를 반드시 `method()` 형태로 정의해야 한다. `"method: function()"` 형태로 정의하면 안 된다.
```js
let animal = {
  eat: function() { // 'eat() {...' 대신 'eat: function() {...'을 사용해본다. 
    // ...
  }
};

let rabbit = {
  __proto__: animal,
  eat: function() {
    super.eat();
  }
};

rabbit.eat();  // SyntaxError: 'super' keyword unexpected here ([[HomeObject]]가 없어서 에러가 발생한다)
```

## 요약
1.  클래스 확장하기:  `class Child extends Parent`
    -   `Child.prototype.__proto__`가  `Parent.prototype`이 되므로 메서드 전체가 상속된다.
2.  생성자 오버라이딩:
    -   `this`를 사용하기 전에  `Child`  생성자 안에서  `super()`로 부모 생성자를 반드시 호출해야 한다.
3.  메서드 오버라이딩:
    -   `Child`에 정의된 메서드에서  `super.method()`를 사용해  `Parent`에 정의된 메서드를 사용할 수 있다.
4.  `super` 키워드와 `[[HomeObject]]`
    -   메서드는 내부 프로퍼티  `[[HomeObject]]`에 자신이 정의된 클래스와 객체를 기억해놓는다.  `super`는  `[[HomeObject]]`를 사용해 부모 메서드를 찾는다.
    -   따라서  `super`가 있는 메서드는 객체 간 복사 시 제대로 동작하지 않을 수 있다.

추가 사항:
-   화살표 함수는  `this`나  `super`를 갖지 않으므로 주변 컨텍스트에 잘 들어맞는다.

# 3. 정적 메서드와 정적 프로퍼티
`"prototype"`이 아닌 클래스 함수 자체에 메서드를 설정할 수도 있다. 이런 메서드를 <strong>정적(static)</strong> 메서드라고 부른다.

정적 메서드는 다음과 같이 클래스 안에서 `static` 키워드를 붙여 만들 수 있다.
```js
class User {
  static staticMethod() {
    alert(this === User);
  }
}

User.staticMethod(); // true
```
정적 메서드는 메서드를 프로퍼티 형태로 직접 할당하는 것과 동일한 일을 한다.

`User.staticMethod()`가 호출될 때  `this`의 값은 클래스 생성자인  `User`  자체가 된다(점 앞 객체).

정적 메서드는 **어떤 특정한 객체가 아닌 클래스에 속한 함수를 구현**하고자 할 때 주로 사용된다.

여러 개의 `Article` 객체를 비교하는 함수가 필요할 때 다음과 같이 구현할 수 있다.
```js
class Article {
  constructor(title, date) {
    this.title = title;
    this.date = date;
  }

  static compare(articleA, articleB) {
    return articleA.date - articleB.date;
  }
}

// 사용법
let articles = [
  new Article('HTML', new Date(2019, 1, 1)),
  new Article('CSS', new Date(2019, 0, 1)),
  new Article('JavaScript', new Date(2019, 11, 1))
];

articles.sort(Article.compare);

alert(articles[0].title); // CSS
```
여기서 `Article.compare`는 `Article` 객체를 비교해주는 수단으로, 글 전체를 ‘위에서’ 바라보며 비교를 수행한다. `Article.compare`이 글 하나의 메서드가 아닌 클래스의 메서드여야 하는 이유가 여기에 있다.

이번에 살펴볼 예시는 ‘팩토리’ 메서드를 구현한 코드이다. 다음과 같이 조건에 맞는 article 인스턴스를 만들어야 한다고 가정해 본다.
1.  매개변수(`title`,  `date`  등)를 이용해 관련 정보가 담긴 article 생성한다.
2.  오늘 날짜를 기반으로 비어있는 article 생성한다.

첫 번째 방법은 생성자를 사용해 구현할 수 있다. 두 번째 방법은 클래스에 정적 메서드를 만들어 구현할 수 있다.
```js
class Article {
  constructor(title, date) {
    this.title = title;
    this.date = date;
  }

  static createTodays() {
    // this는 Article이다.
    return new this('Today's digest', new Date());
  }
}

let article = Article.createTodays();

alert(article.title); // Today's digest
```
정적 메서드는 아래 예시와 같이 항목 검색, 저장, 삭제 등을 수행해주는 데이터베이스 관련 클래스에도 사용된다.
```js
// Article은 article을 관리해주는 특별 클래스라고 가정한다.
// article 삭제에 쓰이는 정적 메서드이다.
Article.remove({ id: 12345 });
```

## 정적 프로퍼티
---
:warning: **최근에 추가됨**

스펙에 추가된 지 얼마 안 된 문법이다. 예시는 Chrome에서만 동작할 수 있다.

---
정적 프로퍼티도 물론 만들 수 있다. 앞에 `static`만 붙이면 된다.
```js
class Article {
  static publisher = 'Ilya Kantor';
}

alert(Article.publisher); // Ilya Kantor
```
위 예시는 `Article`에 프로퍼티를 직접 할당한 것과 동일하게 동작한다.

## 정적 프로퍼티와 메서드 상속
정적 프로퍼티와 메서드는 상속된다.

다음 예시에서 `Animal.compare`와 `Animal.planet`은 상속되어서 각각 `Rabbit.compare`와 `Rabbit.planet`에서 접근할 수 있다.
```js
class Animal {
  static planet = '지구';

  constructor(name, speed) {
    this.speed = speed;
    this.name = name;
  }

  run(speed = 0) {
    this.speed += speed;
    alert(`${this.name}가 속도 ${this.speed}로 달립니다.`);
  }

  static compare(animalA, animalB) {
    return animalA.speed - animalB.speed;
  }
}

// Animal을 상속받았다.
class Rabbit extends Animal {
  hide() {
    alert(`${this.name}가 숨었습니다!`);
  }
}

let rabbits = [
  new Rabbit('흰 토끼', 10),
  new Rabbit('검은 토끼', 5)
];

rabbits.sort(Rabbit.compare);

rabbits[0].run(); // 검은 토끼가 속도 5로 달립니다.

alert(Rabbit.planet); // 지구
```
`Rabbit.compare`을 호출하면 `Animal.compare`가 호출된다.

`Rabbit extends Animal`은 두 개의  `[[Prototype]]`  참조를 만들어 낸다.
1.  함수  `Rabbit`은 프로토타입을 통해 함수  `Animal`을 상속받는다.
2.  `Rabbit.prototype`은 프로토타입을 통해  `Animal.prototype`을 상속받는다.

![animal-rabbit-static](https://user-images.githubusercontent.com/95019875/167063804-9e88f5be-8554-44d6-aaaa-7a97c1db14cf.svg)

이런 과정이 있기 때문에 일반 메서드 상속과 정적 메서드 상속이 가능하다.

## 요약
정적 메서드는 특정 클래스 인스턴스가 아닌 클래스 '전체’에 필요한 기능을 만들 때 사용할 수 있다.

인스턴스끼리 비교해주는 메서드  `Article.compare(article1, article2)`이나 팩토리 메서드  `Article.createTodays()`를 만들 때 정적 메서드가 쓰인다.

정적 프로퍼티는 데이터를 클래스 수준에 저장하고 싶을 때 사용한다. 정적 프로퍼티는 개별 인스턴스에 묶이지 않는다.

문법:
```js
class MyClass {
  static property = ...;

  static method() {
    ...
  }
}
```
`static`을 사용한 선언은 기술적으로는 클래스 자체에 직접 할당하는 것과 동일하다.
```js
MyClass.property = ...
MyClass.method = ...
```
정적 프로퍼티와 정적 메서드는 상속이 가능하다.

# 4. private, protected 프로퍼티와 메서드
객체 지향 프로그래밍에서 가장 중요한 원리 중 하나는 ***내부 인터페이스와 외부 인터페이스를 구분 짓는 것***이다.

프로그래밍에서 객체는 커피 머신과 같다. 프로그래밍에서는 보호 커버를 사용하는 대신 특별한 문법과 컨벤션을 사용해 안쪽 세부 사항을 숨긴다.

## 내부 인터페이스와 외부 인터페이스
객체 지향 프로그래밍에서 프로퍼티와 메서드는 두 그룹으로 분류된다.
- <strong>내부 인터페이스(internal interface)</strong>: 동일한 클래스 내의 다른 메서드에서는 접근할 수 있지만, 클래스 밖에서는 접근할 수 없는 프로퍼티와 메서드이다.
- <strong>외부 인터페이스(external interface)</strong>: 클래스 밖에서도 접근 가능한 프로퍼티와 메서드이다.

자바스크립트에는 아래와 같은 두 가지 타입의 객체 필드(프로퍼티와 메서드)가 있다.
-   **public**: 어디서든지 접근할 수 있으며 외부 인터페이스를 구성한다. 지금까지 다룬 프로퍼티와 메서드는 모두 public이다.
-   **private**: 클래스 내부에서만 접근할 수 있으며 내부 인터페이스를 구성할 때 쓰인다.

자바스크립트 이외의 다수 언어에서는 클래스 자신과 자손 클래스에서만 접근을 허용하는 ‘protected’ 필드를 지원한다. 자손 클래스의 필드에 접근해야 하는 경우가 많기 때문에, protected 필드는 private 필드보다 조금 더 광범위하게 사용됩니다.

자바스크립트는 protected 필드를 지원하지 않지만, protected를 사용하면 편리한 점이 많기 때문에 이를 모방해서 사용하는 경우가 많다.

## 프로퍼티 보호하기
간단한 커피 머신 클래스를 만들어 보겠다.
```js
class CoffeeMachine {
  waterAmount = 0; // 물통에 차 있는 물의 양

  constructor(power) {
    this.power = power;
    alert(`전력량이 ${power}인 커피머신을 만듭니다.`);
  }
}

// 커피 머신을 생성한다.
let coffeeMachine = new CoffeeMachine(100);

// 물을 추가한다.
coffeeMachine.waterAmount = 200;
```
현재 프로퍼티 `waterAmount`와 `power`는 public이다. 두 프로퍼티는 쉽게 읽고 수정할 수 있다.

**protected 프로퍼티 명 앞에는 밑줄  `_`이 붙는다.**

자바스크립트에서 강제한 사항은 아니지만, 밑줄은 프로그래머 사이에서 외부 접근이 불가능한 프로퍼티나 메서드를 나타낼 때 쓴다.

이제 `waterAmount`를 protected로 바꿔서 `waterAmount`를 통제해 보겠다.
```js
class CoffeeMachine {
  _waterAmount = 0;

  set waterAmount(value) {
    if (value < 0) throw new Error('물의 양은 음수가 될 수 없습니다.');
    this._waterAmount = value;
  }

  get waterAmount() {
    return this._waterAmount;
  }

  constructor(power) {
    this._power = power;
  }

}

// 커피 머신을 생성한다.
let coffeeMachine = new CoffeeMachine(100);

// 물을 추가한다.
coffeeMachine.waterAmount = -10; // Error: 물의 양은 음수가 될 수 없습니다.
```

## 읽기 전용 프로퍼티
프로퍼티를 생성할 때만 값을 할당할 수 있고, 그 이후에는 값을 절대 수정하지 말아야 할 때 읽기 전용 프로퍼티를 사용하면 된다.

읽기 전용 프로퍼티를 만들려면 setter(설정자)는 만들지 않고 getter(획득자)만 만들어야 한다.
```js
class CoffeeMachine {
  // ...

  constructor(power) {
    this._power = power;
  }

  get power() {
    return this._power;
  }
}

// 커피 머신을 생성한다.
let coffeeMachine = new CoffeeMachine(100);

alert(`전력량이 ${coffeeMachine.power}인 커피머신을 만듭니다.`); // 전력량이 100인 커피머신을 만든다.

coffeeMachine.power = 25; // Error (setter가 없다)
```
---
:information_source: **getter와 setter 함수**

위에서는 get, set 문법을 사용해서 getter와 setter 함수를 만들었다.

하지만 대부분은 아래와 같이  `get.../set...`  형식의 함수가 선호된다.
```js
class CoffeeMachine {
  _waterAmount = 0;

  setWaterAmount(value) {
    if (value < 0) throw new Error('물의 양은 음수가 될 수 없습니다.');
    this._waterAmount = value;
  }

  getWaterAmount() {
    return this._waterAmount;
  }
}

new CoffeeMachine().setWaterAmount(100);
```
이렇게 함수를 선언하면 다수의 인자를 받을 수 있기 때문에 좀 더 유연하다.  반면 get, set 문법을 사용하면 코드가 짧아진다는 장점이 있다. 

어떤 것을 사용해야 한다는 규칙은 없으므로 원하는 방식을 선택해서 사용한다.

---
:information_source: **protected 필드는 상속된다.**

protected 필드는 아래에서 보게 될 private 필드와 달리 상속된다.

---

## private 프로퍼티
---
:warning: 최근에 추가됨

스펙에 추가된 지 얼마 안 된 문법이다. 이 문법을 지원하지 않거나 부분적으로만 지원하는 엔진을 사용 중이라면 폴리필을 구현해야 한다.

---
private 프로퍼티와 메서드는 `#`으로 시작한다. `#`이 붙으면 클래스 안에서만 접근할 수 있다.

물 용량 한도를 나타내는 private 프로퍼티 `#waterLimit`과 남아있는 물의 양을 확인해주는 private 메서드 `#checkWater`를 구현해 보겠다.
```js
class CoffeeMachine {
  #waterLimit = 200;

  #checkWater(value) {
    if (value < 0) throw new Error('물의 양은 음수가 될 수 없습니다.');
    if (value > this.#waterLimit) throw new Error('물이 용량을 초과합니다.');
  }
}

let coffeeMachine = new CoffeeMachine();

// 클래스 외부에서 private에 접근할 수 없다.
coffeeMachine.#checkWater(); // Error
coffeeMachine.#waterLimit = 1000; // Error
```
`#`은 자바스크립트에서 지원하는 문법으로 private 필드를 의미한다. private 필드는 클래스 외부나 자손 클래스에서 접근할 수 없다.

private 필드는 public 필드와 충돌하지 않는다. private 프로퍼티 `#waterAmount`와 public 프로퍼티 `waterAmount`를 동시에 가질 수 있다.

`#waterAmount`의 접근자 `waterAmount`를 만들어 보겠다.
```js
class CoffeeMachine {
  #waterAmount = 0;

  get waterAmount() {
    return this.#waterAmount;
  }

  set waterAmount(value) {
    if (value < 0) throw new Error('물의 양은 음수가 될 수 없습니다.');
    this.#waterAmount = value;
  }
}

let machine = new CoffeeMachine();

machine.waterAmount = 100;
alert(machine.#waterAmount); // Error
```
protected 필드와 달리, private 필드는 언어 자체에 의해 강제된다는 점이 장점이다.

그런데  `CoffeeMachine`을 상속받는 클래스에서는  `#waterAmount`에 직접 접근할 수 없다.  `#waterAmount`에 접근하려면  `waterAmount`의 getter와 setter를 통해야 한다.
```js
class MegaCoffeeMachine extends CoffeeMachine {
  method() {
    alert(this.#waterAmount); // Error: CoffeeMachine을 통해서만 접근할 수 있다.
  }
}
```
다양한 상황에서 이런 제약사항은 너무 엄격하다. `CoffeeMachine`을 상속받는 클래스에서는 `CoffeeMachine`의 내부에 접근해야 하는 정당한 사유가 있을 수 있다. 언어 차원에서 protected 필드를 지원하지 않아도 더 자주 쓰이는 이유가 바로 여기에 있다.

---
:warning: **private 필드는 this[name]로 사용할 수 없다.**

private 필드는 특별하다.

알다시피, 보통은 `this[name]`을 사용해 필드에 접근할 수 있다.
```js
class User {
  ...
  sayHi() {
    let fieldName = 'name';
    alert(`Hello, ${this[fieldName]}`);
  }
}
```
하지만 private 필드는 `this[name]`으로 접근할 수 없다. 이런 문법적 제약은 필드의 보안을 강화하기 위해 만들어졌다.

---

## 요약
객체 지향 프로그래밍에선 내부 인터페이스와 외부 인터페이스를 구분하는 것을 <strong>캡슐화(encapsulation)</strong>라는 용어를 사용해 설명한다.

캡슐화는 이점은 다음과 같다.
### 사용자가 자신의 발등을 찍지 않도록 보호한다.
외부에서 의도치 않게 클래스를 조작하게 되면 그 결과는 예측할 수 없게 된다.

### 지원 가능
내부 인터페이스를 엄격하게 구분하면, 클래스 개발자들은 사용자에게 알리지 않고도 자유롭게 내부 프로퍼티와 메서드들을 수정할 수 있다.

### 복잡성 은닉
구현 세부 사항이 숨겨져 있으면 간단하고 편리해진다. 외부 인터페이스에 대한 설명도 문서화하기 쉬워진다.

내부 인터페이스를 숨기려면 protected나 private 프로퍼티를 사용하면 된다.
-   protected 필드는  `_`로 시작한다.  `_`은 자바스크립트에서 지원하는 문법은 아니지만 protected 필드를 나타낼 때 관습처럼 사용된다. 개발자는 protected 프로퍼티가 정의된 클래스와 해당 클래스를 상속받는 클래스에서만  `_`가 붙은 필드에 접근해야 한다.
-   private 필드는  `#`로 시작하며 자바스크립트에서 지원하는 문법이다.  `#`로 시작하는 필드는 해당 필드가 정의된 클래스 내부에서만 접근 가능하다.

# 5. 내장 클래스 확장하기
배열, 맵 같은 내장 클래스도 확장이 가능하다.

아래 예시에서 `PowerArray`는 기본 `Array`를 상속받아 만들었다.
```js run
// 메서드 하나를 추가한다(더 많이 추가하는 것도 가능하다).
class PowerArray extends Array {
  isEmpty() {
    return this.length === 0;
  }
}

let arr = new PowerArray(1, 2, 5, 10, 50);
alert(arr.isEmpty()); // false

let filteredArr = arr.filter(item => item >= 10);
alert(filteredArr); // 10, 50
alert(filteredArr.isEmpty()); // false
```
`filter`, `map` 등의 내장 메서드가 상속받은 클래스인 `PowerArray`의 인스턴스(객체)를 반환한다. 이 객체를 구현할 때는 내부에서 객체의 `constructor` 프로퍼티를 사용한다.
```js
arr.constructor === PowerArray
```
`arr.filter()`가 호출될 때, 내부에서는 기본 `Array`가 아닌 `arr.constructor`를 기반으로 새로운 배열이 만들어지고 여기에 필터 후 결과가 담긴다. 이렇게 되면 `PowerArray`에 구현된 메서드를 사용할 수 있다는 장점이 생긴다.

물론 동작 방식을 변경할 수 있다.

특수 정적 getter인 `Symbol.species`를 클래스에 추가할 수 있는데, `Symbol.species`가 있으면 `map`, `filter` 등의 메서드를 호출할 때 만들어지는 개체의 생성자를 지정할 수 있다.

`map`이나 `filter`같은 내장 메서드가 일반 배열을 반환하도록 하려면 다음 예시처럼 `Symbol.species`가 `Array`를 반환하도록 해주면 된다.
```js
class PowerArray extends Array {
  isEmpty() {
    return this.length === 0;
  }

  // 내장 메서드는 반환 값에 명시된 클래스를 생성자로 사용한다.
  static get [Symbol.species]() {
    return Array;
  }
}

let arr = new PowerArray(1, 2, 5, 10, 50);
alert(arr.isEmpty()); // false

// filter는 arr.constructor[Symbol.species]를 생성자로 사용해 새로운 배열을 만든다.
let filteredArr = arr.filter(item => item >= 10);

// filteredArr는 PowerArray가 아닌 Array의 인스턴스이다.
alert(filteredArr.isEmpty()); // Error: filteredArr.isEmpty is not a function
```
---
:information_source: **다른 컬렉션도 유사하게 동작한다.**

`Map`, `Set` 같은 컬렉션도 동일하게 동작한다. 이 컬렉션들도 `Symbol.species`를 사용한다.

---

## 내장 객체와 정적 메서드 상속
내장 객체는 `Object.keys`, `Array.isArray` 등의 자체 정적 메서드를 갖는다.

앞서 배웠듯이 네이티브 클래스들은 서로 상속 관계를 맺는다. `Array`는 `Object`를 상속받는다.

일반적으론 한 클래스가 다른 클래스를 상속받으면 정적 메서드와 그렇지 않은 메서드 모두를 상속받는다. 이와 관련된 내용은 [정적 메서드와 정적 프로퍼티](https://github.com/autroshot/studyroom/blob/main/01-javascript/01-%EC%BD%94%EC%96%B4%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/09-%ED%81%B4%EB%9E%98%EC%8A%A4.md#3-%EC%A0%95%EC%A0%81-%EB%A9%94%EC%84%9C%EB%93%9C%EC%99%80-%EC%A0%95%EC%A0%81-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0)에서 배웠다.

그런데 내장 클래스는 다르다. 내장클래스는 정적 메서드를 상속받지 못한다.

![object-date-inheritance](https://user-images.githubusercontent.com/95019875/167129873-bfe2c5d8-b99b-41c3-b105-bd38e3e91939.svg)

`Date`와 `Object`를 직접 이어주는 링크가 없는 것을 확인할 수 있다.

내장 객체 간의 상속과 `extends`를 사용한 상속의 가장 큰 차이점이 여기에 있다.

# 6. 'instanceof'로 클래스 확인하기
## instanceof 연산자
문법:
```js
obj instanceof Class
```
`obj`가 `Class`에 속하거나 `Class`를 상속받는 클래스에 속하면 `true`가 반환된다.
```js
class Rabbit {}
let rabbit = new Rabbit();

alert(rabbit instanceof Rabbit); // true
```
`instanceof`는 생성자 함수에서도 사용할 수 있다.
```js
// 클래스가 아닌 생성자 함수이다.
function Rabbit() {}

alert(new Rabbit() instanceof Rabbit); // true
```
`Array` 같은 내장 클래스에도 사용할 수 있다.
```js
let arr = [1, 2, 3];
alert(arr instanceof Array); // true
alert(arr instanceof Object); // true (`Array`는 프로토타입 기반으로 `Object`를 상속받는다)
```
정적 메서드 `Symbol.hasInstance`을 사용하면 직접 확인 로직을 설정할 수 있다.

클래스에 정적 메서드 `Symbol.hasInstance`가 구현되어 있으면, `obj instanceof Class`문이 실행될 때, `Class[Symbol.hasInstance](obj)`가 호출된다. 호출 결과는 `true`나 `false`여야 한다.
```js
// canEat 프로퍼티가 있으면 animal이라고 판단할 수 있도록
// instanceOf의 로직을 직접 설정한다.
class Animal {
  static [Symbol.hasInstance](obj) {
    if (obj.canEat) return true;
  }
}

let obj = { canEat: true };

alert(obj instanceof Animal); // true, Animal[Symbol.hasInstance](obj)가 호출된다.
```
대부분의 클래스에는 `Symbol.hasInstance`가 구현되어 있지 않다. 이럴 때는 일반적인 로직이 사용된다. `obj instanceOf Class`는 `Class.prototype`이 `obj` 프로토타입 체인 상의 프로토타입 중 하나와 일치하는지 확인한다.
```js
obj.__proto__ === Class.prototype?
obj.__proto__.__proto__ === Class.prototype?
obj.__proto__.__proto__.__proto__ === Class.prototype?
...
// 이 중 하나라도 true이면 true를 반환한다.
```
한편, `objA`가 `objB`의 프로토타입 체인 상의 어딘가에 있으면 `true`를 반환해주는 메서드, [objA.isPrototypeOf(objB)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/object/isPrototypeOf)도 있다. `obj instanceof Class`는 `Class.prototype.isPrototypeOf(obj)`와 동일하다.

`isPrototypeOf`는 `Class` 생성자를 제외하고 포함 여부를 검사하는 점이 조금 특이하다. 프로토타입 체인과 `Class.prototype`만 고려한다.

`isPrototypeOf`의 이런 특징 때문에 다음과 같이 객체 생성 후 `prototype` 프로퍼티가 변경되는 경우 `false`를 반환한다.
```js
function Rabbit() {}
let rabbit = new Rabbit();

// 프로토타입이 변경되었다.
Rabbit.prototype = {};

// 더 이상 Rabbit이 아니다.
alert(rabbit instanceof Rabbit); // false
```

## 보너스: 타입 확인을 위한 Object.prototype.toString
일반 객체를 문자열로 변화하면 `[object Object]`가 된다.
```js
let obj = {};

alert(obj); // [object Object]
alert(obj.toString()); // 같은 결과가 출력된다.
```
이렇게 `[object Object]`가 되는 이유는 `toString`의 구현방식 때문이다. 그런데 `toString`에는 `toString`을 더 강력하게 만들어주는 기능이 숨겨져 있다. `toString`의 숨겨진 기능을 사용하면 확장 `typeof`, `instanceof`의 대안을 만들 수 있다.

객체에서 내장 `toString`을 추출하는 게 가능하다. 이렇게 추출한 메서드는 모든 값을 대상으로 실행할 수 있다. 호출 결과는 값에 따라 달라진다.
-   숫자형 –  `[object Number]`
-   불린형 –  `[object Boolean]`
-   `null`  –  `[object Null]`
-   `undefined`  –  `[object Undefined]`
-   배열 –  `[object Array]`
-   그외 – 커스터마이징 가능

```js
// 편의를 위해 toString 메서드를 변수에 복사한다.
let objectToString = Object.prototype.toString;

let arr = [];

alert(objectToString.call(arr)); // [object Array]
```
[call/apply와 데코레이터, 포워딩](https://github.com/autroshot/studyroom/tree/main/01-javascript/01-%EC%BD%94%EC%96%B4%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8#9-callapply%EC%99%80-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8F%AC%EC%9B%8C%EB%94%A9) 챕터에서 배운 `call`을 사용해 컨텍스트를 `this=arr`로 설정하고 함수 `objectToString`를 실행하였다.

`toString` 알고리즘은 내부적으로 `this`를 검사하고 상응하는 결과를 반환한다.
```js
let s = Object.prototype.toString;

alert(s.call(123)); // [object Number]
alert(s.call(null)); // [object Null]
alert(s.call(alert)); // [object Function]
```

### Symbol.toStringTag
특수 객체 프로퍼티 `Symbol.toStringTag`를 사용하면 `toString`의 동작을 커스터마이징 할 수 있다.
```js run
let user = {
  [Symbol.toStringTag]: 'User'
};

alert({}.toString.call(user)); // [object User]
```
대부분의 호스트 환경은 자체 객체에 이와 유사한 프로퍼티를 구현해 놓고 있다.
```js
// 특정 호스트 환경의 객체와 클래스에 구현된 toStringTag이다.
alert(window[Symbol.toStringTag]); // Window
alert(XMLHttpRequest.prototype[Symbol.toStringTag]); // XMLHttpRequest

alert({}.toString.call(window)); // [object Window]
alert({}.toString.call(new XMLHttpRequest())); // [object XMLHttpRequest]
```
실행 결과에서 보듯이 호스트 환경 고유 객체의 `Symbol.toStringTag` 값은 `[object ...]`로 쌓여진 값과 동일하다.

내장 객체의 타입 확인을 넘어서 타입을 문자열 형태로 받고 싶다면 `instanceof` 대신, `{}.toString.call`을 사용할 수 있다.

## 요약
|               | 동작 대상      |  반환값      |
|---------------|-------------|---------------|
| `typeof`      | 원시형  |  문자열       |
| `{}.toString` | 원시형, 내장 객체, `Symbol.toStringTag`가 있는 객체   |       문자열 |
| `instanceof`  | 객체     |  true나 false   |

`{}.toString`은 `typeof`보다 기능이 더 많다.

`instanceof` 연산자는 계층 구조를 가진 클래스를 다룰 때나 클래스의 상속 여부를 확인하고자 할 때 그 진가를 발휘한다.
