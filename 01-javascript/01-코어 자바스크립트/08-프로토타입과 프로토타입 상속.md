# 1. 프로토타입 상속
자바스크립트 언어의 고유 기능인 <strong>프로토타입 상속(prototypal inheritance)</strong>을 이용하면 기존의 객체를 가져와 확장하는 것이 가능하다.

## [[Prototype]]
자바스크립트의 객체는 `[[Prototype]]`이라는 숨김 프로퍼티를 갖는다. 이 숨김 프로퍼티의 값은 `null`이거나 다른 객체를 참조한다. 다른 객체를 참조하는 경우에는 참조 대상을 <strong>프로토타입(prototype)</strong>이라 부른다.

![object-prototype-empty](https://user-images.githubusercontent.com/95019875/166406204-b9e878a0-b1fd-4ccb-bf53-f1cbcde8eae2.svg)

`object`에서 프로퍼티를 읽으려고 하는데 해당 프로퍼티가 없으면 자바스크립트는 자동으로 프로토타입에서 프로퍼티를 찾는다. 프로그래밍에서는 이런 동작 방식을 <strong>프로토타입 상속</strong>이라 부른다.

언어 차원에서 지원하는 편리한 기능이나 개발 테크닉 중 프로토타입 상속에 기반해 만들어진 것이 많다.

`[[Prototype]]` 프로퍼티는 내부 프로퍼티이면서 숨김 프로퍼티이지만 다양한 방법을 사용해 개발자가 값을 설정할 수 있다. 다음 예시처럼 특별한 이름인 `__proto__`을 사용하면 값을 설정할 수 있다.
```js
let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};

rabbit.__proto__ = animal;
```
---
:information_source: **`__proto__`는 `[[Prototype]]`용 getter·setter이다.**

`__proto__`는 `[[Prototype]]`과 다르다. `__proto__`는 `[[Prototype]]`의 getter(획득자)이자 setter(설정자)이다.

하위 호환성 때문에 여전히 `__proto__`를 사용할 수 있지만 비교적 근래에 작성된 스크립트에서는 `__proto__` 대신 함수 `Object.getPrototypeOf`나 `Object.setPrototypeOf`을 사용한다. 자세한 설명은 [프로토타입 메서드와 __proto__가 없는 객체](https://github.com/autroshot/studyroom/tree/main/01-javascript/01-%EC%BD%94%EC%96%B4%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8#4-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EB%A9%94%EC%84%9C%EB%93%9C%EC%99%80-__proto__%EA%B0%80-%EC%97%86%EB%8A%94-%EA%B0%9D%EC%B2%B4) 챕터에서 다룰 것이다.

서버 사이드를 포함한 모든 호스트 환경에서 `__proto__`를 지원한다.

---
객체 `rabbit`에 찾는 프로퍼티가 없다면, 자바스크립트는 자동으로 `animal`이라는 객체에서 프로퍼티를 얻는다.
```js
let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};

rabbit.__proto__ = animal;

// 프로퍼티 eats과 jumps를 rabbit에서도 사용할 수 있게 되었다.
alert(rabbit.eats); // true
alert(rabbit.jumps); // true
```

![proto-animal-rabbit](https://user-images.githubusercontent.com/95019875/166406251-2eff265e-65cb-4610-8b0b-2042d335a97d.svg)

이제 “`rabbit`의 프로토타입은 `animal`이다.” 혹은 "`rabbit`은 `animal`을 상속받는다."라고 말할 수 있다.

프로토타입을 설정해 준 덕분에 `rabbit`에서도 `animal`에 구현된 유용한 프로퍼티와 메서드를 사용할 수 있게 되었다. 이렇게 프로토타입에서 상속받은 프로퍼티를 <strong>상속 프로퍼티(inherited property)</strong>라고 한다.

다음과 같이 프로토타입 체인도 가능하다.
```js
let animal = {
  eats: true,
  walk() {
    alert('동물이 걷는다.');
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

let longEar = {
  earLength: 10,
  __proto__: rabbit
};

// 메서드 walk는 프로토타입 체인을 통해 상속받았다.
longEar.walk(); // 동물이 걷는다.
alert(longEar.jumps); // true (rabbit에서 상속받음)
```

![proto-animal-rabbit-chain](https://user-images.githubusercontent.com/95019875/166406284-78b94337-45ae-4dac-bac0-7f9cea281aee.svg)

프로토타입 체이닝에는 두 가지 제약사항이 있다.
1.  순환 참조(circular reference)는 허용되지 않는다. `__proto__`를 이용해 닫힌 형태로 다른 객체를 참조하면 에러가 발생한다.
2.  `__proto__`의 값은 객체나 `null`만 가능하다. 다른 자료형은 무시된다.
3. 객체에는 오직 하나의 `[[Prototype]]`만 있을 수 있다. 객체는 두 개의 객체를 상속받지 못한다.

---
:information_source: **객체의 프로토타입에서 프로퍼티를 가져오는 것은 성능적인 차이가 없다.**

```js
let head = {
  glasses: 1
};

let table = {
  pen: 3,
  __proto__: head
};

let bed = {
  sheet: 1,
  pillow: 2,
  __proto__: table
};

let pockets = {
  money: 2000,
  __proto__: bed
};
```
`glasses`를 얻을 때 `head.glasses`와 `pockets.glasses`는 성능 차이가 없다.

모던 엔진은 프로퍼티가 어디서 발견됐는지 기억하고 있다가 다음 요청 시 이 정보를 재사용한다.

---

## 프로토타입은 읽기 전용이다
프로퍼티를 추가, 수정하거나 지우는 연산은 객체에 직접 해야 한다.

객체 `rabbit`에 메서드 `walk`를 직접 할당해 보겠다.
```js
let animal = {
  eats: true,
  walk() {
    /* rabbit은 이제 이 메서드를 사용하지 않는다. */  
  }
};

let rabbit = {
  __proto__: animal
};

rabbit.walk = function() {
  alert('토끼가 깡충깡충 뜁니다.');
};

rabbit.walk(); // 토끼가 깡충깡충 뜁니다.
```
`rabbit.walk()`를 호출하면 프로토타입에 있는 메서드가 실행되지 않고, 객체 `rabbit`에 직접 추가한 메서드가 실행된다.

접근자 프로퍼티에서는 조금 다르게 작동하지만 결과는 동일하다. 접근자 프로퍼티에 값을 할당하면 객체에 프로퍼티가 추가되는게 아니라 setter 함수가 호출된다.
```js
let user = {
  name: 'John',
  surname: 'Smith',

  set fullName(value) {
    [this.name, this.surname] = value.split(' ');
  },

  get fullName() {
    return `${this.name} ${this.surname}`;
  }
};

let admin = {
  __proto__: user,
  isAdmin: true
};

alert(admin.fullName); // John Smith

// setter 함수가 실행된다.
admin.fullName = 'Alice Cooper';

alert(admin.fullName); // Alice Cooper, setter에 의해 추가된 admin의 프로퍼티(name, surname)에서 값을 가져온다.
alert(user.fullName); // John Smith, 원래 user에 있었던 프로퍼티 값이다.
```

## this가 나타내는 것
`this`는 프로토타입의 영향을 받지 않는다.

**메서드를 어디에서 호출했는지와 상관없이  `this`는 언제나  `.`  앞에 있는 객체이다.**

상속받은 메서드를 사용하더라도 객체는 프로토타입이 아닌 자신의 상태를 수정한다는 특징을 잘 기억해야 한다.
```js
// animal에는 다양한 메서드가 있다.
let animal = {
  walk() {
    if (!this.isSleeping) {
      alert(`동물이 걸어갑니다.`);
    }
  },
  sleep() {
    this.isSleeping = true;
  }
};

let rabbit = {
  name: '하얀 토끼',
  __proto__: animal
};

// rabbit에 새로운 프로퍼티 isSleeping을 추가하고 그 값을 true로 변경한다.
rabbit.sleep();

alert(rabbit.isSleeping); // true
alert(animal.isSleeping); // undefined (프로토타입에는 isSleeping이라는 프로퍼티가 없다.)
```
메서드는 공유되지만 객체의 상태는 공유되지 않는다는 것을 확인할 수 있다.

## for…in 반복문
`for..in`은 상속 프로퍼티도 순회 대상에 포함시킨다.
```js
let animal = {
  eats: true
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

// Object.keys는 객체 자신의 키만 반환한다.
alert(Object.keys(rabbit)); // jumps

// for..in은 객체 자신의 키와 상속 프로퍼티의 키 모두를 순회한다.
for(let prop in rabbit) alert(prop); // jumps, eats
```
[obj.hasOwnProperty(key)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)를 이용하면 상속 프로퍼티를 순회 대상에서 제외할 수 있다. 이 내장 메서드는 상속 프로퍼티가 아니고  `obj`에 직접 구현되어있는 프로퍼티일 경우에만  `true`를 반환한다.

`obj.hasOwnProperty(key)`를 응용하면 다음 예시처럼 객체 자신의 프로퍼티와 상속 프로퍼티를 나눌 수 있다.
```js
let animal = {
  eats: true
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

for(let prop in rabbit) {
  let isOwn = rabbit.hasOwnProperty(prop);

  if (isOwn) {
    alert(`객체 자신의 프로퍼티: ${prop}`); // 객체 자신의 프로퍼티: jumps
  } else {
    alert(`상속 프로퍼티: ${prop}`); // 상속 프로퍼티: eats
  }
}
```
---
:information_source: **키-값을 순회하는 메서드 대부분은 상속 프로퍼티를 제외하고 동작한다.**

`Object.keys`, `Object.values` 같이 객체의 키-값을 대상으로 무언가를 하는 메서드 대부분은 상속 프로퍼티를 제외하고 동작한다.

---

# 2. 함수의 prototype 프로퍼티
이번 챕터에서는 **생성자 함수**를 사용해 객체를 만든 경우에 프로토타입이 어떻게 동작하는지에 대해 알아볼 것이다.

생성자 함수로 만든 객체는 생성자 함수의 프로토타입 정보를 사용해 [[Prototype]]을 설정한다는 차이가 있다.

---
:information_source: **주의**

과거에는 프로토타입에 직접 접근할 수 있는 방법이 생성자 함수의 `prototype` 프로퍼티를 이용하는 방법뿐이었다. 많은 스크립트가 아직 이 방법을 사용하고 있다.

---
생성자 함수(`F`)의 프로토타입을 의미하는 `F.prototype`에서 `prototype`은 `F`에 정의된 일반 프로퍼티이다. 이것은 바로 앞 챕터에서 배운 '프로토타입'과 이름만 같은, 우리가 익히 알고 있는 일반적인 프로퍼티이다.
```js
let animal = {
  eats: true
};

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;

let rabbit = new Rabbit('흰 토끼'); //  rabbit.__proto__ == animal

alert(rabbit.eats); // true
```
`Rabbit.prototype = animal`은 `new Rabbit`을 호출해 만든 새로운 객체의 `[[Prototype]]`을 `animal`로 설정하라는 것을 의미한다.

![proto-constructor-animal-rabbit](https://user-images.githubusercontent.com/95019875/166429102-8bad2808-6d63-481c-8d3e-fe0ff2328320.svg)

여기서 가로 화살표는 일반 프로퍼티인 `prototype`을, 세로 화살표는 `[[Prototype]]`을 나타낸다. 세로 화살표는 `rabbit`이 `animal`을 상속받았다는 것을 의미한다.

---
:information_source: **`F.prototype`은 `new F`를 호출할 때만 사용된다.**

`F.prototype` 프로퍼티는 `new F`를 호출할 때만 사용되며 새롭게 만들어지는 객체의 `[[Prototype]]`을 지정해 준다.

`F.prototype` 프로퍼티가 바뀌어도 이전에 만들어졌던 객체의 `[[Prototype]]`은 그대로 유지된다.

---
:information_source: **일반 객체에 `prototype` 프로퍼티를 추가하면 아무 일도 일어나지 않는다.**

```js
let user = {
  name: 'John',
  prototype: 'Bla-bla' // 마술은 일어나지 않는다.
};
```
---

## 함수의 디폴트 프로퍼티 prototype과 constructor 프로퍼티
별도로 지정하지 않아도 모든 함수는 기본적으로 `prototype` 프로퍼티를 갖는다.

디폴트(default) 프로퍼티 `prototype`은 `constructor` 프로퍼티 하나만 있는 객체를 가리키는데, 이 `constructor` 프로퍼티는 함수 자신을 가리킨다.
```js
function Rabbit() {}

/* 디폴트 prototype
Rabbit.prototype = { constructor: Rabbit };
*/
```

![function-prototype-constructor](https://user-images.githubusercontent.com/95019875/166429118-665abb78-435c-42d9-944c-bafad438c5a2.svg)

특별한 조작을 가하지 않았다면 `new Rabbit`을 실행해 만든 토끼 객체 모두에서 `constructor` 프로퍼티를 사용할 수 있는데, 이때 `[[Prototype]]`을 거친다.
```js
function Rabbit() {}
// 디폴트 prototype:
// Rabbit.prototype = { constructor: Rabbit }

let rabbit = new Rabbit(); // { constructor: Rabbit }을 상속받았다.

alert(rabbit.constructor == Rabbit); // true ([[Prototype]]을 거쳐 접근한다)
```

![rabbit-prototype-constructor](https://user-images.githubusercontent.com/95019875/166429150-6c3ce28d-a191-4b83-ad18-1f2ac19a6fbc.svg)

`constructor` 프로퍼티는 다음과 같이 기존에 있던 객체의 `constructor`를 사용해 새로운 객체를 만들때 사용할 수 있다.
```js
function Rabbit(name) {
  this.name = name;
  alert(name);
}

let rabbit = new Rabbit('흰 토끼');

let rabbit2 = new rabbit.constructor('검정 토끼');
```
이 방법은 객체가 있는데 이 객체를 만들 때 어떤 생성자가 사용되었는지 알 수 없는 경우(객체가 서드 파티 라이브러리에서 온 경우 등)에 유용하다.

**자바스크립트는 알맞은  `constructor`  값을 보장하지 않는다**는 것을 유의해야 한다.

함수에 기본으로 `prototype`이 설정될 뿐, `constructor`와 관련해서 벌어지는 모든 일은 전적으로 개발자에게 달려있다.

다음 예시에서는 `prototype` 프로퍼티 값을 다른 객체로 바꿨더니 new를 사용해 만든 객체에 `constructor`가 없는 것을 확인할 수 있다.
```js
function Rabbit() {}
Rabbit.prototype = {
  jumps: true
};

let rabbit = new Rabbit();
alert(rabbit.constructor === Rabbit); // false
```
이런 상황을 방지하고 `constructor`의 기본 성질을 제대로 활용하려면, `prototype` 전체를 덮어쓰지 말고 디폴트 `prototype`에 원하는 프로퍼티를 추가, 제거해야 한다.
```js
function Rabbit() {}

// Rabbit.prototype 전체를 덮어쓰지 말고
// 원하는 프로퍼티가 있으면 그냥 추가한다.
Rabbit.prototype.jumps = true
// 이렇게 하면 디폴트 프로퍼티 Rabbit.prototype.constructor가 유지된다.
```
실수로 `prototype`을 덮어씌었더라도 `constructor` 프로퍼티를 다시 만들어주면 `constructor`를 문제 없이 사용할 수 있다.
```js
Rabbit.prototype = {
  jumps: true,
  constructor: Rabbit
};

// 수동으로 constructor를 추가해 주었기 때문에 우리가 알고 있던 constructor의 특징을 그대로 사용할 수 있다.
```

# 3. 내장 객체의 프로토타입
## Object.prototype
```js
let obj = {};
alert(obj); // [object Object]
```
`obj = new Object()`를 줄이면 `obj = {}`가 된다. `Object`는 내장 객체 생성자 함수인데, 이 생성자 함수의 `prototype`은 `toString`을 비롯한 다양한 메서드가 구현되어있는 거대한 객체를 참조한다.

`new Object()`를 호출하거나 리터럴 문법 `{...}`을 사용해 객체를 만들 때, 새롭게 생성된 객체의 `[[Prototype]]`은 바로 앞 챕터에서 언급한 규칙에 따라 `Object.prototype`을 참조한다.

![object-prototype-1](https://user-images.githubusercontent.com/95019875/166443613-f3baeec8-f942-483d-9605-103cd7ee1f43.svg)

따라서 `obj.toString()`을 호출하면 `Object.prototype`에서 해당 메서드를 가져오게 된다.

## 다양한 내장 객체의 프로토타입
`Array`, `Date`, `Function`을 비롯한 내장 객체들 역시 프로토타입에 메서드를 저장해 놓는다. 이런 내부 동작은 메모리 효율을 높여주는 장점이 있다.

명세서에 의하면 모든 내장 프로토타입의 상속 트리 꼭대기에는 `Object.prototype`이 있어야 한다고 규정한다. 이런 명세 때문에 "**모든 것은 객체를 상속받는다.**"라고 한다.

![native-prototypes-classes](https://user-images.githubusercontent.com/95019875/166443623-46dcf499-5385-4996-b6f6-5e409affac79.svg)

체인 상의 프로토타입에는 중복 메서드가 있을 수 있다. 중복 메서드가 있을 때는 체인 상에서 가까운 곳에 있는 메서드가 사용된다.

그 예시로는 `Array.prototype`과 `Object.prototype`에서 중복되는 메서드 `toString`이 있다.

![native-prototypes-array-tostring](https://user-images.githubusercontent.com/95019875/166443640-6a624fc8-19bd-46c8-9066-d500af7b8b25.svg)

함수도 마찬가지다. 함수는 내장 객체 `Function`의 생성자를 사용해 만들어지는데, `call`, `apply`를 비롯한 메서드는 `Fuction.prototype`에서 받아온다. 참고로 함수에도 `toString`이 구현되어 있다.

## 원시값
문자열, 숫자, 불린값은 객체가 아니다. 이런 원시 타입 값의 프로퍼티에 접근하려고 하면 내장 생성자 `String`, `Number`, `Boolean`을 사용하는 임시 래퍼(wrapper) 객체가 생성된다. 임시 래퍼 객체는 메서드를 제공하고 나면 사라진다.

임시 래퍼 객체는 우리에게 보이지 않는 곳에서 만들어지고 엔진에 의해 최적화가 이루어진다. 이 객체의 메서드는 `String.prototype`, `Number.prototype`, `Boolean.prototype`와 같은 프로토타입에 존재한다.

---
:warning: **`null`과 `undefined`에 대응하는 래퍼 객체는 없다.**

`null`과 `undefined`에 대응하는 래퍼 객체는 없으며, `null`과 `undefined`에서는 메서드와 프로퍼티를 이용할 수 없다. 프로토타입도 물론 사용할 수 없다.

---

## 네이티브 프로토타입 변경하기
네이티브 프로토타입은 수정할 수 있다.

다음과 같이 `String.prototype`에 메서드를 하나 추가하면 모든 문자열에서 해당 메서드를 사용할 수 있다.
```js
String.prototype.show = function() {
  alert(this);
};

'BOOM!'.show(); // BOOM!
```
개발을 하다 보면 네이티브 프로토타입에 새 내장 메서드를 추가하고 싶은 유혹이 자꾸 생길 것이다. 하지만 이것은 좋지 않은 생각이다.

---
:warning: **중요**

프로토타입은 전역으로 영향을 미치기 때문에 프로토타입을 조작하면 기존 코드와 충돌이 날 가능성이 크다. 두 라이브러리에서 동시에  `String.prototype.show`  메서드를 추가하면 한 라이브러리의 메서드가 다른 라이브러리의 메서드를 덮어쓴다.

이런 이유로 **네이티브 프로토타입을 수정하는 것은 추천하지 않는다.**

---
**모던 프로그래밍에서 네이티브 프로토타입 변경을 허용하는 경우는 폴리필을 만들 때뿐이다.**

폴리필은 자바스크립트 명세서에 있는 메서드와 동일한 기능을 하는 메서드 구현체를 의미한다. 명세서에는 정의되어 있으나 특정 자바스크립트 엔진에서는 해당 기능이 구현되어있지 않을 때 폴리필을 사용한다.
```js
if (!String.prototype.repeat) { // repeat이라는 메서드가 없다고 가정한다.
  // 프로토타입에 repeat를 추가한다.

  String.prototype.repeat = function(n) {
    // string을 n회 반복(repeat)한다.

    // 실제 이 메서드를 구현하려면 더 복잡한 코드가 필요하다.
    // 전체 알고리즘은 명세서에서 확인할 수 있는데,
    // 명세서를 완벽히 구현하지 않은 폴리필이라도 충분히 쓸만하니 예시는 이 정도로만 작성해보겠다.
    return new Array(n + 1).join(this);
  };
}

alert('라'.repeat(3)); // 라라라
```

## 프로토타입에서 메서드 빌려오기
[call/apply와 데코레이터, 포워딩](https://github.com/autroshot/studyroom/blob/main/01-javascript/01-%EC%BD%94%EC%96%B4%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/06-%ED%95%A8%EC%88%98%20%EC%8B%AC%ED%99%94%ED%95%99%EC%8A%B5.md#9-callapply%EC%99%80-%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8F%AC%EC%9B%8C%EB%94%A9) 챕터에서 **메서드 빌리기**에 대한 내용을 다룬 적이 있다.

한 객체의 메서드를 다른 객체로 복사할 때 이 기법이 사용된다.

개발을 하다 보면 네이티브 프로토타입에 구현된 메서드를 빌려야 하는 경우가 종종 생긴다.

다음 예시에서는 유사 배열 객체를 만들고 여기에 `Array` 메서드를 복사한다.
```js
let obj = {
  0: 'Hello',
  1: 'world!',
  length: 2,
};

obj.join = Array.prototype.join;

alert(obj.join(',')); // Hello,world!
```
내장 메서드 `join`의 내부 알고리즘은 제대로 된 인덱스가 있는지, `length` 프로퍼티가 있는지만 확인하기 때문에 예시는 에러 없이 의도한 대로 동작한다. 호출 대상이 진짜 배열인지는 상관없다. 다수의 내장 메서드가 이런 식으로 동작한다.

메서드 빌리기 대신 `obj.__proto__`를 `Array.prototype`으로 설정해 배열 메서드를 상속받는 방법이 있다. 이렇게 하면 `obj`에서 모든 `Array` 메서드를 사용할 수 있다. 그런데 자바스크립트는 단일 상속만 허용하기 때문에 이 방법은 `obj`가 다른 객체를 상속받고 있을 때는 사용할 수 없다.

메서드 빌리기는 여러 객체에서 필요한 기능을 가져와 섞는 것을 가능하게 해주기 때문에 유연한 개발을 가능하게 해준다.

# 4. 프로토타입 메서드와 __proto__가 없는 객체
`__proto__`는 브라우저를 대상으로 개발하고 있다면 다소 구식이기 때문에 더는 사용하지 않는 것이 좋다. 표준에도 관련 내용이 명시되어 있다.

대신 다음의 모던한 메서드를 사용하는 것이 좋다.
-   [Object.create(proto, [descriptors])](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/create) - `[[Prototype]]`이  `proto`를 참조하는 빈 객체를 만든다. 이때 프로퍼티 설명자를 추가로 넘길 수 있다.
-   [Object.getPrototypeOf(obj)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf) - `obj`의  `[[Prototype]]`을 반환한다.
-   [Object.setPrototypeOf(obj, proto)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf) - `obj`의  `[[Prototype]]`이  `proto`가 되도록 설정한다.

```js
let animal = {
  eats: true
};

// 프로토타입이 animal인 새로운 객체를 생성한다.
let rabbit = Object.create(animal);

alert(rabbit.eats); // true

alert(Object.getPrototypeOf(rabbit) === animal); // true

Object.setPrototypeOf(rabbit, {}); // rabbit의 프로토타입을 {}으로 바꾼다.
```

`Object.create`에는 프로퍼티 설명자를 선택적으로 전달할 수 있다. 설명자는 [프로퍼티 플래그와 설명자](https://github.com/autroshot/studyroom/blob/main/01-javascript/01-%EC%BD%94%EC%96%B4%20%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/07-%EA%B0%9D%EC%B2%B4%20%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%20%EC%84%A4%EC%A0%95.md#1-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%ED%94%8C%EB%9E%98%EA%B7%B8%EC%99%80-%EC%84%A4%EB%AA%85%EC%9E%90) 챕터에서 배운 것과 같은 형태로 사용하면 된다.

`Object.create`를 사용하면 `for..in`을 사용하는 것보다 더 효과적으로 객체의 얕은 복사본(shallow-copy)을 만들 수 있다.
```js
let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
```
`Object.create`를 호출하면 `obj`의 모든 프로퍼티를 포함한 완벽한 사본이 만들어진다, 사본에는 열거 가능한 프로퍼티와 불가능한 프로퍼티, 데이터 프로퍼티, getter, setter 등 모든 프로퍼티가 복제된다. `[[Prototype]]`도 복제된다.

---
:warning: **속도가 중요하다면 기존 객체의 `[[Prototype]]`을 변경하지 말아야 한다.**

원한다면 언제나 `[[Prototype]]`을 얻거나 설정할 수 있다. 하지만 대개는 객체를 생성할 때에만 `[[Prototype]]`을 설정하고 이후에는 수정하지 않는다.

자바스크립트 엔진은 `[[Prototype]]`을 변경하지 않는 방식에 최적화되어 있다. 프로토타입을 즉석에서 바꾸는 연산은 객체 프로퍼티 접근 작업의 최적화를 망치기 때문에 성능에 나쁜 영향을 미친다.

---

## 아주 단순한 객체
알다시피 객체는 키-값 쌍을 저장하는 연관 배열로도 사용할 수 있다.

그런데 커스텀 사전을 만드는 것과 같이 사용자가 직접 입력한 키를 가지고 객체를 만들다 보면 사소한 결함이 발견된다. 다른 문자열은 괜찮지만 `"__proto__"`라는 문자열은 키로 사용할 수 없다.
```js
let obj = {};

let key = prompt('입력하고자 하는 key는 무엇인가요?', '__proto__');
obj[key] = '...값...';

alert(obj[key]); // '...값...'이 아닌 [object Object]가 출력됩니다.
```
`__proto__`는 항상 객체이거나 `null`이어야 한다. 문자열은 프로토타입이 될 수 없다.

예시에서는 이 버그가 그리 치명적이지 않다. 그런데 할당 값이 객체일 때는 프로토타입이 바뀔 수 있다는 치명적인 버그가 발생할 수 있다. 프로토타입이 바뀌면 예상치 못한 일이 발생할 수 있기 때문이다.

개발자들은 대개 프로토타입이 중간에 바뀌는 시나리오는 배제하고 개발을 진행한다. 이런 고정관념 때문에 프로토타입이 중간에 바뀌면서 발생한 버그는 그 원인을 쉽게 찾지 못한다. 서버 사이드에서 자바스크립트를 사용 할 때는 이런 버그가 취약점이 되기도 한다.

이 문제를 해결하기 위해서는 객체 대신 맵을 사용하면 된다. 또는 객체를 사용하면서 다음 방법을 이용할 수 있다.

이전에 배웠듯이 `__proto__`는 객체의 프로퍼티가 아니라 `Object.prototype`의 접근자 프로퍼티이다.

![object-prototype-2](https://user-images.githubusercontent.com/95019875/166463100-b45f5275-ac78-4581-abb4-1b311a48ec0b.svg)

간단한 트릭을 사용해서 객체가 연관 배열의 역할을 다 하도록 만들 수 있다.
```js
let obj = Object.create(null);

let key = prompt('입력하고자 하는 key는 무엇인가요?', '__proto__');
obj[key] = '...값...';

alert(obj[key]); // '...값...'이 제대로 출력된다.
```
`Object.create(null)`을 사용해 프로토타입이 없는 빈 객체를 만들었다. 이 객체는 `__proto__` getter와 setter를 상속받지 않는다.

이제 `__proto__`는 평범한 데이터 프로퍼티처럼 처리되므로 문제 없이 예시가 잘 동작하게 된다.

이렇게 프로토타입이 없는 빈 객체는 ‘아주 단순한(very plain)’ 혹은 ‘순수 사전식(pure dictionary)’ 객체라고 부른다. 일반 객체  `{...}`  보다 훨씬 단순하다. 참고로 아주 단순한 객체는 내장 메서드가 없다는 단점이 있다. `toString`같은 메서드를 사용할 수 없다.

하지만 객체를 연관 배열로 쓸 때는 이런 단점이 문제가 되진 않는다.

객체 관련 메서드 대부분은 `Object.keys(obj)` 같이 `Object.something(...)` 형태를 가진다. 이 메서드는 프로토타입에 있는 것이 아니기 때문에 '아주 단순한 객체’에도 사용할 수 있다.
```js
let chineseDictionary = Object.create(null);
chineseDictionary.hello = '你好';
chineseDictionary.bye = '再见';

alert(Object.keys(chineseDictionary)); // hello,bye
```

관련된 메서드는 다음과 같다.
-   [Object.keys(obj)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)  /  [Object.values(obj)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/values)  /  [Object.entries(obj)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)  –  `obj`  내 열거 가능한 프로퍼티 키, 값, 키-값 쌍을 담은 배열을 반환한다.
-   [Object.getOwnPropertySymbols(obj)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols)  –  `obj`  내 심볼형 키를 담은 배열을 반환한다.
-   [Object.getOwnPropertyNames(obj)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames)  –  `obj`  내 문자형 키를 담은 배열을 반환한다.
-   [Reflect.ownKeys(obj)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys)  –  `obj`내 키 전체를 담은 배열을 반환한다.
-   [obj.hasOwnProperty(key)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)  – 상속받지 않고  `obj`  자체에 구현된 키 중 이름이  `key`인 것이 있으면  `true`를 반환한다.

`Object.keys`를 비롯하여 객체의 프로퍼티를 반환하는 메서드들은 객체가 ‘직접 소유한’ 프로퍼티만 반환한다. 상속 프로퍼티는 `for..in`을 사용해 얻을 수 있다.
