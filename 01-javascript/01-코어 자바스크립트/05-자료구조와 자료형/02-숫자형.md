# 숫자형
## 숫자를 입력하는 다양한 방법
큰 숫자나 작은 숫자를 나타낼 때는 과학적 표기법을 이용한다. 자바스크립트에서는 숫자 옆에 `e`를 붙이고 원하는 0의 개수를 그 옆에 붙여주면 된다.
```js
let billion = 1e9;  // 10억, 1과 9개의 0
alert(7.3e9);  // 73억(7,300,000,000)

let ms =  1e-6;  // 0이 6개인 소수이다.
```

### 16진수, 2진수, 8진수
16진수는 `0x`를 사용해 표현할 수 있다.
```js
alert(0xff); // 255
alert(0xFF); // 255(대·소문자를 가리지 않으므로 둘 다 같은 값을 나타낸다)
```
2진수와 `0b`를, 8진수는 `0o`를 사용해 나타낼 수 있다.
```js
let a = 0b11111111; // 255의 2진수
let b = 0o377; // 255의 8진수

alert(a == b); // true, a와 b는 같은 수이다.
```
자바스크립트에서 지원하는 진법은 앞의 3개이다. 이 외의 진법을 사용하려면 함수 `parseInt`를 사용해야 한다.

## toString(base)
`num.toString(base)` 메서드는 `base`진법으로 `num`을 표현한 후, 이를 문자형으로 변환해 반환한다.
```js
let num = 255;

alert(num.toString(16));  // ff
alert(num.toString(2));   // 11111111
```
`base`는 기본값이 `10`이며, `2`부터 `36`까지 넣을 수 있다. `base`별 유스 케이스는 다음과 같다.

### base=16
16진수 색, 문자 인코딩 등을 표현할 때 사용한다. 숫자는 `0`부터 `9`, 10 이상의 수는 `A`부터 `F`를 사용하여 나타낸다.

### base=2
비트 연산 디버깅에 주로 쓰인다. 숫자는  `0` 또는 `1`이 될 수 있습니다.

### base=36
사용할 수 있는 `base` 중 최댓값으로, `0..9`와 `A..Z`를 사용해 숫자를 표현한다. 알파벳 전체가 숫자를 나타내는 데 사용된다.  `36` 베이스는 url을 줄이는 것과 같이 숫자로 된 긴 식별자를 짧게 줄일 때 유용하다.
```js run
alert(123456..toString(36)); // 2n9c
```

---
:warning: 점 두 개와 메서드 호출

위 예시처럼 숫자를 대상으로 메서드  `toString`을 직접 호출하고 싶다면 숫자 다음에 점 두 개  `..`를 붙여야 한다.

`123456.toString(36)`처럼 점을 한 개만 사용하면, 첫 번째 점 이후는 소수부로 인식되어 에러가 발생할 수 있다. 점을 하나 더 추가하면 자바스크립트는 소수부가 없다고 판단하고 함수를 호출한다.

`(123456).toString(36)`도 가능하다.

---

## 어림수 구하기
<strong>어림수(rounding)</strong>와 관련된 내장 함수 중에서 많이 사용되는 것은 다음과 같다.
- `Math.ceil`: 올림
- `Math.floor`: 내림
- `Math.round`: 반올림
- `Math.trunc`: 소수부를 무시한다. **Internet Explorer**에서는 지원하지 않는 기능이다.

각 내장 함수의 결과를 표로 정리하면 다음과 같다.
|      |`Math.ceil`|`Math.floor`|`Math.round`|`Math.trunc`|
|------|------------|-----------|------------|------------|
|`3.1` |`4`         |`3`        |`3`         |`3`         |
|`3.6` |`4`         |`3`        |`4`         |`3`         |
|`-1.1`|`-1`        |`-2`       |`-1`        |`-1`        |
|`-1.6`|`-1`        |`-2`       |`-2`        |`-1`        |

소수점 `n`번째 수를 기준으로 어림수를 구하고 싶을 때 사용할 수 있는 방법은 두 가지가 있다.
### 1. 곱하기와 나누기
```js run
let num = 1.23456;

alert(Math.floor(num * 100) / 100); // 1.23456 -> 123.456 -> 123 -> 1.23
```

### 2. 소수점 `n` 번째 수까지의 **반올림**을 구한 후 이를 **문자형**으로 반환해주는 메서드인 [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed)를 사용한다.
```js
let num = 12.36;
alert(num.toFixed(1)); // '12.4'
```
`toFixed`를 사용할 때 주의할 점은 이 메서드의 반환 값이 문자열이라는 것이다. 소수부의 길이가 인수보다 작으면 끝에 0이 추가된다.
```js
let num = 12.34;
alert(num.toFixed(5)); // '12.34000', 소수부의 길이가 5이기 때문에 남은 공간에는 0이 추가되었다.
```
참고로, `+num.toFixed(5)`처럼 단항 덧셈 연산자를 앞에 붙이거나 `Number()`를 이용하면 문자형의 숫자를 숫자형으로 변환할 수 있다.

## 부정확한 계산
숫자는 내부적으로 64비트 형식 IEEE-754으로 표현되기 때문에 숫자를 저장하려면 정확히 64비트가 필요하다. 64비트 중 52비트는 숫자를 저장하는 데 사용되고, 11비트는 소수점 위치를(정수는 0), 1비트는 부호를 저장하는 데 사용된다.

꽤 자주 발생하는 현상인 정밀도 손실(loss of precision)이라는 것이 있다.
```js
alert(0.1 + 0.2 == 0.3); // false
alert(0.1 + 0.2); // 0.30000000000000004
```
10진법에서 1/3을 정확히 나타낼 수 없듯이, 2진법을 사용하는 컴퓨터에서는 0.1 또는 0.2를 **정확하게** 저장할 수 없다. IEEE-754에서는 가능한 가장 가까운 숫자로 반올림하는 방법을 사용해 이런 문제를 해결한다. 그런데 반올림 규칙을 적용하면 발생하는 '작은 정밀도 손실’을 우리가 볼 수는 없지만 실제로 손실은 발생한다.
```js run
alert(0.1.toFixed(20)); // 0.10000000000000000555
```
이 문제를 해결하는 가장 신뢰할만한 방법은 toFixed(n) 메서드를 사용해 어림수를 만드는 것이다.
```js
let sum = 0.1 + 0.2;
alert(sum.toFixed(2)); // 0.30
alert(+sum.toFixed(2)); // 0.3
```
숫자에 임시로 10의 거듭제곱을 곱하여 정수로 바꾸고, 원하는 연산을 한 후 다시 곱했던 수로 나누는 것도 하나의 방법이 될 수 있다. 정수를 대상으로 하는 수학 연산은 소수를 대상으로 하는 연산보다 에러가 적기 때문이다. 그런데 어쨌든 마지막에 나눗셈이 들어가기 때문에 소수가 다시 등장할 수 있다는 단점이 있다.
```js
alert((0.1 * 10 + 0.2 * 10) / 10); // 0.3
alert((0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
```
무한소수를 방지하는 완벽한 방법은 사실 없다. 필요할 때마다 '꼬리’를 잘라 어림수를 만드는 방법뿐이다.

---
:information_source: 정밀도 손실로 생기는 흥미로운 현상
```js
// 숫자가 스스로 증가했다.
alert(9999999999999999); // 10000000000000000이 출력된다.
```
문제의 원인은 정밀도 손실 때문이다. 실제 숫자를 저장하는 데에 사용되는 52비트에 위 숫자를 저장하기에는 공간이 모자라다. 따라서 최소 유효 숫자(the least significant digit)가 손실되어 버렸다.

---
:information_source: 두 종류의 0

자바스크립트 내부에서 숫자를 표현하는 방식 때문에 발생하는 또 다른 흥미로운 현상은  `0`과  `-0`이라는 두 종류의 0이 존재한다는 사실이다.

자바스크립트에선 숫자의 부호가 단일 비트에 저장되는데 0을 포함한 모든 숫자에 부호를 설정할 수도, 설정하지 않을 수도 있기 때문이다.

대부분의 연산은  `0`과  `-0`을 동일하게 취급하기 때문에 두 0의 차이는 두드러지지 않는다.

---

## isNaN과 isFinite
숫자형의 특수 숫자 값은 두 가지가 있다.
-   `Infinity`와  `-Infinity`
-   `NaN`: 에러를 나타내는 값이다.

특수 숫자와 관련된 특별한 함수는 다음과 같다.

### isNaN(value)
인수를 숫자로 변환한 다음 `NaN`인지 테스트한다.
```js
alert(isNaN(NaN)); // true
alert(isNaN('str')); // true
```
`NaN`은 `NaN` 자기 자신을 포함하여 그 어떤 값과도 같지 않다는 점에서 독특하다. 자기 자신에 대한 `===`도 `false`를 반환한다. 따라서 `NaN`을 판별할 때는 `isNaN` 함수를 사용해야 한다.
```js
alert(NaN === NaN); // false
```

### isFinite(value)
인수를 숫자로 변환하고, 변환한 숫자가 `NaN/Infinity/-Infinity`가 아닌 일반 숫자인 경우 `true`를 반환한다.
```js
alert(isFinite('15')); // true
alert(isFinite('str')); // false, NaN이기 때문이다.
alert(isFinite(Infinity)); // false, Infinity이기 때문이다.
```
`isFinite`는 문자열이 일반 숫자인지 검증하는 데 사용되곤 한다.
```js
let num = +prompt('숫자를 입력하세요.', '');

// 숫자가 아닌 값을 입력하거나 Infinity, -Infinity를 입력하면 false가 출력된다.
alert(isFinite(num));
```
빈 문자열이나 공백만 있는 문자열은 `isFinite`를 포함한 모든 숫자 관련 내장 함수에서 `0`으로 취급된다는 점을 주의해야 한다.

---
:information_source: `Object.is`와 비교하기

[`Object.is`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/is)는  `===`처럼 값을 비교할 때 사용되는 특별한 내장 메서드이다. 아래와 같은 두 가지 에지 케이스에서는  `===`보다 좀 더 신뢰할 만한 결과를 보여준다.

1.  `NaN`을 대상으로 비교할 때:  `Object.is(NaN, NaN) === true`
2.  `0`과  `-0`이 다르게 취급되어야 할 때:  `Object.is(0, -0) === false`이다. 숫자를 나타내는 비트가 모두 0이더라도 부호를 나타내는 비트가 다르므로  `0`과  `-0`은 사실 다른 값이긴 하다.

앞의 두 에지 케이스를 제외하면 `Object.is(a, b)`와  `a === b`의 결과는 같다.

이런 식의 비교는 자바스크립트 명세서에서 종종 찾아볼 수 있다. 내부 알고리즘에서 두 값을 비교해야 하는데, 비교 결과가 정확해야 하는 경우  `Object.is`를 사용한다. `Object.is`에서 사용되는 비교방식은 명세서에서  SameValue라고 부른다.

---

## parseInt와 parseFloat
단항 덧셈 연산자 `+` 또는 `Number()`를 사용하여 숫자형으로 변형할 때는 피연산자가 숫자가 아니면 형 변환이 실패한다.
```js
alert(+'100px'); // NaN
```

내장 함수 `parseInt`와 `parseFloat`은 앞에서부터 불가능할 때까지 문자열에서 숫자를 ‘읽는다'. 숫자를 읽는 도중 오류가 발생하면 이미 수집된 숫자를 반환한다. `parseInt`는 정수, `parseFloat`는 부동 소수점 숫자를 반환한다. 두 함수는 '약한' 형 변환을 해준다.
```js
alert(parseInt('100px')); // 100
alert(parseFloat('12.5em')); // 12.5

alert(parseInt('12.3')); // 12, 정수 부분만 반환된다.
alert(parseFloat('12.3.4')); // 12.3, 두 번째 점에서 숫자 읽기를 멈춘다.
```
```js
alert(parseInt('a123')); // NaN, a는 숫자가 아니므로 숫자를 읽기가 바로 중단된다.
```

---
:information_source: `parseInt(str, radix)`의 두 번째 인수

`parseInt()`의 두 번째 매개 변수는 선택적으로 사용할 수 있다. `radix`는 원하는 16진수, 2진수 등의 진수를 지정해 줄 때 사용한다.
```js
alert(parseInt('0xff', 16)); // 255
alert(parseInt('ff', 16)); // 255, 0x가 없어도 동작한다.

alert(parseInt('2n9c', 36)); // 123456
```
---

## 기타 수학 메서드
자바스크립트에서 제공하는 내장 객체 Math에는 다양한 수학 관련 메서드와 상수들이 들어있다.

### Math.random()
0 이상 1 미만의 난수를 반환한다.
```js
alert(Math.random()); // 0.1234567894322
alert(Math.random()); // 0.5435252343232
alert(Math.random()); // ... (무작위 수)
```

### Math.max(a, b, c...), Math.min(a, b, c...)
인수 중 최댓값/최솟값을 반환한다.
```js
alert(Math.max(3, 5, -10, 0, 1)); // 5
alert(Math.min(1, 2)); // 1
```

### Math.pow(n, power)
`n`을 `power`번 거듭제곱한 값을 반환한다.
```js
alert(Math.pow(2, 10)); // 2의 10제곱 = 1024
```

이 외의 다양한 함수와 상수는 [MDN 문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Math)를 참고한다.
