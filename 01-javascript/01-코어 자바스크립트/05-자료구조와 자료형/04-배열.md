# 배열
**순서가 있는 컬렉션**을 저장할 때는 **배열**을 사용하면 편리하다.

## 배열 선언
빈 배열을 만드는 방법은 아래 두 가지가 있다.
```js
let arr = new Array();
let arr = [];
```
대부분 두 번째 방법으로 배열을 선언하는데, 이때 대괄호 안에 초기 요소를 넣어주는 것도 가능하다.
```js
let fruits = ['사과', '오렌지', '자두'];
```
각 배열 요소에는 0부터 시작하는 숫자(**인덱스**)가 매겨져 있다. 이 숫자들은 배열 내 순서를 나타낸다.

배열 내 특정 요소를 얻고 싶다면 대괄호 안에 인덱스를 넣어주면 된다.
```js
let fruits = ['사과', '오렌지', '자두'];

alert(fruits[0]); // 사과
alert(fruits[1]); // 오렌지
alert(fruits[2]); // 자두
```
같은 방법으로 요소를 수정할 수 있다.
```js
fruits[2] = '배'; // 배열이 ['사과', '오렌지', '배']로 바뀐다.
```

새로운 요소를 배열에 추가하는 것도 가능하다.

```js
fruits[3] = '레몬'; // 배열이 ['사과', '오렌지', '배', '레몬']으로 바뀐다.
```

`length`를 사용하면 배열에 담긴 요소가 몇 개인지 알 수 있다.

```js
let fruits = ['사과', '오렌지', '자두'];

alert(fruits.length); // 3
```
`alert`를 사용해 요소 전체를 출력하는 것도 가능하다.
```js
let fruits = ['사과', '오렌지', '자두'];

alert(fruits); // 사과,오렌지,자두
```
배열 요소의 자료형에는 제약이 없다.
```js run no-beautify
// 요소에 여러 가지 자료형이 섞여 있다.
let arr = ['사과', { name: '이보라' }, true, function() { alert('안녕하세요.'); }];

// 인덱스가 1인 요소(객체)의 name 프로퍼티를 출력한다.
alert(arr[1].name); // 이보라

// 인덱스가 3인 요소(함수)를 실행한다.
arr[3](); // 안녕하세요.
```

---
:information_source: **trailing 쉼표**
배열의 마지막 요소는 객체와 마찬가지로 쉼표로 끝날 수 있다.
```js
let fruits = [
  '사과',
  '오렌지',
  '자두',
];
```
trailing(길게 늘어지는) 쉼표를 사용하면 모든 줄의 생김새가 유사해지기 때문에 요소를 넣거나 빼기가 쉬워진다.

---

## pop/push와 shift/unshift
<strong>큐(queue)</strong>는 배열을 사용해 만들 수 있는 대표적인 자료구조로, 배열과 마찬가지로 순서가 있는 컬렉션을 저장하는 데 사용한다. 큐에서 사용하는 주요 연산은 아래와 같다.
-   `push`: 맨 끝에 요소를 추가한다.
-   `shift`: 제일 앞 요소를 꺼내 제거한 후 남아있는 요소들을 앞으로 밀어준다. 이렇게 하면 두 번째 요소가 첫 번째 요소가 된다.

![queue](https://user-images.githubusercontent.com/95019875/156590982-ba8e25d8-a017-4768-aa98-94e3f02289af.svg)

배열은 큐 이외에  <strong>스택(stack)</strong>이라 불리는 자료구조를 구현할 때도 쓰입니다. 스택에서 사용하는 연산은 아래와 같습니다.
-   `push`: 요소를 스택의 끝에 집어넣는다.
-   `pop`: 스택의 끝 요소를 추출한다.

![stack](https://user-images.githubusercontent.com/95019875/156591014-ddddc6be-30f2-48b3-a11c-b38580880a06.svg)

큐는 먼저 집어넣은 요소가 먼저 나오기 때문에 큐는 선입선출(First-In-First-Out, FIFO) 자료구조라고 부른다. 반면 스택은 가장 나중에 집어넣은 요소가 먼저 나오기 때문에 후입선출(Last-In-First-Out, LIFO) 자료구조라고 부른다.

자바스크립트 배열을 사용하면 큐나 스택을 모두 만들 수 있다. 이 자료구조들은 배열의 처음이나 끝에 요소를 더하거나 뺄 때 사용한다. 이렇게 처음이나 끝에 요소를 더하거나 빼주는 연산을 제공하는 자료구조를 컴퓨터 과학 분야에서는 <strong>데큐(deque, Double Ended Queue)</strong>라고 부른다.

### pop/push는 배열의 끝에 무언가를 해주는 메서드이다.

`pop`: 배열의 끝 요소를 제거하고, 제거한 요소를 반환한다.
```js
let fruits = ['사과', '오렌지', '배'];

alert(fruits.pop()); // 배열에서 '배'를 제거하고 제거된 요소를 얼럿창에 띄운다.

alert(fruits); // 사과, 오렌지
```
`push`: 배열의 끝에 요소를 추가한다. 여러 개도 가능하다.
```js
let fruits = ['사과', '오렌지'];

fruits.push('배');

alert(fruits); // 사과, 오렌지, 배
```
`fruits.push(...)`를 사용하는 것은 `fruits[fruits.length] = ...` 코드와 동일할 기능을 한다.
<br></br>

### shift/unshift는 배열의 앞에 무언가를 해주는 메서드이다.

`shift`: 배열의 앞 요소를 제거하고, 제거한 요소를 반환한다.
```js
let fruits = ['사과', '오렌지', '배'];

alert(fruits.shift()); // 배열에서 '사과'를 제거하고 제거된 요소를 얼럿창에 띄운다.

alert(fruits); // 오렌지, 배
```
`unshift`: 배열의 앞에 요소를 추가한다. 여러 개도 가능하다.
```js run
let fruits = ['오렌지', '배'];

fruits.unshift('사과');

alert(fruits); // 사과, 오렌지, 배
```

## 배열의 내부 동작 원리
배열은 **특별한 종류의 객체**이며 객체처럼 동작한다.

배열은 객체와 마찬가지로 참조를 통해 복사된다.
```js
let fruits = ['바나나']
let arr = fruits; // 참조를 복사한다(두 변수가 같은 객체를 참조한다).

alert(arr === fruits); // true
arr.push('배'); // 참조를 이용해 배열을 수정한다.
alert(fruits); // 바나나, 배 - 요소가 두 개가 되었다.
```

배열에서 객체와 동일하게 `this`를 사용할 수 있다.
```js
let arr = ['a', 'b'];

arr.push(function() {
  alert(this);
})

arr[2](); // a,b,function(){...}
```

배열을 '순서가 있는 자료의 컬렉션’처럼 다루지 않고 '일반 객체'처럼 다루면 자바스크립트의 최적화 기법이 동작하지 않아 배열 특유의 이점이 사라진다. 배열을 다음과 같이 사용하는 것은 잘못된 사용법이다.
-   `arr.test = 5`  같이 숫자가 아닌 값을 프로퍼티 키로 사용하는 경우
-   `arr[0]`과  `arr[1000]`만 추가하고 그사이에 아무런 요소도 없는 경우
-   `arr[1000]`,  `arr[999]`같이 요소를 역순으로 채우는 경우

임의의 키를 사용해야 한다면 배열보다는 일반 객체 `{}`가 적합한 자료구조일 확률이 높다.

## 성능
`push`/`pop`은 빠르지만 `shift`/`unshift`는 느리다. `shift`/`unshift`는 요소 전체를 이동시켜야 되기 때문이다.

## 반복문
`for`문은 배열을 순회할 때 쓰는 가장 오래된 방법이다. 순회할 때 인덱스를 사용한다. 가장 빠른 방법이며 오래된 브라우저와도 호환된다.
```js
let arr = ['사과', '오렌지', '배'];

for (let i = 0; i < arr.length; i++) {
  alert(arr[i]);
}
```
배열에 적용할 수 있는 또 다른 순회 문법으로는 `for..of`가 있다.
```js run
let fruits = ['사과', '오렌지', '자두'];

// 배열 요소를 대상으로 반복 작업을 수행한다.
for (let fruit of fruits) {
  alert(fruit);
}
```
`for..of`를 사용하면 현재 요소의 인덱스는 얻을 수 없고 값만 얻을 수 있다.`for..of`가 문법도 짧고 사용이 간편하기 때문에, 인덱스가 필요한 상황이 아니면 **`for..of`를 사용**하는 것을 권장한다.

배열은 객체형에 속하므로 `for..in`을 사용하는 것도 가능하다.
```js
let arr = ['사과', '오렌지', '배'];

for (let key in arr) {
  alert(arr[key]); // 사과, 오렌지, 배
}
```
그런데 `for..in`은 다음과 같은 특징을 지니기 때문에 **배열에 `for..in`을 사용해서는 안 된다.**
1. `for..in` 반복문은 '모든 프로퍼티'를 대상으로 순회합니다. 키가 숫자가 아닌 프로퍼티도 순회 대상에 포함된다.
	객체 중에는 배열과 유사한 형태를 보이는 ‘유사 배열(array-like)’ 객체가 존재한다. 유사 배열 객체에는 배열과 달리 키가 숫자형이 아닌 프로퍼티와 메서드가 있을 수 있다. `for..in`을 유사 배열 객체에 사용하면 이 모든 것을 대상으로 순회가 이뤄져서 ‘필요 없는’ 프로퍼티들이 문제를 일으킬 가능성이 생긴다.

2. `for..in`  반복문은 객체에 사용하는 것에 최적화되어 있어서 배열에 사용하면 객체 대비 10~100배 정도 느리다.

## length 프로퍼티
배열에 무언가 조작을 가하면 `length` 프로퍼티가 자동으로 갱신된다. 

`length` 프로퍼티는 배열 내 요소의 개수가 아니라 **가장 큰 인덱스에 1을 더한 값**이다. 따라서 배열에 요소가 하나만 있는데, 이 요소의 인덱스가 아주 큰 수라면 배열의 `length` 프로퍼티도 아주 커진다.
```js
let fruits = [];
fruits[123] = '사과';

alert(fruits.length); // 124
```
물론 배열을 이렇게 사용해서는 안 된다.

`length`  프로퍼티의 또 다른 독특한 특징은 **쓰기가 가능하다**는 것이다.

`length`의 값을 수동으로 증가시키면 아무 일도 일어나지 않는 반면, 값을 감소시키면 배열이 잘리는 것을 확인할 수 있다. 짧아진 배열은 다시 되돌릴 수 없다.
```js
let arr = [1, 2, 3, 4, 5];

arr.length = 2; // 요소를 2개만 남긴다.
alert(arr); // [1, 2]

arr.length = 5; // 원래 길이로 되돌린다.
alert(arr[3]); // undefined, 삭제된 기존 요소들이 복구되지 않는다.
```
이런 특징을 활용해 `arr.length = 0;`을 사용하면 아주 간단하게 배열을 비울 수 있다.

## new Array()
`new Array()` 문법을 사용해도 배열을 만들 수 있다.
```js
let arr = new Array('사과', '배', '기타');
```
대괄호 `[]`를 사용하면 더 짧은 문법으로 배열을 만들 수 있기 때문에 `new Array()`는 잘 사용되지 않는다.

숫자형 인수 하나를 넣어서 `new Array`를 호출하면 배열이 만들어지는데, 이 배열에는 요소가 없는 반면 길이는 인수와 같아진다.
```js
let arr = new Array(2);

alert(arr[0]); // undefined가 출력된다. 요소가 하나도 없는 배열이 만들어졌다.
alert(arr.length); // 길이는 2이다.
```
이런 뜻밖의 상황을 마주치지 않기 위해 `new Array`의 기능을 잘 알지 않는 한 대부분의 개발자는 대괄호를 써서 배열을 만든다.

## 다차원 배열
배열 역시 배열의 요소가 될 수 있다. 이런 배열을 가리켜 다차원 배열(multidimensional array)이라 부른다. 다차원 배열은 행렬을 저장하는 용도로 쓰인다.
```js
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert(matrix[1][1]); // 5
```

## toString
배열에는 `toString` 메서드가 구현되어 있어서 이를 사용하면 요소를 쉼표로 구분한 문자열이 반환된다. 쉼표 뒤에 빈 칸이 없는 것을 주의해야 한다.
```js run
let arr = [1, 2, 3];

alert(arr); // 1,2,3
alert(String(arr) === '1,2,3'); // true
```
배열에는 `Symbol.toPrimitive`나 `valueOf` 메서드가 없다. 따라서 아래 예시에서는 문자열로의 형 변환이 일어나 `[]`는 빈 문자열, `[1]`은 문자열 `'1'`, `[1,2]`는 문자열 `'1,2'`로 변환된다.
```js
alert([] + 1); // '1'
alert([1] + 1); // '11'
alert([1,2] + 1); // '1,21'
```
