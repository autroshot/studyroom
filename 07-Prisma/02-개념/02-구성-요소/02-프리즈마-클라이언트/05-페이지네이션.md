# 페이지네이션

Prisma Client는 오프셋 페이지네이션과 커서 기반 페이지네이션을 모두 지원한다.

## 오프셋 페이지네이션

오프셋 페이지 매김은 `skip`과 `take`를 사용하여 특정 수의 결과를 건너뛰고 제한된 범위를 선택한다.

다음 쿼리는 처음 3개의 `Post` 레코드를 건너뛰고 레코드 4 - 7을 반환한다.

```js
const results = await prisma.post.findMany({
  skip: 3,
  take: 4,
})
```

<이미지>

결과 페이지를 구현하려면 페이지 수에 페이지당 표시할 결과 수를 곱한 값을 `skip`하면 된다.

### ✔ 오프셋 페이지네이션의 장점

- 모든 페이지로 즉시 이동할 수 있다.

  예를 들어 200개의 레코드를 `skip`하고  10개의 레코드를 `take`할 수 있으며 결과 집합의 21페이지로 바로 이동하는 것을 시뮬레이션한다. (밑에 있는 SQL은 `OFFSET`을 사용) 커서 기반 페이지네이션에서는 불가능하다.

- 모든 정렬 순서로 동일한 결과 집합에 페이지를 매길 수 있다.

  예를 들어 이름별로 정렬된 `User` 레코드 목록의 21페이지로 이동할 수 있다. 고유한 순차 열을 기준으로 정렬해야 하는 커서 기반 페이지네이션에서는 불가능하다.

### ✘ 오프셋 페이지네이션의 단점

- 오프셋 페이지네이션은 데이터베이스 수준에서 확장되지 않는다.

  예를 들어 200,000개의 레코드를 건너뛰고 처음 10개를 취하는 경우 데이터베이스는 요청한 10개를 반환하기 전에 여전히 처음 200,000개의 레코드를 순회해야 한다. 이는 성능에 부정적인 영향을 미친다.

### 오프셋 페이지네이션 유스 케이스

- 작은 결과 집합의 얕은 페이지 매김.

  예를 들어 작성자별로 `Post` 레코드를 필터링하고 결과에 페이지를 매길 수 있는 블로그 인터페이스가 있다.

#### 예시: 필터링 및 오프셋 페이지네이션

다음 쿼리는 `email` 필드에 `prisma.io`가 포함된 모든 레코드를 반환한다. 쿼리는 처음 40개 레코드를 건너뛰고 레코드 41 - 50을 반환한다.

```js
const results = await prisma.post.findMany({
  skip: 40,
  take: 10,
  where: {
    email: {
      contains: 'prisma.io',
    },
  },
})
```

#### 예시: 정렬 및 오프셋 페이지네이션

다음 쿼리는 `email` 필드에 `Prisma`가 포함된 모든 레코드를 반환하고 `title` 필드를 기준으로 결과를 정렬한다. 쿼리는 처음 200개의 레코드를 건너뛰고 레코드 201 - 220을 반환한다.

```js
const results = await prisma.post.findMany({
  skip: 200,
  take: 20,
  where: {
    email: {
      contains: 'Prisma',
    },
  },
  orderBy: {
    title: 'desc',
  },
})
```

