# 페이지네이션

프리즈마 클라이언트는 오프셋 페이지네이션과 커서 기반 페이지네이션을 모두 지원합니다.

## 오프셋 페이지네이션

오프셋 페이지 매김은 `skip`과 `take`를 사용하여 특정 수의 결과를 건너뛰고 제한된 범위를 선택합니다.

다음 쿼리는 처음 3개의 `Post` 레코드를 건너뛰고 레코드 4 - 7을 반환합니다.

```js
const results = await prisma.post.findMany({
  skip: 3,
  take: 4,
})
```

![offset-skip-take](https://user-images.githubusercontent.com/95019875/184620183-33a1c3d6-ac83-4f27-9797-1af88693b89d.png)

결과 페이지를 구현하려면 페이지 수에 페이지당 표시할 결과 수를 곱한 값을 `skip`하면 됩니다.

### ✔ 오프셋 페이지네이션의 장점

- 모든 페이지로 즉시 이동할 수 있습니다.

  예를 들어 200개의 레코드를 `skip`하고  10개의 레코드를 `take`할 수 있으며 결과 집합의 21페이지로 바로 이동하는 것을 시뮬레이션합니다. (밑에 있는 SQL은 `OFFSET`을 사용) 커서 기반 페이지네이션에서는 불가능합니다.

- 모든 정렬 순서로 동일한 결과 집합에 페이지를 매길 수 있습니다.

  예를 들어 이름별로 정렬된 `User` 레코드 목록의 21페이지로 이동할 수 있습니다. 고유한 순차 열을 기준으로 정렬해야 하는 커서 기반 페이지네이션에서는 불가능합니다.

### ✘ 오프셋 페이지네이션의 단점

- 오프셋 페이지네이션은 데이터베이스 수준에서 확장되지 않습니다.

  예를 들어 200,000개의 레코드를 건너뛰고 처음 10개를 취하는 경우 데이터베이스는 요청한 10개를 반환하기 전에 여전히 처음 200,000개의 레코드를 순회해야 합니다. 이는 성능에 부정적인 영향을 미칩니다.

### 오프셋 페이지네이션 유스 케이스

- 작은 결과 집합의 얕은 페이지 매김.

  예를 들어 작성자별로 `Post` 레코드를 필터링하고 결과에 페이지를 매길 수 있는 블로그 인터페이스가 있습니다.

#### 예시: 필터링 및 오프셋 페이지네이션

다음 쿼리는 `email` 필드에 `prisma.io`가 포함된 모든 레코드를 반환합니다. 쿼리는 처음 40개 레코드를 건너뛰고 레코드 41 - 50을 반환합니다.

```js
const results = await prisma.post.findMany({
  skip: 40,
  take: 10,
  where: {
    email: {
      contains: 'prisma.io',
    },
  },
})
```

#### 예시: 정렬 및 오프셋 페이지네이션

다음 쿼리는 `email` 필드에 `Prisma`가 포함된 모든 레코드를 반환하고 `title` 필드를 기준으로 결과를 정렬합니다. 쿼리는 처음 200개의 레코드를 건너뛰고 레코드 201 - 220을 반환합니다.

```js
const results = await prisma.post.findMany({
  skip: 200,
  take: 20,
  where: {
    email: {
      contains: 'Prisma',
    },
  },
  orderBy: {
    title: 'desc',
  },
})
```

## 커서 기반 페이지네이션

커서 기반  페이지네이션은 주어진 **커서** 전후에 제한된 결과 집합을 반환하기 위해 `cursor`와 `take`를 사용합니다. 커서는 결과 집합에서 사용자의 위치를 북마크로 지정하며 ID 또는 타임스탬프와 같은 고유한 순차적 열이어야 합니다.

다음 예시에서는 `"Prisma"` 단어가 포함된 처음 4개의 `Post` 레코드를 반환하고 마지막 레코드의 ID를 `myCursor`로 저장합니다.

> **참고**
>
> 다음은 첫 번째 쿼리이므로 전달할 커서가 없습니다.

```js
const firstQueryResults = await prisma.post.findMany({
  take: 4,
  where: {
    title: {
      contains: 'Prisma' /* 선택적 필터 */,
    },
  },
  orderBy: {
    id: 'asc',
  },
})

// 결과 집합에서의 위치를 북마크로 지정합니다.
// 이 경우에는 4개의 목록에서 마지막 게시물의 ID입니다.

const lastPostInResults = firstQueryResults[3] // 기억: 기반이 없는 인덱스
const myCursor = lastPostInResults.id // 예시: 29
```

다음 다이어그램은 처음 4개 결과 또는 페이지 1의 ID를 보여줍니다. 다음 쿼리의 커서는 **29**입니다.

![cursor-1](https://user-images.githubusercontent.com/95019875/184620222-b3740047-4c8d-48d4-b29a-d62c48271d64.png)

두 번째 쿼리는 **제공된 커서 뒤에**(즉, **29** 보다 큰 ID) `"Prisma"`라는 단어가 포함된 처음 4개의 `Post` 레코드를 반환합니다.

```js
const secondQueryResults = await prisma.post.findMany({
  take: 4,
  skip: 1, // 커서를 스킵합니다.
  cursor: {
    id: myCursor,
  },
  where: {
    title: {
      contains: 'Prisma' /* 선택적 필터 */,
    },
  },
  orderBy: {
    id: 'asc',
  },
})

const lastPostInResults = secondQueryResults[3] // 기억: 기반이 없는 인덱스
const myCursor = lastPostInResults.id // 예시: 52
```

다음 다이어그램은 ID가 **29**인 레코드 **다음**의 처음 4개 `Post` 레코드를 보여줍니다. 이 예시에서 새 커서는 **52**입니다.

![cursor-2](https://user-images.githubusercontent.com/95019875/184620239-8bf444d6-b994-4daa-8486-e934a58ca1e7.png)

### 자주 묻는 질문

#### 항상 skip: 1을 넣어야 하나요?

`skip: 1`을 넣지 않으면 결과 집합에 이전 커서가 포함됩니다.

첫 번째 쿼리는 4개의 결과를 반환하고 커서는 **29**입니다.

![cursor-1](https://user-images.githubusercontent.com/95019875/184620302-2cfdfa64-ec05-4d58-8f68-c59c2f4f10ff.png)

`skip: 1`가 없으면 두 번째 쿼리는 커서를 포함한 4개의 결과를 반환합니다.

![cursor-3](https://user-images.githubusercontent.com/95019875/184620309-5d1bff6d-fda2-4a73-91ee-c92024957ccb.png)

`skip: 1`인 경우에는 커서가 포함되지 않습니다.

![cursor-2](https://user-images.githubusercontent.com/95019875/184620356-8087bde4-0704-453d-9549-3d31170b87cc.png)

원하는 페이지네이션 동작에 따라 `skip: 1`을 선택하거나 선택하지 않을 수 있습니다.

#### 커서 값을 추측할 수 있나요?

다음 커서의 값을 추측하면 결과 집합에서 알 수 없는 위치로 페이지를 이동합니다. ID는 순차적이지만 증가 비율을 예측할 수 없습니다. (특히 필터링된 결과 집합에서 `2`, `20`, `32`가 `1`, `2`, `3`보다 가능성이 높음)

#### 커서 기반 페이지네이션은 밑에 있는 데이터베이스의 커서 개념을 사용하나요?

그렇지 않습니다. 커서 페이지 페이지네이션은 밑에 있는 데이터베이스(예: 포스트그레SQL)의 커서를 사용하지 않습니다.

### ✔ 커서 기반 페이지네이션의 장점

- 커서 기반 페이지네이션은 일정한 기준을 가집니다. 밑에 있는 SQL은 `OFFSET`을 사용하지 않고 대신 `cursor` 값보다 큰 ID를 가진 모든 `Post` 레코드를 쿼리합니다.

### ✘ 커서 기반 페이지네이션의 단점

- 고유한 순차적 열이어야 하는 커서를 기준으로 정렬해야 합니다.
- 커서만으로는 특정 페이지로 이동할 수 없습니다. 예를 들어 1 - 399페이지를 먼저 요청하지 않고는 400페이지(페이지 크기 20)의 시작을 나타내는 커서를 정확하게 예측할 수 없습니다.

### 커서 기반 페이지네이션 유스 케이스

- 무한 스크롤 - 예를 들어 날짜/시간 내림차순으로 블로그 게시물을 정렬하고 한 번에 10개의 블로그 게시물을 요청합니다.
- 예를 들어 장기 실행 데이터 내보내기의 일부로 전체 결과 집합을 일괄적으로 페이징합니다.

#### 예시: 필터링 및 커서 기반 페이지네이션

```js
const secondQuery = await prisma.post.findMany({
  take: 4,
  cursor: {
    id: myCursor,
  },
|  where: {
|    title: {
|      contains: 'Prisma' /* 선택적 필터 */,
|    },
  },
  orderBy: {
    id: 'asc',
  },
})
```

#### 정렬 및 커서 기반 페이지네이션

커서 기반 페이지네이션을 사용하려면 ID 또는 타임스탬프와 같은 고유한 순차적 열을 기준으로 정렬해야 합니다. 커서라고 부르는 이 값은 결과 집합에서 위치를 북마크로 지정하고 다음 집합을 요청할 수 있게 합니다.

#### 예: 커서 기반 페이지네이션으로 뒤로 페이징

뒤로 페이지를 지정하려면 `take`를 음수 값으로 설정합니다.

다음 쿼리는 커서를 제외하고 `id`가 200보다 작은 `Post` 레코드 4개를 반환합니다.

```js
const myOldCursor = 200

const firstQueryResults = await prisma.post.findMany({
  take: -4,
  skip: 1,
  cursor: {
    id: myOldCursor,
  },
  where: {
    title: {
      contains: 'Prisma' /* 선택적 필터 */,
    },
  },
  orderBy: {
    id: 'asc'
  }
})
```

