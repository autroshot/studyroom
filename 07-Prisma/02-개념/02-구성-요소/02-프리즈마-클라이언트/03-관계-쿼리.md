# 관계 쿼리

프리즈마 클라이언트의 주요 기능은 둘 이상의 모델 간의 관계를 쿼리하는 기능이다. 관계 쿼리에는 다음이 포함된다.

- `select`와 `include`를 통한 중첩 읽기(가끔 열렬한 로딩으로도 부름)
- 트랜잭션 보장이 포함 된 중첩 쓰기
- 관련 레코드 필터링하기

프리즈마 클라이언트에는 관계를 넘나들 수 있는 유연한 API도 있다.

## 중첩 읽기

중첩 읽기를 사용하면 사용자 및 해당 사용자의 게시물과 같은 데이터베이스의 여러 테이블에서 관련 데이터를 읽을 수 있다.

중첩 읽기는 다음을 포함한다.

- `include`를 사용해 쿼리 응답에 사용자의 게시물이나 프로필과 같은 관련 레코드를 포함한다.
- 중첩 `select`를 사용해 관련 레코드의 특정 필드를 포함한다. `include` 내부에 `select`를 중첩할 수도 있다.

다음 예시에서는 단일 사용자와 해당 사용자의 게시물을 반환한다.

```js
const getUser = await prisma.user.findUnique({
  where: {
    id: 19,
  },
  include: {
    posts: true,
  },
})
```

결과:

```js
{
  id: 19,
  name: null,
  email: 'emma@prisma.io',
  profileViews: 0,
  role: 'USER',
  coinflips: [],
  posts: [
    {
      id: 20,
      title: 'My first post',
      published: true,
      authorId: 19,
      comments: null,
      views: 0,
      likes: 0
    },
    {
      id: 21,
      title: 'How to make cookies',
      published: true,
      authorId: 19,
      comments: null,
      views: 0,
      likes: 0
    }
  ]
}
```

### 특정 관계의 모든 필드 포함하기

다음 예시에서는 `title` 필드에 `cookies` 단어가 포함된 모든 게시물과 각 게시물의 작성자를 반환한다. 결과에는 모든 작성자 필드가 포함된다.

```js
const getPosts = await prisma.post.findMany({
  where: {
    title: {
      contains: 'cookies',
    },
  },
  include: {
    author: true, // Return all fields
  },
})
```

결과:

```js
[
  {
    id: 17,
    title: 'How to make cookies',
    published: true,
    authorId: 16,
    comments: null,
    views: 0,
    likes: 0,
    author: {
      id: 16,
      name: null,
      email: 'orla@prisma.io',
      profileViews: 0,
      role: 'USER',
      coinflips: [],
    },
  },
  {
    id: 21,
    title: 'How to make cookies',
    published: true,
    authorId: 19,
    comments: null,
    views: 0,
    likes: 0,
    author: {
      id: 19,
      name: null,
      email: 'emma@prisma.io',
      profileViews: 0,
      role: 'USER',
      coinflips: [],
    },
  },
]
```

### 깊이 중첩된 관계 포함하기

관계의 관계를 포함하도록 `include` 옵션을 중첩할 수 있다.

다음 예시는 사용자의 게시물과 각 게시물의 카테고리를 반환한다.

```js
const user = await prisma.user.findMany({
  include: {
    posts: {
      include: {
        categories: true,
      },
    },
  },
})
```

결과:

```js
{
    "id": 40,
    "name": "Yvette",
    "email": "yvette@prisma.io",
    "profileViews": 0,
    "role": "USER",
    "coinflips": [],
    "testing": [],
    "city": null,
    "country": "Sweden",
    "posts": [
        {
            "id": 66,
            "title": "How to make an omelette",
            "published": true,
            "authorId": 40,
            "comments": null,
            "views": 0,
            "likes": 0,
            "categories": [
                {
                    "id": 3,
                    "name": "Easy cooking"
                }
            ]
        },
        {
            "id": 67,
            "title": "How to eat an omelette",
            "published": true,
            "authorId": 40,
            "comments": null,
            "views": 0,
            "likes": 0,
            "categories": []
        }
    ]
}
```

### 특정 관계 필드 선택하기

중첩 `select`를 사용하여 반환할 관계 필드의 하위 집합을 선택할 수 있다.

예를 들어 다음 쿼리는 사용자의 관련 게시물의 `name`과 `title`를 반환한다.

```js
const getUser = await prisma.user.findUnique({
  where: {
    id: 19,
  },
  select: {
    name: true,
    posts: {
      select: {
        title: true,
      },
    },
  },
})
```

결과:

```js
{
  name: "Elsa",
  posts: [ { title: 'My first post' }, { title: 'How to make cookies' } ]
}
```

`include` 내부에 `select`를 중첩할 수도 있다.

다음 예시에서는 각 게시물의 모든 `User` 필드와 `title` 필드를 반환한다.

```js
const getUser = await prisma.user.findUnique({
  where: {
    id: 1,
  },
  // select: { name: true } <-- 불가능
  include: {
    posts: {
      select: {
        title: true,
      },
    },
  },
})
```

결과:

```js
{
  "id": 1,
  "name": null,
  "email": "martina@prisma.io",
  "profileViews": 0,
  "role": "USER",
  "coinflips": [],
  "posts": [
    {
      "title": "How to grow salad"
    },
    {
      "title": "How to ride a horse"
    }
  ]
}
```

`select`와 `include`는 같은 수준에서는 사용할 수 없다. 즉, 사용자의 게시물을 `include`하고 각 게시물의 제목을 `select`하면, 사용자의 `email`만 `select`할 수 없다.

```js
// The following query returns an exception
const getUser = await prisma.user.findUnique({
  where: {
    id: 19,
  },
|  select: { // 불가능하다.
    email:  true
  }
|  include: { // 불가능하다.
    posts: {
      select: {
        title: true
      }
    }
  },
})
```

결과:

```js
Invalid `prisma.user.findUnique()` invocation:

{
  where: {
    id: 19
  },
  select: {
  ~~~~~~
    email: true
  },
  include: {
  ~~~~~~~
    posts: {
      select: {
        title: true
      }
    }
  }
}


Please either use `include` or `select`, but not both at the same time.
```

대신 중첩 `select` 옵션을 사용한다.

```js
const getUser = await prisma.user.findUnique({
  where: {
    id: 19,
  },
  select: {
    // 이것은 잘 동작한다.
    email: true,
    posts: {
      select: {
        title: true,
      },
    },
  },
})
```

### 관계 카운트

2.20.0 이상에서는 필드와 함께 관계 카운트를 `include`하거나 `select`할 수 있다. (예: 사용자의 게시물 수)

### 관계 목록 필터링하기

`select`를 사용해 관련 레코드(예: 사용자의 게시물)에서 데이터의 하위 집합을 반환할 때 해당 관계 목록을 필터링하고 정렬할 수 있다.

예를 들어 `prisma.io` 이메일 주소로 모든 사용자를 쿼리하고 게시된 게시물의 제목을 선택할 수 있다.

`email`에 `prisma.io`가 포함된 모든 `User` 레코드를 반환하고 아직 게시되지 않은 모든 `Post` 레코드의 `title`을 선택한다.

```js
const result = await prisma.user.findMany({
  where: {
    email: {
      contains: 'prisma.io',
    },
  },
  select: {
    posts: {
      where: {
        published: false,
      },
      orderBy: {
        title: 'asc',
      },
      select: {
        title: true,
      },
    },
  },
})
```

`post` 모델의 속성을 사용하여 동일한 쿼리를 작성할 수 있다.

```js
const result = await prisma.post.findMany({
  where: {
    published: false,
    User: {
      email: {
        contains: 'prisma.io',
      },
    },
  },
  select: {
    title: true,
  },
})
```

## 중첩 쓰기

중첩 쓰기를 사용하면 단일 트랜잭션으로 데이터베이스에 관계형 데이터를 쓸 수 있다.

예를 들어 다음 중첩 쓰기는 하나의 `User`와 두 개의 관련 `Post` 레코드를 생성한다.

```js
const createUserAndPost = await prisma.user.create({
  data: {
    email: 'elsa@prisma.io',
    name: 'Elsa Prisma',
    posts: {
      create: [
        { title: 'How to make an omelette' },
        { title: 'How to eat an omelette' },
      ],
    },
  },
})
```

중첩 쓰기는 다음과 같다.

- 단일 프리즈마 클라이언트 쿼리에서 여러 테이블의 데이터 생성, 업데이트, 삭제에 대한 트랜잭션 보장을 제공한다. 쿼리의 일부가 실패하면(예: 사용자 생성은 성공하지만 게시물 생성은 실패) 프리즈마 클라이언트는 모든 변경 사항을 롤백시킨다.
- 데이터 모델에서 지원하는 모든 수준의 중첩을 지원한다.
- 모델의 생성 또는 업데이트 쿼리를 사용할 때 관계 필드에 사용할 수 있다. 다음 섹션에서는 쿼리별로 사용할 수 있는 중첩 쓰기 옵션을 보여준다.

자세한 내용은 [원문](https://www.prisma.io/docs/concepts/components/prisma-client/relation-queries#nested-writes)을 확인한다.

## 관계 필터

### -대다 관계 필터링

프리즈마 클라이언트는 관계의 -대다 측면에서 관련 레코드의 속성으로 레코드를 필터링하는 `some`, `every`, `none` 옵션을 제공한다. 예를 들어 게시물 속성을 기반으로 사용자를 필터링할 수 있다.

예를 들어:

| 요구 사항                                                    | 사용할 쿼리 옵션               |
| :----------------------------------------------------------- | :----------------------------- |
| 게시되지 않은 `Post` 레코드가 하나 이상 있는 모든 `User` 목록을 원한다. | `some` 게시물이 게시되지 않음  |
| 게시되지 않은 `Post` 레코드가 없는 모든 `User` 목록을 원한다. | `none` 게시물이 게시되지 않음  |
| 게시되지 않은 `Post` 레코드만 있는 모든 `User` 목록을 원한다. | `every` 게시물이 게시되지 않음 |

예를 들어 다음 쿼리는다음 기준을 충족하는  `User` 결과를 반환한다.

- 조회수가 100회를 넘는 게시물이 없다.
- 모든 게시물에 좋아요가 50개 이하이다.

```js
const users = await prisma.user.findMany({
  where: {
    posts: {
      none: {
        views: {
          gt: 100,
        },
      },
      every: {
        likes: {
          lte: 50,
        },
      },
    },
  },
})
```

### -대일 관계 필터링

프리즈마 클라이언트는 관계의 -대일 측면에서 관련 레코드의 속성으로 레코드를 필터링하는 `is`, `isNot` 옵션을 제공한다. 예를 들어 작성자의 속성을 기반으로 게시물을 필터링할 수 있다.

예를 들어 다음 쿼리는 다음 기준을 충족하는 `Post` 레코드를 반환한다.

- 작성자 이름은 Bob이 아니다
- 작성자는 40세 이상이다.

```js
const users = await prisma.post.findMany({
  where: {
    author: {
      isNot: {
        name: "Bob"
      },
      is: {
        age: {
          gt: 40
        }
      }
    }
  }
})
```

### 관련 레코드가 있는지 여부로 필터링

[관계 카운트로 필터링](https://github.com/prisma/prisma/issues/3821)하는 것은 아직 지원되지 않는다. 그러나 레코드에 관련 레코드가 있는지 여부를 필터링할 수 있다.

예를 들어 다음 쿼리는 `none`을 사용해 게시물이 없는 모든 사용자를 반환한다.

```js
const usersWithZeroPosts = await prisma.user.findMany({
  where: {
    posts: {
      none: {},
    },
  },
})
```

다음 쿼리는 하나 이상의 게시물이 있는 모든 사용자를 반환한다.

```js
const usersWithSomePosts = await prisma.user.findMany({
  where: {
    posts: {
      some: {},
    },
  },
})
```

## 유연한 API

유연한(fluent) API를 사용하면 함수 호출을 통해 모델의 관계를 유연하게 탐색할 수 있다. 마지막 함수 호출은 전체 쿼리의 반환 타입을 결정한다. (각 유형 주석은 코드 스니펫 아래에 추가되어 명시적임)

이 쿼리는 특정 `User`를 기준으로 모든 `Post` 레코드를 반환한다.

```js
const postsByUser: Post[] = await prisma.user
  .findUnique({ where: { email: 'alice@prisma.io' } })
  .posts()
```

이는 다음 `findMany` 쿼리와 동일한다.

```js
const postsByUser = await prisma.post.findMany({
  where: { author: { email: 'alice@prisma.io' } },
})
```

위 쿼리 간의 주요 차이점은, 유연한 API 호출은 두 개의 개별 데이터베이스 쿼리로 변환되는 반면 다른 하나는 단일 쿼리만 생성한다는 것이다. ([GitHub 이슈](https://github.com/prisma/prisma/issues/1984) 참조)

이 요청은 특정 게시물의 모든 카테고리를 반환한다.

```js
const categoriesOfPost: Category[] = await prisma.post
  .findUnique({ where: { id: 1 } })
  .categories()
```

원하는 만큼 쿼리를 체이닝할 수 있다.

이 예시에서 연결은 `Profile`에서 시작하여 `User`, `Post`로 이동한다.

```js
const posts: Post[] = await prisma.profile
  .findUnique({ where: { id: 1 } })
  .user()
  .posts()
```

체이닝에 대한 유일한 요구 사항은 이전 함수 호출이 **단일 객체**(예: `findUnique` 쿼리 또는 `profile.user()` 같은 -대일 관계에서 반환됨)만 반환해야 한다는 것이다.

`findMany`는 단일 객체가 아닌 목록을 반환 하기 때문에 다음 쿼리는 불가능하다.

```js
// 이 쿼리는 올바르지 않다.
const posts = await prisma.user.findMany().posts()
```

