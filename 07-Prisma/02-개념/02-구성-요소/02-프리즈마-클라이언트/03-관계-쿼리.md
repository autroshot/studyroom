# 관계 쿼리

Prisma Client의 주요 기능은 둘 이상의 모델 간의 관계를 쿼리하는 기능이다. 관계 쿼리에는 다음이 포함된다.

- `select`와 `include`를 통한 중첩 읽기(가끔 열렬한 로딩으로도 부름)
- 트랜잭션 보장이 포함 된 중첩 쓰기
- 관련 레코드 필터링하기

Prisma Client에는 관계를 넘나들 수 있는 유연한 API도 있다.

## 중첩 읽기

중첩 읽기를 사용하면 사용자 및 해당 사용자의 게시물과 같은 데이터베이스의 여러 테이블에서 관련 데이터를 읽을 수 있다.

중첩 읽기는 다음을 포함한다.

- `include`를 사용해 쿼리 응답에 사용자의 게시물이나 프로필과 같은 관련 레코드를 포함한다.
- 중첩 `select`를 사용해 관련 레코드의 특정 필드를 포함한다. `include` 내부에 `select`를 중첩할 수도 있다.

다음 예시에서는 단일 사용자와 해당 사용자의 게시물을 반환한다.

```js
const getUser = await prisma.user.findUnique({
  where: {
    id: 19,
  },
  include: {
    posts: true,
  },
})
```

결과:

```js
{
  id: 19,
  name: null,
  email: 'emma@prisma.io',
  profileViews: 0,
  role: 'USER',
  coinflips: [],
  posts: [
    {
      id: 20,
      title: 'My first post',
      published: true,
      authorId: 19,
      comments: null,
      views: 0,
      likes: 0
    },
    {
      id: 21,
      title: 'How to make cookies',
      published: true,
      authorId: 19,
      comments: null,
      views: 0,
      likes: 0
    }
  ]
}
```

### 특정 관계의 모든 필드 포함하기

다음 예시에서는 `title` 필드에 `cookies` 단어가 포함된 모든 게시물과 각 게시물의 작성자를 반환한다. 결과에는 모든 작성자 필드가 포함된다.

```js
const getPosts = await prisma.post.findMany({
  where: {
    title: {
      contains: 'cookies',
    },
  },
  include: {
    author: true, // Return all fields
  },
})
```

결과:

```js
[
  {
    id: 17,
    title: 'How to make cookies',
    published: true,
    authorId: 16,
    comments: null,
    views: 0,
    likes: 0,
    author: {
      id: 16,
      name: null,
      email: 'orla@prisma.io',
      profileViews: 0,
      role: 'USER',
      coinflips: [],
    },
  },
  {
    id: 21,
    title: 'How to make cookies',
    published: true,
    authorId: 19,
    comments: null,
    views: 0,
    likes: 0,
    author: {
      id: 19,
      name: null,
      email: 'emma@prisma.io',
      profileViews: 0,
      role: 'USER',
      coinflips: [],
    },
  },
]
```

### 깊이 중첩된 관계 포함하기

관계의 관계를 포함하도록 `include` 옵션을 중첩할 수 있다.

다음 예시는 사용자의 게시물과 각 게시물의 카테고리를 반환한다.

```js
const user = await prisma.user.findMany({
  include: {
    posts: {
      include: {
        categories: true,
      },
    },
  },
})
```

결과:

```js
{
    "id": 40,
    "name": "Yvette",
    "email": "yvette@prisma.io",
    "profileViews": 0,
    "role": "USER",
    "coinflips": [],
    "testing": [],
    "city": null,
    "country": "Sweden",
    "posts": [
        {
            "id": 66,
            "title": "How to make an omelette",
            "published": true,
            "authorId": 40,
            "comments": null,
            "views": 0,
            "likes": 0,
            "categories": [
                {
                    "id": 3,
                    "name": "Easy cooking"
                }
            ]
        },
        {
            "id": 67,
            "title": "How to eat an omelette",
            "published": true,
            "authorId": 40,
            "comments": null,
            "views": 0,
            "likes": 0,
            "categories": []
        }
    ]
}
```

### 특정 관계 필드 선택하기

중첩 `select`를 사용하여 반환할 관계 필드의 하위 집합을 선택할 수 있다.

예를 들어 다음 쿼리는 사용자의 관련 게시물의 `name`과 `title`를 반환한다.

```js
const getUser = await prisma.user.findUnique({
  where: {
    id: 19,
  },
  select: {
    name: true,
    posts: {
      select: {
        title: true,
      },
    },
  },
})
```

결과:

```js
{
  name: "Elsa",
  posts: [ { title: 'My first post' }, { title: 'How to make cookies' } ]
}
```

`include` 내부에 `select`를 중첩할 수도 있다.

다음 예시에서는 각 게시물의 모든 `User` 필드와 `title` 필드를 반환한다.

```js
const getUser = await prisma.user.findUnique({
  where: {
    id: 1,
  },
  // select: { name: true } <-- 불가능
  include: {
    posts: {
      select: {
        title: true,
      },
    },
  },
})
```

결과:

```js
{
  "id": 1,
  "name": null,
  "email": "martina@prisma.io",
  "profileViews": 0,
  "role": "USER",
  "coinflips": [],
  "posts": [
    {
      "title": "How to grow salad"
    },
    {
      "title": "How to ride a horse"
    }
  ]
}
```

`select`와 `include`는 같은 수준에서는 사용할 수 없다. 즉, 사용자의 게시물을 `include`하고 각 게시물의 제목을 `select`하면, 사용자의 `email`만 `select`할 수 없다.

```js
// The following query returns an exception
const getUser = await prisma.user.findUnique({
  where: {
    id: 19,
  },
|  select: { // 불가능하다.
    email:  true
  }
|  include: { // 불가능하다.
    posts: {
      select: {
        title: true
      }
    }
  },
})
```

결과:

```js
Invalid `prisma.user.findUnique()` invocation:

{
  where: {
    id: 19
  },
  select: {
  ~~~~~~
    email: true
  },
  include: {
  ~~~~~~~
    posts: {
      select: {
        title: true
      }
    }
  }
}


Please either use `include` or `select`, but not both at the same time.
```

대신 중첩 `select` 옵션을 사용한다.

```js
const getUser = await prisma.user.findUnique({
  where: {
    id: 19,
  },
  select: {
    // 이것은 잘 동작한다.
    email: true,
    posts: {
      select: {
        title: true,
      },
    },
  },
})
```

### 관계 카운트

2.20.0 이상에서는 필드와 함께 관계 카운트를 `include`하거나 `select`할 수 있다. (예: 사용자의 게시물 수)

### 관계 목록 필터링하기

`select`를 사용해 관련 레코드(예: 사용자의 게시물)에서 데이터의 하위 집합을 반환할 때 해당 관계 목록을 필터링하고 정렬할 수 있다.

예를 들어 `prisma.io` 이메일 주소로 모든 사용자를 쿼리하고 게시된 게시물의 제목을 선택할 수 있다.

`email`에 `prisma.io`가 포함된 모든 `User` 레코드를 반환하고 아직 게시되지 않은 모든 `Post` 레코드의 `title`을 선택한다.

```js
const result = await prisma.user.findMany({
  where: {
    email: {
      contains: 'prisma.io',
    },
  },
  select: {
    posts: {
      where: {
        published: false,
      },
      orderBy: {
        title: 'asc',
      },
      select: {
        title: true,
      },
    },
  },
})
```

`post` 모델의 속성을 사용하여 동일한 쿼리를 작성할 수 있다.

```js
const result = await prisma.post.findMany({
  where: {
    published: false,
    User: {
      email: {
        contains: 'prisma.io',
      },
    },
  },
  select: {
    title: true,
  },
})
```

## 중첩 쓰기

중첩 쓰기를 사용하면 단일 트랜잭션으로 데이터베이스에 관계형 데이터를 쓸 수 있다.

예를 들어 다음 중첩 쓰기는 하나의 `User`와 두 개의 관련 `Post` 레코드를 생성한다.

```js
const createUserAndPost = await prisma.user.create({
  data: {
    email: 'elsa@prisma.io',
    name: 'Elsa Prisma',
    posts: {
      create: [
        { title: 'How to make an omelette' },
        { title: 'How to eat an omelette' },
      ],
    },
  },
})
```

중첩 쓰기는 다음과 같다.

- 단일 Prisma Client 쿼리에서 여러 테이블의 데이터 생성, 업데이트, 삭제에 대한 트랜잭션 보장을 제공한다. 쿼리의 일부가 실패하면(예: 사용자 생성은 성공하지만 게시물 생성은 실패) Prisma Client는 모든 변경 사항을 롤백시킨다.
- 데이터 모델에서 지원하는 모든 수준의 중첩을 지원한다.
- 모델의 생성 또는 업데이트 쿼리를 사용할 때 관계 필드에 사용할 수 있다. 다음 섹션에서는 쿼리별로 사용할 수 있는 중첩 쓰기 옵션을 보여준다.

자세한 내용은 [원문](https://www.prisma.io/docs/concepts/components/prisma-client/relation-queries#nested-writes)을 확인한다.
