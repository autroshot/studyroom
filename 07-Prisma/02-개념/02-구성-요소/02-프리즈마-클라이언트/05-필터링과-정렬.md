# 필터링과 정렬

프리즈마 클라이언트는 `where`과 `orderBy` 쿼리 옵션을 사용하여 필터링과 정렬을 지원한다.

## 필터링

프리즈마 클라이언트를 사용하면 관련 모델을 포함한 모델 필드의 모든 조합에서 레코드를 필터링할 수 있으며 다양한 필터 조건을 지원한다.

아래의 쿼리는 다음과 같다.

- 다음이 포함된 모든 `User` 레코드를 반환
  - `prisma.io`로 끝나는 이메일 주소
  - 하나 이상의 게시된 게시물 (관계 쿼리)
- 모든 `User` 필드를 반환
- `published`가 `true`인 모든 관련 `Post` 레코드를 포함

```js
const result = await prisma.user.findMany({
  where: {
    email: {
      endsWith: 'prisma.io',
    },
    posts: {
      some: {
        published: true,
      },
    },
  },
  include: {
    posts: {
      where: {
        published: true,
      },
    },
  },
})
```

결과:

```js
[
  {
    id: 1,
    name: 'Ellen',
    email: 'ellen@prisma.io',
    role: 'USER',
    posts: [
      {
        id: 1,
        title: 'How to build a house',
        published: true,
        authorId: 1,
      },
      {
        id: 2,
        title: 'How to cook kohlrabi',
        published: true,
        authorId: 1,
      },
    ],
  },
]
```

### 필터 조건과 연산자

`startsWith`, `contains` 같은 [연산자의 전체 목록](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#filter-conditions-and-operators)은 프리즈마 클라이언트 문서를 참고한다.

#### 연산자 결합하기

연산자(예: `NOT`, `OR`)를 사용해 조건의 조합으로 필터링할 수 있다.

다음 쿼리는 `"prisma.io"`나 `"gmail.com"`로 끝나지만 `"hotmail.com"`로 끝나지 않는 `email`을 가진 모든 사용자를 반환한다.

```js
const result = await prisma.user.findMany({
  where: {
    OR: [
      {
        email: {
          endsWith: 'prisma.io',
        },
      },
      { email: { endsWith: 'gmail.com' } },
    ],
    NOT: {
      email: {
        endsWith: 'hotmail.com',
      },
    },
  },
  select: {
    email: true,
  },
})
```

결과:

```js
[{ email: 'yewande@prisma.io' }, { email: 'raheem@gmail.com' }]
```

### 관계 필터링

프리즈마 클라이언트는 관련 레코드에 대한 필터링을 지원한다.

예를 들어 다음 스키마에서 한 사용자는 많은 블로그 게시물을 가질 수 있다고 가정해 보겠다.

```js
model User {
  id    Int     @id @default(autoincrement())
  name  String?
  email String  @unique
  posts Post[] // User can have many posts
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  published Boolean @default(true)
  author    User    @relation(fields: [authorId], references: [id])
  authorId  Int
}
```

`User`와 `Post` 사이의 일대다 관계를 통해 게시물을 기반으로 사용자를 쿼리할 수 있다.

예를 들어 다음 쿼리는 하나 이상(`some`)의 게시물에 10회 이상의 조회수가 있는 모든 사용자를 반환한다.

```js
const result = await prisma.user.findMany({
  where: {
    posts: {
      some: {
        views: {
          gt: 10,
        },
      },
    },
  },
})
```

작성자의 속성을 기반으로 게시물을 쿼리할 수도 있습니다.

예를 들어 다음 쿼리는 작성자의 `email`에 `"prisma.io"`을 포함된 모든 게시물을 반환합니다 .

```js
const res = await prisma.post.findMany({
  where: {
    author: {
      email: {
        contains: 'prisma.io',
      },
    },
  },
})
```

### 스칼라 목록/배열 필터링

스칼라 목록(예: `String[]`)에는 특별한 [필터 조건](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#scalar-list-filters) 집합이 있다.

예를 들어 다음 쿼리는 `tags` 배열에 `databases`가 포함된 모든 게시물을 반환한다.

```js
const posts = await client.post.findMany({
  where: {
    tags: {
      has: 'databases',
    },
  },
})
```

### 대소문자를 구분하지 않는 필터링

대소문자를 구분하지 않는 필터링은 PostgreSQL 및 몽고DB 공급자를 위한 기능으로 사용할 수 있다. MySQL, MariaDB, Microsoft SQL Server는 기본적으로 대소문자를 구분하지 않는다.

대소문자를 구분하지 않는 필터링을 사용하려면 특정 필터에 `mode` 프로퍼티를 추가하고 `insensitive`를 지정한다.

```js
const users = await prisma.user.findMany({
  where: {
    email: {
      endsWith: 'prisma.io',
      mode: 'insensitive', // 기본값: default
    },
    name: {
      equals: 'Archibald', // 기본 모드
    },
  },
})
```

참고: [대소문자 구분](https://www.prisma.io/docs/concepts/components/prisma-client/case-sensitivity)

## 정렬

`orderBy`를 사용해 특정 필드 또는 필드 집합을 기준으로 레코드 목록 또는 중첩 레코드 목록을 정렬한다.

예를 들어 다음 쿼리는 `role`과 `name`으로 정렬된 모든 `User` 레코드와 `title`로 정렬된 각 사용자의 게시물을 반환한다.

```js
const usersWithPosts = await prisma.user.findMany({
  orderBy: [
    {
      role: 'desc',
    },
    {
      name: 'desc',
    },
  ],
  include: {
    posts: {
      orderBy: {
        title: 'desc',
      },
      select: {
        title: true,
      },
    },
  },
})
```

결과:

```js
[
  {
    "email": "kwame@prisma.io",
    "id": 2,
    "name": "Kwame",
    "role": "USER",
    "posts": [
      {
        "title": "Prisma in five minutes"
      },
      {
        "title": "Happy Table Friends: Relations in Prisma"
      }
    ]
  },
  {
    "email": "emily@prisma.io",
    "id": 5,
    "name": "Emily",
    "role": "USER",
    "posts": [
      {
        "title": "Prisma Day 2020"
      },
      {
        "title": "My first day at Prisma"
      },
      {
        "title": "All about databases"
      }
    ]
  }
]
```

> **참고**
>
> [중첩된 레코드 목록을 정렬](./03-관계-쿼리.md/#관계-목록-필터링하기)하여 ID별로 단일 레코드를 검색할 수도 있다.

### 관계로 정렬하기

관계의 프로퍼티를 기준으로 정렬할 수도 있다.

예를 들어 다음 쿼리는 작성자의 이메일 주소를 기준으로 모든 게시물을 정렬한다.

```js
const posts = await prisma.post.findMany({
  orderBy: {
    author: {
      email: 'asc',
    },
  },
})
```

### 관계 그룹 값으로 정렬하기

2.19.0 이상에서는 관련 레코드 카운트를 기준으로 정렬할 수 있다.

예를 들어 다음 쿼리는 관련 게시물 수를 기준으로 사용자를 정렬한다.

```js
const getActiveUsers = await prisma.user.findMany({
  take: 10,
  orderBy: {
    posts: {
      _count: 'desc',
    },
  },
})
```

> **참고**
>
> 현재 [관계 카운트를 반환](https://github.com/prisma/prisma/issues/5079)하는 것은 불가능하다.

### null 레코드를 처음이나 마지막으로 정렬하기

버전 4.1.0 이상에서는 `null` 필드가 있는 레코드가 처음이나 마지막에 나타나도록 결과를 정렬할 수 있다.

이 기능을 사용하려면 `schema.prisma` 파일의 `generator` 블록에서 `orderByNulls` 미리보기 기능을 활성화한다.

```js
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["orderByNulls"]
}
```

> **참고**
>
> 선택 스칼라 필드에서만 `null`로 정렬할 수 있다. 필수 필드 또는 관계 필드에서 `null`을 기준으로 정렬하려고 하면 프리즈마 클라이언트에서 [P2009 오류](https://www.prisma.io/docs/reference/api-reference/error-reference#p2009)가 발생한다.

예시: `updatedAt`가 선택 필드인 경우, 다음 쿼리는 `updatedAt`로 게시물을 정렬하며 `null` 레코드는 끝에 정렬한다.

```js
const posts = await prisma.post.findMany({
  orderBy: {
    updatedAt: { sort: 'asc', nulls: 'last' },
  },
})
```

