# 집계, 그룹화, 요약

프리즈마 클라이언트를 사용하면 레코드를 카운트하고 숫자 필드를 집계하고 고유한 필드 값을 선택할 수 있습니다.

## 집계

프리즈마 클라이언트를 사용하면 모델의 숫자 필드(`Int`와 `Float` 등)에 `aggregate`를 수행할 수 있습니다.

다음 쿼리는 모든 사용자의 평균 연령을 반환합니다.

```js
const aggregations = await prisma.user.aggregate({
  _avg: {
    age: true,
  },
})

console.log('Average age:' + aggregations._avg.age)
```

집계를 필터링 및 정렬과 결합할 수 있습니다.

예를 들어 다음 쿼리는 사용자의 평균 연령을 반환합니다.

- `age` 오름차순으로 정렬
- `email`에는 `prisma.io`가 포함되야 함
- 10명의 사용자로 제한

```js
const aggregations = await prisma.user.aggregate({
  _avg: {
    age: true,
  },
  where: {
    email: {
      contains: 'prisma.io',
    },
  },
  orderBy: {
    age: 'asc',
  },
  take: 10,
})

console.log('Average age:' + aggregations._avg.age)
```

### 집계 값은 null을 허용한다

2.21.0 이상에서 `null`이 될 수 있는 필드에 대한 집계는 `number`나 `null`를 반환할 수 있습니다. 레코드가 발견되지 않으면 항상 `0`을 반환하는 `count`는 제외합니다.

`age`에 `null`을 허용하는 스키마에 대한 다음 쿼리를 가정해 보겠습니다.

```js
const aggregations = await prisma.user.aggregate({
  _avg: {
    age: true,
  },
  _count: {
    age: true,
  },
})
```

결과:

```js
{
  _avg: {
    age: null
  },
  _count: {
    age: 9
  }
}
```

쿼리는 다음 시나리오 중 하나일 경우 `{ _avg: { age: null } }`을 반환합니다.

- 사용자가 없음
- 모든 사용자의 `age` 필드 값이 `null`

이를 통해 실제 집계 값(0일 수 있음)과 데이터 없음을 구별할 수 있습니다.

## Group by

프리즈마 클라이언트의 `groupBy`를 사용하면 하나 이상의 필드 값(예: `country`, `country`와 `city`)을 기준으로 **레코드를 그룹화**하고 특정 도시에 거주하는 사람들의 평균 연령을 찾는 것과 같이 각 그룹에 대한 **집계를 수행**할 수 있습니다. `groupBy`는 2.20.0 이상에서 GA(Generally Available)입니다.

다음 예시에서는 모든 사용자를 `country` 필드별로 그룹화하고 각 국가의 총 프로필 조회 수를 반환합니다.

```js
const groupUsers = await prisma.user.groupBy({
  by: ['country'],
  _sum: {
    profileViews: true,
  },
})
```

결과:

```js
[
  { country: 'Germany', _sum: { profileViews: 126 } },
  { country: 'Sweden', _sum: { profileViews: 0 } },
]
```

### `groupBy`와 필터링

`groupBy`는 두 가지 수준의 필터링, `where`과 `having`을 지원합니다.

#### `where`로 레코드 필터링하기

`where`을 사용해 **그룹화하기 전에** 모든 레코드를 필터링할 수 있습니다.

다음 예시는 국가별로 사용자를 그룹화하고 프로필 보기를 합산하지만 이메일 주소에 `prisma.io`가 들어있는 사용자만 포함합니다.

```js
const groupUsers = await prisma.user.groupBy({
  by: ['country'],
  where: {
    email: {
      contains: 'prisma.io',
    },
  },
  _sum: {
    profileViews: true,
  },
})
```

#### `having`으로 그룹 필터링하기

`having`을 사용해 개별 레코드가 아닌 필드의 합계 또는 평균과 같은 집계 값으로 **전체 그룹**을 필터링합니다.

예를 들어 평균 `profileViews`가 100보다 큰 그룹만 반환합니다. 

```js
const groupUsers = await prisma.user.groupBy({
  by: ['country'],
  where: {
    email: {
      contains: 'prisma.io',
    },
  },
  _sum: {
    profileViews: true,
  },
  having: {
    profileViews: {
      _avg: {
        gt: 100,
      },
    },
  },
})
```

##### `having` 유스 케이스

`having`의 주 유스 케이스는 집계를 필터링하는 것입니다. 그룹화 하기 전에 `where`을 사용해 데이터 세트의 크기를 최대한 줄이는 것이 좋다. 이렇게 하면 ✔ 데이터베이스가 반환해야 하는 레코드 수가 줄어들고 ✔ 인덱스가 사용되기 때문입니다.

예를 들어 다음 쿼리는 스웨덴이나 가나 출신이 아닌 모든 사용자를 그룹화합니다.

```js
const fd = await prisma.user.groupBy({
  by: ['country'],
  where: {
    country: {
      notIn: ['Sweden', 'Ghana'],
    },
  },
  _sum: {
    profileViews: true,
  },
  having: {
    profileViews: {
      _min: {
        gte: 10,
      },
    },
  },
})
```

다음 쿼리는 동일한 결과를 달성하지만 그룹화 후에 가나의 사용자를 제외합니다. 이것은 어떤 이점도 제공하지 않으며 권장되지 않습니다.

```js
const groupUsers = await prisma.user.groupBy({
  by: ['country'],
  where: {
    country: {
      not: 'Sweden',
    },
  },
  _sum: {
    profileViews: true,
  },
  having: {
    country: {
      not: 'Ghana',
    },
    profileViews: {
      _min: {
        gte: 10,
      },
    },
  },
})
```

> **참고**
>
> `having` 내에서는 `by`에서 사용 가능한 집계 값 또는 필드만 필터링할 수 있습니다.

### `groupBy`와 `orderBy`

`groupBy`와 `orderBy`를 결합할 때 다음 제약 조건이 적용됩니다.

- `by`에 있는 필드에 `orderBy`할 수 있습니다.
- 집계를 `orderBy`할 수 있습니다. (2.21.0 이상에서 미리보기 기능)
- `skip`, `take`와 함께 `groupBy`를 사용하는 경우, 쿼리에 반드시 `orderBy`가 포함되야 합니다.

#### 집계 그룹별 정렬하기

집계 그룹별로 정렬할 수 있습니다. 버전 2.21.0에서 관계형 데이터베이스의 집계된 그룹과 함께 `orderBy`를 사용하는 것을 지원하고, 3.4.0에서 몽고DB에 대한 해당 기능을 지원합니다.

다음 예시에서는 해당 그룹의 사용자 수를 기준으로 각 `city` 그룹을 정렬합니다. (가장 큰 그룹이 앞에 옴)

```js
const groupBy = await prisma.user.groupBy({
  by: ['city'],
  _count: {
    city: true,
  },
  orderBy: {
    _count: {
      city: 'desc',
    },
  },
})
```

결과:

```js
[
  { city: 'Berlin', count: { city: 3 } },
  { city: 'Paris', count: { city: 2 } },
  { city: 'Amsterdam', count: { city: 1 } },
]
```

#### 필드별 정렬

다음 쿼리는 국가별로 그룹을 정렬하는데, 처음 두 그룹은 건너뛰고 세 번째와 네 번째 그룹을 반환합니다.

```js
const groupBy = await prisma.user.groupBy({
  by: ['country'],
  _sum: {
    profileViews: true,
  },
  orderBy: {
    country: 'desc',
  },
  skip: 2,
  take: 2,
})
```

### 자주 묻는 질문

#### `groupBy`와 `select`를 함께 사용할 수 있나요?

불가능합니다. 그러나 `by`에 포함된 모든 필드 는 자동으로 반환됩니다.

#### `where`을 사용하는 것과 `groupBy`와 `having`을 사용하는 것의 차이점은 무엇인가요?

`where`는 그룹화하기 전에 모든 레코드를 필터링합니다. `having`은 전체 그룹을 필터링하며 해당 그룹에 있는 특정 필드의 평균 또는 합계와 같은 집계 필드 값에 대한 필터링을 지원합니다.

#### `groupby`와 `distinct`의 차이점은 무엇인가요?

`distinct`, `groupBy` 둘 다 하나 이상의 고유한 필드 값으로 레코드를 그룹화합니다. `groupBy`는 각 그룹 내에서 데이터를 집계할 수 있습니다. 덴마크 게시물의 평균 조회수를 반환하는 것이 그 예입니다. 반면 `distinct`는 그렇지 않습니다.

## 카운트

`count`를 사용해 레코드 또는 `null`이 아닌 필드 값의 수를 셉니다.

다음 예시 쿼리는 모든 사용자를 셉니다.

```js
const userCount = await prisma.user.count()
```

### 관계 카운트

관계를 세는 기능은 버전 2.20.0 이상에서 사용할 수 있습니다.

관계의 수(예: 사용자의 게시물 수)를 반환하려면 다음과 같이 중첩된 `select`에 `_count` 매개변수를 사용합니다.

```js
const usersWithCount = await prisma.user.findMany({
  include: {
    _count: {
      select: { posts: true },
    },
  },
})
```

결과:

```js
{ id: 1, _count: { posts: 3 } },
{ id: 2, _count: { posts: 2 } },
{ id: 3, _count: { posts: 2 } },
{ id: 4, _count: { posts: 0 } },
{ id: 5, _count: { posts: 0 } }
```

`_count` 매개변수

- `include` 또는 `select` 최상위 수준에서 사용 가능
- 레코드를 반환하는 모든 쿼리와 함께 사용 가능 (`delete`, `update`, `findFirst`) 
- 여러 관계의 수를 반환할 수 있음

#### `include`를 사용하여 관계 카운트

다음 쿼리는 결과에 각 사용자의 게시물 수를 포함합니다.

```js
const usersWithCount = await prisma.user.findMany({
  include: {
    _count: {
      select: { posts: true },
    },
  },
})
```

결과:

```js
{ id: 1, _count: { posts: 3 } },
{ id: 2, _count: { posts: 2 } },
{ id: 3, _count: { posts: 2 } },
{ id: 4, _count: { posts: 0 } },
{ id: 5, _count: { posts: 0 } }
```

#### `select`를 사용하여 관계 카운트

다음 쿼리는 `select`를 사용해 각 사용자의 게시물 수를 반환하고 다른 필드는 반환하지 않습니다.

```js
const usersWithCount = await prisma.user.findMany({
  select: {
    _count: {
      select: {
        posts: true,
        recipes: true,
      },
    },
  },
})
```

결과:

```js
{
  _count: {
    posts: 3,
    recipes: 9
  }
}
```

### `null`이 아닌 필드 값 카운트

2.15.0 이상에서는 모든 레코드와 `null`이 아닌 필드 값의 모든 인스턴스를 계산할 수 있습니다.

아래 쿼리는 다음의 수를 반환합니다.

- 모든 `User` 기록 (`_all`)
- `null`이 아닌 모든 `name` 값 (고유 값이 아닌 `null`이 아닌 값)

```js
const userCount = await prisma.user.count({
  select: {
    _all: true, // Count all records
    name: true, // Count all non-null field values
  },
})
```

결과:

```js
{ _all: 30, name: 10 }
```

### 필터링된 카운트

`count`는 필터링을 지원합니다.

다음 예시 쿼리는 프로필 보기가 100개 이상인 모든 사용자를 셉니다.

```js
const userCount = await prisma.user.count({
  where: {
    profileViews: {
      gte: 100,
    },
  },
})
```

다음 예시 쿼리는 특정 사용자의 게시물을 셉니다.

```js
const postCount = await prisma.post.count({
  where: {
    authorId: 29,
  },
})
```

## 고유하게 선택하기

프리즈마 클라이언트를 사용하면 프리즈마 쿼리 응답이나 `findMany` 쿼리에 `distinct`를 사용해 중복된 행을 필터링할 수 있습니다. `distinct`는 종종 테이블의 행에서 값의 특정 고유 조합을 식별하기 위해 `select`와 함께 사용됩니다.

다음 예시에서는 고유한 `name` 필드 값이 있는 모든 `User` 레코드의 모든 필드를 반환합니다.

```js
const result = await prisma.user.findMany({
  where: {},
  distinct: ['name'],
})
```

다음 예시는 고유한 `role` 필드 값(예 : `ADMIN`및 `USER`)을 반환합니다.

```js
const distinctRoles = await prisma.user.findMany({
  distinct: ['role'],
  select: {
    role: true,
  },
})
```

결과:

```js
[
  {
    role: 'USER',
  },
  {
    role: 'ADMIN',
  },
]
```

### `distinct`의 구현 방식

프리즈마의 `distinct` 옵션은 `SELECT DISTINCT` SQL을 사용하지 않습니다. 대신 다음을 사용합니다.

- `SELECT` 쿼리
- 고유한 선택을 위한 인메모리 후처리

`distinct` 쿼리의 일부로 `select`와 `include`를 지원하기 위해 이러한 방식으로 설계되었다.

다음 예시에서는 각 플레이어의 게임당 최고 점수를 반환하기 위해, `score`로 정렬된 고유 `gameId`와 `playerId`를 선택합니다. 쿼리는 `include`와 `select`를 사용하여 추가 데이터를 포함합니다.

- `score` 선택 (`Play` 필드에서)
- 관련 선수 이름 선택 (`Play`와 `User`의 관계에서)
- 관련 게임 이름 선택 ( `Play`와 `Game`의 관계에서)

예시 스키마:

```js
model User {
  id   Int     @id @default(autoincrement())
  name String?
  play Play[]
}

model Game {
  id   Int     @id @default(autoincrement())
  name String?
  play Play[]
}

model Play {
  id       Int   @id @default(autoincrement())
  score    Int?  @default(0)
  playerId Int?
  player   User? @relation(fields: [playerId], references: [id])
  gameId   Int?
  game     Game? @relation(fields: [gameId], references: [id])
}
```

쿼리:

```js
const distinctScores = await prisma.play.findMany({
  distinct: ['playerId', 'gameId'],
  orderBy: {
    score: 'desc',
  },
  select: {
    score: true,
    game: {
      select: {
        name: true,
      },
    },
    player: {
      select: {
        name: true,
      },
    },
  },
})
```

결과:

```js
[
  {
    score: 900,
    game: { name: 'Pacman' },
    player: { name: 'Bert Bobberton' }
  },
  {
    score: 400,
    game: { name: 'Pacman' },
    player: { name: 'Nellie Bobberton' }
  }
]
```

`select`와 `distinct`가 없는 쿼리는 다음을 반환합니다.

```js
[
  {
    gameId: 2,
    playerId: 5
  },
  {
    gameId: 2,
    playerId: 10
  }
]
```

