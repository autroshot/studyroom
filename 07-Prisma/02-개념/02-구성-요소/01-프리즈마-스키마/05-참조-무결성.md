# 참조 무결성

참조 무결성은 모든 참조가 유효함을 나타내는 데이터 집합의 속성이다. 참조 무결성을 위해서는 한 레코드가 다른 레코드를 참조하면 참조된 레코드가 존재해야 한다.

예를 들어 `Post` 모델이 작성자를 정의하면 작성자가 존재해야 한다.

참조 무결성은 참조를 손상시키는 변경을 방지하는 제약 조건과 레코드를 업데이트하거나 삭제할 때 실행되는 참조 작업을 정의하여 구현된다.

예를 들어 `Post` 모델의 경우 작성자가 삭제되면 어떻게 되는지 정의해야 한다.

프리즈마에서 참조 무결성은 `@relation` 속성을 사용하여 레코드 간의 관계를 정의하여 구현된다. 이 속성의 `onUpdate`와 `onDelete` 인수를 사용하여 관련 레코드를 업데이트하거나 삭제할 때 발생하는 참조 작업을 정의할 수 있다.

예를 들어 `Post`와 `User` 사이에 일대다 관계가 있는 다음 블로그 게시물 스키마를 사용하겠다.

```js
model Post {
  id       Int    @id @default(autoincrement())
  title    String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId Int
}

model User {
  id    Int    @id @default(autoincrement())
  posts Post[]
}
```

이 경우 `onDelete: Cascade` 인수는 `Cascade` 참조 작업을 지정하여 관련 `User`가 삭제되면 `Post`가 삭제된다. 지원되는 작업에 대한 자세한 내용은 [참조 작업](./06-관계/05-참조-작업.md)을 참고한다.

외래 키를 지원하는 관계형 데이터베이스를 사용하는 경우에는 밑에 있는 데이터베이스에서 참조 무결성을 처리할 수 있다. 이것은 SQL 데이터베이스를 사용할 때 프리즈마의 기본 옵션이다.

또는 프리즈마는 클라이언트에서 참조 무결성을 에뮬레이트할 수 있다. 이것은 외래 키를 지원하지 않는 몽고DB를 데이터베이스로 사용할 때 기본 옵션이다. 또한 [PlanetScale을 사용할 때](https://www.prisma.io/docs/guides/database/using-prisma-with-planetscale#differences-to-consider)와 같이 외래 키가 지원되지 않거나 다른 이유로 선호되는 경우(예: 확장 문제가 있는 경우) 관계형 데이터베이스에 대한 에뮬레이션을 활성화할 수 있다.

> **참고**
>
> 프리즈마 클라이언트에서 참조 무결성을 에뮬레이트하는 데에는 상당한 성능 영향이 있다. 밑에 있는 데이터베이스가 외래 키로 참조 무결성을 처리할 수 있는 경우에는 보통 그것을 이용한다.

## 데이터 소스에서 참조 무결성 설정하기

참조 무결성은 현재 미리보기 기능이다. 이를 활성화하려면 `schema.prisma`의 `generator` 블록 내부의 `previewFeatures` 목록에 추가한다.

```js
datasource db {
  provider             = "mysql"
  url                  = env("DATABASE_URL")
  referentialIntegrity = "prisma"
}

generator js {
  provider        = "prisma-client-js"
  previewFeatures = ["referentialIntegrity"]
}
```

사용된 참조 무결성 유형을 변경하려면 `datasource` 블록의 `referentialIntegrity` 매개변수를 업데이트하면 된다.

사용 가능한 옵션은 다음과 같다.

- `foreignKeys` - 외래 키를 사용하여 데이터베이스의 참조 무결성을 처리한다. 이것은 모든 SQL 데이터베이스 커넥터를 사용할 때의 기본 옵션이다.
- `prisma` - 프리즈마 클라이언트에서 참조 무결성을 에뮬레이트한다. 이것은 몽고DB 커넥터를 사용할 때의 기본(그리고 유일한) 옵션이다. 플래닛스케일 데이터베이스와 함께 MySQL 커넥터를 사용할 때도 이 옵션을 활성화해야 한다.

> **참고**
>
> 프리즈마 마이그레이트를 사용할 때 값을 `prisma`로 설정하면 다음 마이그레이션에서 이전에 생성된 모든 외래 키가 제거된다. 값을 `foreignKeys`로 설정하면 다음 마이그레이션에서 모든 관계에 대한 외래 키가 생성된다.

## 프리즈마에서 참조 무결성 처리하기

`referentialIntegrity` 매개변수에 `prisma` 옵션을 사용하여 프리즈마 클라이언트에서 참조 무결성이 에뮬레이트되는 경우, 현재 데이터 모델에서 사용할 수 있는 지원 참조 작업의 수가 감소한다.

| 참조 작업  | `onUpdate` | `onDelete` |
| :--------- | :--------- | :--------- |
| Restrict   | 아니요     | 예         |
| SetNull    | 아니요     | 예         |
| SetDefault | 아니요     | 아니요     |
| Cascade    | 아니요     | 예         |
| NoAction   | 아니요     | 예         |

현재 프리즈마는 참조 작업만 구현한다. 외래 키는 이러한 제약 조건을 위반하는 방식으로 데이터를 조작하는 것을 불가능하게 하는 제약 조건을 생성한다. 쿼리를 실행하는 대신 데이터베이스가 오류로 응답한다. 클라이언트에서 참조 무결성을 에뮬레이트하는 경우 이러한 제약 조건이 생성되지 않으므로 참조 작업을 `NoAction`으로 설정하면 참조 무결성을 손상시키는 것을 방지하기 위한 검사가 수행되지 않는다.

프리즈마에서 참조 무결성을 에뮬레이트할 때의 또 다른 제한 사항은 모든 `raw` 데이터베이스 쿼리가 참조 작업을 트리거하지 않으며, `raw` 쿼리를 사용하여 레코드를 삭제하거나 업데이트하는 경우 수동으로 처리해야 한다는 것이다.

`db pull` 명령을 사용할 때 기존 관계가 데이터 모델에 유지된다. 여기에는 몇 가지 주의 사항이 있다.

- 관계의 일부인 모델을 삭제하면 프리즈마는 관계를 삭제한다.
- 관계 필드에 사용된 스칼라 필드를 삭제하거나 이름을 바꾸면 관계 필드는 여전히 이전 버전을 참조하므로 유효성 검사 오류가 발생한다. 예를 들어 다음 데이터 모델을 사용한다.

    ```js
    model A {
      field Int
      b     B   @relation(fields: [field], references: [id])
    }
    ```

    `field`를 `renamedField`로 변경하면 다음 `db pull`에서 다음의 데이터 모델이 생성된다.

    ```js
    model A {
      renamedField Int
      b            B   @relation(fields: [field], references: [id])
    }
    ```

    이 경우 데이터 모델을 계속 사용하기 전에 `renamedField`을 가리키도록 관계를 수동으로 수정해야 한다.

## 외래 키로 참조 무결성 처리하기

`foreignKeys` 매개변수에 `referentialIntegrity` 옵션을 사용하여 데이터베이스에서 참조 무결성이 처리되는 경우 데이터베이스에서 지원하는 모든 참조 작업을 사용할 수 있다.

| 작업        | `onUpdate` | `onDelete` |
| :---------- | :--------- | :--------- |
| Restrict⟒   | 예         | 예         |
| SetNull     | 예         | 예         |
| SetDefault⟑ | 예         | 예         |
| Cascade     | 예         | 예         |
| NoAction    | 예         | 예         |

- ⟒ SQL Server에서는 지원되지 않음
- ⟑ MySQL/InnoDB에서는 지원되지 않음

이 모드에서 `raw` 데이터베이스 쿼리는 그에 따라 작업을 트리거한다.
