# ORM

프리즈마는 ORM(Object Relational Mapping)이다. 하지만 프리즈마는 전통적인 ORM과 근본적으로 다르며 기존의 ORM에서 많이 발생하는 문제가 없는 새로운 종류의 ORM이다.

전통적인 ORM은 테이블을 프로그래밍 언어의 모델 클래스에 매핑하여 관계형 데이터베이스 작업을 위한 객체 지향 방식을 제공한다. 이 접근 방식은 [객체-관계형 임피던스 불일치](https://en.wikipedia.org/wiki/Object–relational_impedance_mismatch)로 인해 발생하는 많은 문제를 야기한다.

프리즈마는 기존 ORM과 근본적으로 다르다. 프리즈마를 사용하면 데이터베이스 스키마와 프로그래밍 언어의 모델에 대한 단일 정보 소스 역할을 하는 선언적 [프리즈마 스키마](https://www.prisma.io/docs/concepts/components/prisma-schema)에서 모델을 정의할 수 있다. 그런 다음 앱의 코드에서 프리즈마 클라이언트를 사용하여 복잡한 모델 인스턴스를 관리하는 오버헤드 없이 안전한 타입 방식으로 데이터베이스의 데이터를 읽고 쓸 수 있다. 프리즈마 클라이언트가 항상 순수한 자바스크립트 객체를 반환하기 때문에 데이터 쿼리 프로세스를 훨씬 더 자연스럽고 예측 가능하게 만든다.

이제 ORM 패턴과 워크플로, 프리즈마가 데이터 매퍼 패턴을 구현하는 방법, 프리즈마 접근 방식의 이점에 대해 자세히 알아볼 것이다.

## ORM이 무엇일까?

### ORM 패턴 - 액티브 레코드와 데이터 매퍼

ORM은 높은 수준의 데이터베이스 추상화를 제공한다. ORM은 데이터베이스의 복잡성을 숨기면서 데이터를 생성, 읽기, 삭제, 조작하기 위해 객체를 통한 프로그래밍 방식의 인터페이스를 제공한다.

ORM의 아이디어는 모델을 데이터베이스의 테이블에 매핑하는 **클래스**로 정의한다는 것이다. 클래스와 인스턴스는 데이터베이스에서 데이터를 읽고 쓸 수 있는 프로그래밍 방식의 API를 제공한다.

두 가지 일반적인 ORM 패턴이 있다. [액티브 레코드](https://en.wikipedia.org/wiki/Active_record_pattern)와 [데이터 매퍼](https://en.wikipedia.org/wiki/Data_mapper_pattern)는 객체와 데이터베이스 간에 데이터를 전송하는 방식이 다르다. 두 패턴 모두 클래스를 기본 구성 요소로 정의해야 한다. 두 패턴의 가장 큰 차이점은 데이터 매퍼 패턴이 데이터베이스에서 앱 코드의 메모리 내 객체를 분리하고 데이터 매퍼 계층을 사용하여 둘 사이에서 데이터를 전송한다는 것이다. 실제로 데이터 매퍼를 사용하면 메모리 내 객체(데이터베이스의 데이터를 표현)는 데이터베이스의 존재조차 모른다.

#### 액티브 레코드

액티브 레코드 ORM은 두 표현의 구조가 밀접하게 관련된 데이터베이스 테이블에 모델 클래스를 매핑한다. 예를 들어 모델 클래스의 각 필드는 데이터베이스 테이블에서 일치하는 열을 갖는다. 모델 클래스의 인스턴스는 데이터베이스 행을 래핑하고 데이터베이스의 지속적인 변경을 처리하기 위해 데이터와 액세스 로직를 모두 전달한다. 또한 모델 클래스는 모델의 데이터와 관련된 비즈니스 로직를 전달할 수 있다.

모델 클래스에는 일반적으로 다음을 수행하는 메서드가 있다.

- SQL 쿼리에서 모델의 인스턴스를 생성
- 나중에 테이블에 삽입할 수 있도록 새 인스턴스를 생성
- 일반적으로 사용되는 SQL 쿼리를 래핑하고 액티브 레코드 개체를 반환
- 데이터베이스를 업데이트하고 액티브 레코드에 데이터를 삽입
- 필드를 가져오고 설정
- 비즈니스 로직을 구현

#### 데이터 매퍼

데이터 매퍼 ORM은 액티브 레코드와 대조적으로 데이터베이스의 표현에서 앱의 메모리 내 데이터 표현을 분리한다. 디커플링은 매핑 책임을 두 가지 유형의 클래스로 분리하도록 요구함으로써 달성된다.

- **엔터티 클래스** - 데이터베이스를 모르는 엔터티에 대한 응용 프로그램의 메모리 내 표현
- **매퍼 클래스** - 다음의 두 가지 책임이 있다.
  - 두 표현 간의 데이터 변환
  - 데이터베이스에서 데이터를 가져오고 데이터베이스의 변경 사항을 유지하는 데 필요한 SQL을 생성

데이터 매퍼 ORM을 사용하면 코드에 구현된 문제 영역과 데이터베이스 간의 유연성을 높일 수 있다. 데이터 매퍼 패턴을 사용하면 전체 데이터 매핑 레이어 뒤에 있는 도메인을 알고 있을 필요가 없게 데이터베이스가 구현되는 방식을 숨길 수 있기 때문이다.

전통적인 데이터 매퍼 ORM이 이렇게 하는 이유 중 하나는 두 가지 책임이 별도의 팀(예: [DBA](https://en.wikipedia.org/wiki/Database_administrator)와 백엔드 개발자)에 의해 처리되는 조직 구조 때문이다.

실제로 모든 데이터 매퍼 ORM이 이 패턴을 엄격하게 준수하는 것은 아닙니다. 예를 들어 액티브 레코드와 데이터 매퍼를 모두 지원하는 타입스크립트 환경 시스템에서 널리 사용되는 ORM인 [TypeORM](https://github.com/typeorm/typeorm/blob/master/docs/active-record-data-mapper.md#what-is-the-data-mapper-pattern)은 데이터 매퍼에 대해 다음과 같은 접근 방식을 취한다.

- 엔터티 클래스는 데코레이터(`@Column`)를 사용하여 클래스 속성을 테이블 열에 매핑하고 데이터베이스를 인식한다.
- 매퍼 클래스 대신 저장소 클래스가 데이터베이스 쿼리에 사용되며 사용자 지정 쿼리가 포함될 수 있다. 저장소는 데코레이터를 사용하여 엔터티 속성과 데이터베이스 열 간의 매핑을 결정한다.

데이터베이스에 다음 `User` 테이블이 있다고 가정해 보겠다.

![User-테이블](https://user-images.githubusercontent.com/95019875/184179176-65457331-ce80-4d03-8af4-0d5393390342.png)

대응되는 엔터티 클래스는 다음과 같다.

```tsx
import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm'

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number

  @Column({ name: 'first_name' })
  firstName: string

  @Column({ name: 'last_name' })
  lastName: string

  @Column({ unique: true })
  email: string
}
```

### 스키마 마이그레이션 워크플로

데이터베이스를 사용하는 앱 개발의 핵심은 새로운 기능을 수용하고 해결하려는 문제에 맞도록 데이터베이스 스키마를 변경하는 것이다. 이 섹션에서는 [스키마 마이그레이션](https://www.prisma.io/dataguide/types/relational/what-are-database-migrations)이 무엇이며 워크플로에 미치는 영향에 대해 설명한다.

ORM은 개발자와 데이터베이스 사이에 있기 때문에 대부분의 ORM은 데이터베이스 스키마의 생성과 수정을 지원하는 마이그레이션 도구를 제공한다.

마이그레이션은 데이터베이스 스키마를 한 상태에서 다른 상태로 바꾸는 일련의 단계이다. 첫 번째 마이그레이션은 일반적으로 테이블과 인덱스를 생성하는 것이다. 후속 마이그레이션은 열을 추가 또는 제거하거나, 새 인덱스를 도입하거나, 새 테이블을 생성할 수 있다. 마이그레이션 도구에 따라 마이그레이션은 SQL문이나 SQL문으로 변환되는 프로그래밍 코드의 형태([ActiveRecord](https://guides.rubyonrails.org/active_record_migrations.html)과 [SQLAlchemy](https://alembic.sqlalchemy.org/en/latest/tutorial.html#create-a-migration-script)와 같이)일 수 있다.

데이터베이스에는 일반적으로 데이터가 포함되어 있기 때문에 마이그레이션은 스키마 변경 사항을 더 작은 단위로 나누는 데 도움이 되어 우발적인 데이터 손실을 방지하는 데 도움이 된다.

프로젝트를 처음부터 시작한다고 가정하면 전체 워크플로는 다음과 같다. 데이터베이스 스키마에 `User` 테이블을 만들고 위의 예시와 같이 `User` 엔터티 클래스를 정의하는 마이그레이션을 만든다.

프로젝트가 진행되어 테이블에 새 `salutation` 열을 추가하기로 결정했다면 `User` 테이블을 변경하고 `salutation` 열을 추가하는 또 다른 마이그레이션을 생성한다.

TypeORM 마이그레이션이 어떻게 생겼는지 살펴보겠다.

```tsx
import { MigrationInterface, QueryRunner } from 'typeorm'

export class UserRefactoring1604448000 implements MigrationInterface {
  async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE "User" ADD COLUMN "salutation" TEXT`)
  }

  async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE "User" DROP COLUMN "salutation"`)
  }
}
```

마이그레이션이 수행되고 데이터베이스 스키마가 변경된 후에는 엔터티 및 매퍼 클래스도 새 `salutation` 열을 알도록 업데이트해야 한다.

TypeORM에서는 이것은 `User` 엔터티 클래스에 `salutation` 프로퍼티를 추가하는 것을 의미한다.

```tsx
import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm'

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number

  @Column({ name: 'first_name' })
  firstName: string

  @Column({ name: 'last_name' })
  lastName: string

  @Column({ unique: true })
  email: string

  @Column()
  salutation: string
}
```

변경 사항이 수동으로 적용되고 프로그래밍 방식으로 쉽게 확인할 수 없기 때문에 이러한 변경 사항을 동기화하는 것은 ORM에서 어려울 수 있다. 이미 존재하는 열의 이름을 바꾸는 것은 훨씬 더 복잡하며 열에 대한 참조를 검색하고 교체해야 한다.

요약하면 스키마를 발전시키는 것은 앱 구축의 핵심 부분이다. ORM의 경우, 스키마 업데이트 워크플로에는 마이그레이션 도구를 사용하여 마이그레이션을 만든 다음 해당 엔터티와 매퍼 클래스를 업데이트하는 작업이 포함된다(구현에 따라 다름). 나중에 배우겠지만 프리즈마는 이에 대해 다른 접근 방식을 취한다.

마이그레이션이 무엇이며 개발 워크플로에 어떻게 적용되는지 살펴보았으므로 ORM의 장점과 단점에 대해 자세히 알아보겠다.

### ORM의 이점

개발자가 ORM을 사용하는 데에는 여러 가지 이유가 있다.

- ORM은 도메인 모델 구현을 용이하게 한다. 도메인 모델은 비즈니스 로직의 동작과 데이터를 통합하는 개체 모델이다. 즉, 데이터베이스 구조나 SQL 시맨틱이 아닌 실제 비즈니스 개념에 집중할 수 있다.
- ORM은 코드 양을 줄이는 데 도움이 된다. 일반적인 CRUD 작업에 대해 반복적인 SQL문을 작성하고 SQL 주입과 같은 취약점을 방지하기 위해 사용자 입력을 이스케이핑할 필요가 없다.
- ORM을 사용하면 SQL을 거의 작성하지 않아도 된다(복잡성에 따라 이상한 원시 쿼리를 작성해야 할 수도 있음). 이는 SQL에 익숙하지 않지만 데이터베이스 작업을 원하는 개발자에게 유용하다.
- 많은 ORM은 데이터베이스별 세부 정보를 추상화한다. 이론적으로 이것은 ORM이 한 데이터베이스에서 다른 데이터베이스로 쉽게 변경할 수 있음을 의미한다. 하지만 실제로는 앱의 데이터베이스를 변경하는 일은 거의 없다.

생산성 향상을 목표로 하는 모든 추상화와 마찬가지로 ORM 사용에도 단점이 있다.

### ORM의 단점

ORM을 사용하기 시작할 때는 단점이 잘 드러나지 않는다. 이 섹션에서는 일반적인 단점을 다룬다.

- ORM을 사용하면 [객체-관계형 임피던스 불일치](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch)로 이어질 수 있는 데이터베이스 테이블의 객체 그래프 표현을 형성할 수 있다. 이것은 해결하려는 문제가 관계형 데이터베이스에 쉽게 매핑되지 않는 복잡한 객체 그래프를 형성할 때 발생한다. 관계형 데이터베이스와 메모리 내(객체 포함)에 있는 두 가지 데이터 표현 간의 동기화는 매우 어렵다. 객체가 관계형 데이터베이스 레코드에 비해 서로 관련될 수 있는 방식이 더 유연하고 다양하기 때문이다.
- ORM이 문제와 관련된 복잡성을 처리하는 동안에도 동기화 문제는 사라지지 않다. 데이터베이스 스키마나 데이터 모델을 변경하려면 변경 사항을 다시 다른 쪽에 매핑해야 한다. 이 부담은 종종 개발자에게 있다. 프로젝트에서 작업하는 팀의 맥락에서 데이터베이스 스키마 변경에는 조정이 필요하다.
- ORM은 캡슐화 복잡성으로 인해 API 표면이 넓어지는 경향이 있다. SQL을 작성하지 않아도 되는 반면 ORM 사용법을 배우는 데 많은 시간이 들어간다. 이는 대부분의 추상화에 적용되지만 데이터베이스 작동 방식을 이해하지 못하면 느린 쿼리를 개선하기 어려울 수 있다.
- 일부 복잡한 쿼리는 SQL이 제공하는 유연성으로 인해 ORM에서 지원되지 않는다. 이 문제는 ORM에 SQL문 문자열을 전달하고 쿼리를 자동으로 실행하는 원시 SQL 쿼리 기능으로 해결이 가능하다.

이제 ORM의 비용과 이점을 배웠으므로 프리즈마가 무엇인지 더 잘 이해할 수 있을 것이다.

## 프리즈마

프리즈마는 앱 개발자의 데이터베이스 작업을 돕고 다음의 도구를 제공하는 차세대 ORM이다.

- **프리즈마 클라이언트** - 앱에서 사용할 수 있게 자동 생성되며 타입이 안전한 데이터베이스 클라이언트
- **프리즈마 마이그레이트** - 선언적 데이터 모델링 및 마이그레이션 도구
- **프리즈마 스튜디오** - 데이터베이스의 데이터를 검색하고 관리하기 위한 모던 GUI

> **참고**
>
> 프리즈마 클라이언트는 가장 눈에 띄는 도구이기 때문에 간단히 프리즈마라고 부르기도 한다.

세 개의 도구는 데이터베이스 스키마, 앱의 객체 스키마, 둘 사이의 매핑에 대한 단일 정보 소스로 [프리즈마 스키마](https://www.prisma.io/docs/concepts/components/prisma-schema)를 사용한다. 프리즈마 스키마는 개발자에 의해 정의되며 프리즈마의 주요 설정 파일이다.

프리즈마는 타입 안전성, 풍부한 자동 완성, 관계 가져오기 API와 같은 기능을 사용하여 개발 중인 소프트웨어의 생산성과 신뢰성을 향상시킨다.

### 프리즈마가 데이터 매퍼 패턴을 구현하는 방법

앞에서 언급했듯이 데이터 매퍼 패턴은 데이터베이스와 앱을 서로 다른 팀에서 소유하고 있는 조직과 잘 어울린다.

관리형 데이터베이스 서비스 및 DevOps 방식이 포함된 최신 클라우드 환경의 등장으로 더 많은 팀이 교차 기능 접근법을 채택하고 있다.

프리즈마를 사용하면 DB 스키마와 객체 스키마를 동시에 발전시킬 수 있으므로 처음부터 편차를 줄이면서 `@map` 속성을 사용하여 앱과 데이터베이스를 어느 정도 분리된 상태로 유지할 수 있다. 이것이 한계처럼 보일 수 있지만, 이는 도메인 모델의 진화(객체 스키마를 통한)가 나중에 데이터베이스에 부과되는 것을 방지한다.

프리즈마의 데이터 매퍼 패턴 구현이 기존 데이터 매퍼 ORM과 개념적으로 어떻게 다른지 이해하기 위해 개념과 구성 요소를 간략하게 비교해 보겠다.

| 개념                | 설명                                            | 기존 ORM의 구성 요소                                      | 프리즈마의 구성 요소                    | 프리즈마의 믿을 만한 소스   |
| :------------------ | :---------------------------------------------- | :-------------------------------------------------------- | :-------------------------------------- | :-------------------------- |
| 객체 스키마         | 앱의 인메모리 데이터 구조                       | 모델 클래스                                               | 생성된 타입스크립트 타입                | 프리즈마 스키마의 모델      |
| 데이터 매퍼         | 객체 스키마와 데이터베이스 사이를 변환하는 코드 | 매퍼 클래스                                               | 프리즈마 클라이언트에서 생성된 함수     | 프리즈마 스키마의 @map 속성 |
| 데이터베이스 스키마 | 데이터베이스의 데이터 구조(예: 테이블과 열)     | 직접 작성하거나 프로그래밍 방식 API를 사용하여 작성한 SQL | 프리즈마 마이그레이트에 의해 생성된 SQL | 프리즈마 스키마             |

프리즈마는 다음의 추가 이점과 함께 데이터 매퍼 패턴을 구현한다.

- 프리즈마 스키마를 기반으로 프리즈마 클라이언트를 생성하여 클래스 정의 및 매핑 로직의 보일러플레이트를 줄임
- 앱 객체와 데이터베이스 스키마 간의 동기화 문제를 제거
- 데이터베이스 마이그레이션은 프리즈마 스키마에서 파생되었기 때문에 일급 시민임

### 프리즈마 스키마

프리즈마의 데이터 매퍼 패턴 구현의 중심에는 프리즈마 스키마가 있다. 프리즈마 스키마는 다음의 책임에 대한 단일 정보 소스이다.

- 프리즈마가 데이터베이스를 연결하는 방법을 설정
- 프리즈마 클라이언트 생성 – 앱 코드에서 사용하기 위한 타입 안전 ORM
- 프리즈마 마이그레이트로 데이터베이스 스키마 생성 및 개선
- 앱 객체와 데이터베이스 열 간의 매핑을 정의

프리즈마의 모델은 액티브 레코드 ORM과 의미가 조금 다르다. 프리즈마에서 모델은 프리즈마 클라이언트의 속성에 대한 열 간의 매핑, 관계, 테이블을 설명하는 추상 엔터티로 프리즈마 스키마에 정의된다.

예를 들어 블로그에 대한 프리즈마 스키마는 다음과 같다.

```tsx
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String? @map("post_content")
  published Boolean @default(false)
  author    User?   @relation(fields: [authorId], references: [id])
  authorId  Int?
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}
```

위의 예시를 분석하면 다음과 같다.

- `datasource` 블록은 데이터베이스에 대한 연결을 정의한다.
- `generator` 블록은 프리즈마에게 타입스크립트 및 Node.js용 클라이언트를 생성하도록 지시한다 .
- `Post`와 `User` 모델은 데이터베이스 테이블에 매핑된다.
- 두 모델은 각 `User`가 많은 관련 `Post`를 가질 수 있는 1-n 관계를 갖는다.
- 모델의 각 필드에는 타입이 있다. 예를 들어 `id`는 `Int` 타입을 갖는다.
- 필드에는 다음을 정의하는 필드 속성이 포함될 수 있다.
  - `@id` 속성이 있는 주 키
  - `@unique` 속성이 있는 고유 키
  - `@default` 속성이 있는 기본값
  - `@map` 속성이 있는 프리즈마 클라이언트 필드와 테이블 열 간의 매핑. 예를 들어 `content` 필드(프리즈마 클라이언트에서 액세스 가능)가 데이터베이스의 `post_content` 열에 매핑된다.

`User`-`Post` 관계를 시각화한 다이어그램은 다음과 같다.

<img src="https://user-images.githubusercontent.com/95019875/184213734-1c6c4a9b-8953-4bfb-bd79-40a50c76da98.png" alt="관계-다이어그램" style="zoom: 50%;" />

프리즈마 수준에서 `User`-`Post` 관계는 다음으로 구성된다.

- `@relation` 속성에서 참조하는 스칼라 `authorId` 필드이다. 이 필드는 데이터베이스 테이블에 존재한다. `Post`와 `User`를 연결하는 외래 키이다.
- 두 개의 관계 필드 - `author`와 `posts`는 데이터베이스 테이블에 **존재하지 않는다**. 관계 필드는 프리즈마 수준에서 모델 간의 연결을 정의하고 프리즈마 스키마와 생성된 프리즈마 클라이언트에만 존재하며 관계에 액세스하는 데 사용된다.

프리즈마 스키마의 선언적 특성은 간결하며 프리즈마 클라이언트에서 데이터베이스 스키마와 해당 표현을 정의할 수 있다.

### 프리즈마 워크플로

프리즈마의 워크플로는 기존 ORM과 약간 다르다. 새로운 애플리케이션을 처음부터 구축하거나 점진적으로 채택할 때 프리즈마를 사용할 수 있다.

- 신규 애플리케이션(그린필드) - 아직 데이터베이스 스키마가 없는 프로젝트는 프리즈마 마이그레이트를 사용하여 데이터베이스 스키마를 생성할 수 있다.
- 기존 애플리케이션(브라운필드) - 이미 데이터베이스 스키마가 있는 프로젝트를 프리즈마에서 [분석](https://www.prisma.io/docs/concepts/components/introspection)하여 프리즈마 스키마와 프리즈마 클라이언트를 생성할 수 있다. 이 유스 케이스는 기존 마이그레이션 도구와 함께 작동하며 점진적 채택에 유용하다. 마이그레이션 도구로 프리즈마 마이그레이트로 전환하는 것이 가능하다. 그러나 이것은 선택 사항이다.

두 워크플로 모두에서 프리즈마 스키마가 기본 설정 파일이다.

#### 기존 데이터베이스가 있는 프로젝트에서 점진적 채택을 하는 워크플로

브라운필드 프로젝트에는 일반적으로 이미 데이터베이스 추상화와 스키마가 있습니다. 프리즈마는 기존 데이터베이스를 검사하여 기존 데이터베이스 스키마를 반영하는 프리즈마 스키마를 얻고 프리즈마 클라이언트를 생성함으로써 해당 프로젝트와 통합할 수 있다. 이 워크플로는 이미 사용 중인 모든 마이그레이션 도구 및 ORM과 호환된다. 점진적인 평가 및 채택을 선호하는 경우에는 이 방식을 [병렬 채택 전략](https://en.wikipedia.org/wiki/Parallel_adoption)의 일부로 사용할 수 있다.

이 워크플로와 호환되는 설정의 전체 목록은 다음과 같다.

- 데이터베이스 스키마를 생성하고 변경하기 위해 `CREATE TABLE`과 `ALTER TABLE`로 이루어진 순수 SQL 파일을 사용하는 프로젝트
- [db-migrate](https://github.com/db-migrate/node-db-migrate) 또는 [Umzug](https://github.com/sequelize/umzug)와 같은 타사 마이그레이션 라이브러리를 사용하는 프로젝트
- 이미 ORM을 사용 중인 프로젝트. 이 경우에는 ORM을 통한 데이터베이스 접근은 변경되지 않고 생성된 프리즈마 클라이언트가 점진적으로 채택될 수 있음

실제로 기존 DB를 점검하고 프리즈마 클라이언트를 생성하는 데 필요한 단계는 다음과 같다.

1. `datasource`(이 경우에는 기존 DB)와 `generator`를 정의하는 `schema.prisma`을 생성한다.

```tsx
datasource db {
  provider = "postgresql"
  url      = "postgresql://janedoe:janedoe@localhost:5432/hello-prisma"
}

generator client {
  provider = "prisma-client-js"
}
```

2. `prisma db pull`을 실행하여 데이터베이스 스키마에서 파생된 모델로 프리즈마 스키마를 채운다.
3. (선택 사항) 프리즈마 클라이언트와 데이터베이스 간의 [필드 및 모델 매핑](https://www.prisma.io/docs/concepts/components/prisma-schema/data-model#mapping-model-names-to-tables-or-collections)을 커스터마이징한다.
4. `prisma generate`를 실행한다.

프리즈마는 `node_modules` 폴더 안에 프리즈마 클라이언트를 생성하여 앱에서 가져오는 것이 가능해진다. 자세한 사용 설명서는 [프리즈마 클라이언트 API](https://www.prisma.io/docs/concepts/components/prisma-client) 문서를 참고한다.

요약하자면 프리즈마 클라이언트는 병렬 채택 전략의 일부로 기존 데이터베이스와 도구를 사용하여 프로젝트에 통합할 수 있다.

#### 새 프로젝트의 워크플로

프리즈마는 지원하는 워크플로 측면에서 ORM과 다르다. 새 데이터베이스 스키마를 만들고 변경하는 데 필요한 단계를 자세히 살펴보면 프리즈마 마이그레이트를 이해하는 데 도움이 된다.

프리즈마 마이그레이트는 선언적 데이터 모델링 및 마이그레이션을 위한 CLI다. ORM의 일부로 제공되는 대부분의 마이그레이션 도구와 달리 한 상태에서 다른 상태로 이동하는 작업을 할 필요가 없다. 대신 현재 스키마만 설명하면 된다. 프리즈마 마이그레이트는 작업을 추론하고 SQL을 생성하며 마이그레이션을 수행한다.

다음 예제는 위의 블로그 예제와 유사한 새 데이터베이스 스키마가 있는 새 프로젝트에서 프리즈마를 사용하는 방법을 보여준다.

1. 프리즈마 스키마를 생성한다.

```tsx
// schema.prisma
datasource db {
  provider = "postgresql"
  url      = "postgresql://janedoe:janedoe@localhost:5432/hello-prisma"
}

generator client {
  provider = "prisma-client-js"
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String? @map("post_content")
  published Boolean @default(false)
  author    User?   @relation(fields: [authorId], references: [id])
  authorId  Int?
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}
```

2. `prisma migrate`을 실행하여 마이그레이션을 위한 SQL을 생성해, 이를 데이터베이스에 적용하고 프리즈마 클라이언트를 생성한다.

데이터베이스 스키마에 추가 변경 사항이 생기면 다음을 수행한다.

1. 프리즈마 스키마에 변경 사항을 적용한다. `User` 모델에 `registrationDate` 필드를 추가하는 것이 그 예이다.
2. `prisma migrate`을 다시 실행한다.

마지막 단계는 프리즈마 스키마에 필드를 추가하고 프리즈마 마이그레이트를 사용하여 데이터베이스 스키마를 원하는 상태로 변환하는 선언적 마이그레이션이 작동하는 방식을 보여준다. 마이그레이션이 실행된 후 프리즈마 클라이언트는 업데이트된 스키마를 반영하도록 자동으로 재생성된다.

##### 프리즈마 마이그레이트를 사용하지 않는 새 프로젝트를 위한 대안

프리즈마 마이그레이트 대신 타사 마이그레이션 도구로 새 프로젝트에서 프리즈마 클라이언트를 사용할 수 있다.

예를 들어 새 프로젝트는 Node.js 마이그레이션 프레임워크 [db-migrate](https://github.com/db-migrate/node-db-migrate)를 사용하여 데이터베이스 스키마 및 마이그레이션을 생성하고 프리즈마 클라이언트를 쿼리에 사용할 수 있다. 자세한 내용은 [기존 데이터베이스가 이미 존재하는 워크플로](#기존-데이터베이스가-있는-프로젝트에서-점진적-채택을-하는-워크플로)에서 다뤘다.

## 프리즈마 클라이언트로 데이터 접근하기

프리즈마 클라이언트에 표시되는 쿼리 메서드를 사용하여 데이터베이스에 접근할 수 있다. 모든 쿼리는 오래된 순수 자바스크립트 객체를 반환한다.

위의 블로그 스키마에 대해 사용자를 가져오는 코드는 다음과 같다.

```tsx
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const user = await prisma.user.findUnique({
  where: {
    email: 'alice@prisma.io',
  },
})
```

이 쿼리에서 `findUnique` 메서드는 `User` 테이블에서 하나의 행을 가져온다. 기본적으로 프리즈마는 `User` 테이블의 모든 스칼라 필드를 반환한다.

> **참고**
>
> 예시에서는 프리즈마 클라이언트에서 제공하는 타입 안전 기능을 최대한 활용하기 위해 타입스크립트를 사용한다. 그러나 프리즈마는 [Node.js의 자바스크립트](https://dev.to/prisma/productive-development-with-prisma-s-zero-cost-type-safety-4od2)에서도 잘 작동한다.

프리즈마 클라이언트는 프리즈마 스키마에서 코드를 생성하여 쿼리와 결과를 [구조적 타입](https://en.wikipedia.org/wiki/Structural_type_system)에 매핑한다. 이는 생성된 프리즈마 클라이언트에 연결된 타입이 `user`에 있음을 의미한다.

```tsx
export type User = {
  id: number
  email: string
  name: string | null
}
```

이렇게 하면 존재하지 않는 필드에 접근할 때 타입 오류가 발생한다. 더 나아가 모든 쿼리에 대한 결과 타입을 쿼리를 실행하기 전에 미리 알 수 있어 오류를 잡는 데 도움이 된다.

예를 들어 다음 코드 스니펫은 타입 오류를 발생시킨다.

```tsx
console.log(user.lastName) // 'lastName' 프로퍼티는 'User' 타입에 존재하지 않는다.
```

### 관계 가져오기

프리즈마 클라이언트에서 관계 가져오기는 `include` 옵션으로 사용한다.

예를 들어 사용자와 사용자의 게시물을 가져오려면 다음과 같이 한다.

```tsx
const user = await prisma.user.findUnique({
  where: {
    email: 'alice@prisma.io',
  },
  include: {
    posts: true,
  },
})
```

이 쿼리를 사용하면 `user`의 타입에는 `posts` 배열 필드에 접근할 수 있는 `Post`도 포함된다.

```tsx
console.log(user.posts[0].title)
```

프리즈마 클라이언트 API의 [CRUD 작업](https://www.prisma.io/docs/concepts/components/prisma-client/crud)에 대한 자세한 내용은 문서에서 확인할 수 있다. 중요한 것은 모든 쿼리와 결과가 타입별로 지원되며 관계를 가져오는 방법을 완전히 제어할 수 있다는 것이다.

## 결론

프리즈마는 전통적인 ORM과 다르며 기존 ORM에서 일반적으로 발생하는 문제가 없는 새로운 종류의 데이터 매퍼 ORM이다.

기존 ORM과 달리 프리즈마를 사용하면 데이터베이스 스키마 및 앱 모델에 대한 선언적 단일 정보 소스인 프리즈마 스키마를 정의할 수 있다. 프리즈마 클라이언트의 모든 쿼리는 일반 자바스크립트 객체를 반환하므로 데이터베이스와 상호 작용하는 프로세스가 훨씬 더 자연스럽고 예측 가능해진다.

프리즈마는 새로운 프로젝트를 시작하고 기존 프로젝트에 적용하기 위한 두 가지 주요 워크플로를 지원한다. 두 워크플로 모두에서 프리즈마 스키마는 기본 설정 파일이다.

모든 추상화와 마찬가지로 프리즈마와 다른 ORM은 서로 다른 가정으로 밑에 있는 데이터베이스의 세부 정보를 숨긴다.

이러한 차이점과 유스 케이스는 모두 워크플로와 채택 비용에 영향을 미친다. 이 차이를 이해하면 정보에 근거한 결정을 내리는 데 도움이 될 것이다.

