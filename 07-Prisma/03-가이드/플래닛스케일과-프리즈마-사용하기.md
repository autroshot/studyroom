# 플래닛스케일과 프리즈마 사용하기

Prisma와 [PlanetScale](https://planetscale.com/)은 Prisma의 ORM과 PlanetScale의 확장성이 뛰어난 MySQL 기반 플랫폼을 사용하여 데이터 접근 앱의 신속하고 타입이 안전한 개발을 최적화하는 개발 영역을 제공한다.

## 플래닛스케일이란?

PlanetScale은 Vitess 데이터베이스 클러스터링 시스템을 사용하여 MySQL 호환 데이터베이스 플랫폼을 제공한다.

기능은 다음과 같다.

- **엔터프라이즈 확장성** - PlanetScale은 여러 데이터베이스 서버 간의 확장을 지원하는 고가용성 프로덕션 데이터베이스 클러스터를 제공한다. 이는 연결 제한을 관리해야 하는 문제를 피하기 때문에 서버리스 컨텍스트에서 특히 유용하다.
- **데이터베이스 브랜치** - PlanetScale을 사용하면 데이터베이스 스키마의 브랜치를 생성할 수 있으므로 프로덕션 데이터베이스에 변경 사항을 적용하기 전에 개발 분기에서 변경 사항을 테스트할 수 있다.
- **논블로킹 스키마 변경** - PlanetScale은 사용자가 데이터베이스를 잠그거나 다운타임을 일으키지 않고 데이터베이스 스키마를 업데이트할 수 있는 워크플로를 제공한다.

## 다른 데이터베이스 제공자와의 공통점

PlanetScale과 함께 Prisma를 사용하는 것은 다른 관계형 데이터베이스에서 Prisma를 사용하는 것과 거의 동일하다.

다음과 같은 기능을 똑같이 사용할 수 있다.

- Prisma Schema 언어로 데이터베이스 모델링
- PlanetScale이 제공하는 연결 문자열과 함께 스키마에서 Prisma의 기존 `mysql` 데이터베이스 커넥터를 사용
- PlanetScale에 이미 데이터베이스 스키마가 있는 경우 기존 프로젝트에 분석 사용
- `db push`를 사용해 스키마의 변경 사항을 데이터베이스에 푸시
- 앱에서 Prisma Client를 사용 하여 PlanetScale의 데이터베이스 서버와 통신

## 고려해야 할 차이점

확장성을 위한 PlanetScale의 브랜치 모델 및 설계로 인해 고려해야 할 많은 차이점이 존재한다.

Prisma와 함께 PlanetScale을 사용하기로 결정할 때 다음 사항에 유의해야 한다.

- **브랜치 및 배포 요청** - PlanetScale은 스키마 변경을 테스트할 수 있는 **개발 브랜치**와 직접적인 스키마 변경으로부터 보호되는 **프로덕션 브랜치**라는 두 가지 유형의 데이터베이스 브랜치를 제공한다. 변경 사항을 개발 브랜치에서 먼저 만든 다음 배포 요청을 사용하여 프로덕션에 배포해야 한다. 프로덕션 브랜치는 고가용성이며 자동화된 일일 백업을 포함한다.
- **참조 작업 및 무결성** - 여러 데이터베이스 서버에서 확장을 지원하기 위해 PlanetScale은 일반적으로 관계형 데이터베이스에서 다른 테이블의 데이터 간의 관계를 적용하는 데 사용되는 외래 키 제약 조건을 사용하지 않는다. 대신 앱에서 이를 수동으로 처리할 것을 사용자에게 요청한다.
  Prisma를 사용하면 데이터에서 이러한 관계를 유지하고 Prisma 클라이언트에서 참조 무결성을 에뮬레이트 하는 기능을 사용하여 참조 작업을 사용할 수 있다.
- **외래 키에 대한 인덱스 생성** - Prisma에서 참조 무결성을 에뮬레이트할 때 외래 키에 대한 인덱스를 생성해야 한다. 표준 MySQL 데이터베이스에서는 테이블에 외래 키 제약 조건이 있는 열에 인덱스가 자동으로 생성된다. PlanetScale은 외래 키를 지원하지 않기 때문에 인덱스는 [현재](https://github.com/prisma/prisma/issues/10611) 참조 무결성을 에뮬레이트할 때 생성되지 않으며, 이로 인해 쿼리가 제대로 최적화되지 않는 문제가 발생할 수 있다. 이를 방지하기 위해 Prisma에서 인덱스를 생성할 수 있다.
- **`db push`를 사용하여 스키마 변경** - 개발 브랜치를 프로덕션 브랜치에 병합하면 PlanetScale이 자동으로 두 스키마를 비교하고 자체 스키마 diff를 생성한다. 이는 마이그레이션 파일의 자체 기록을 생성하는 Prisma의 `prisma migrate` 워크플로가 PlanetScale과 함께 작업할 때 자연스럽게 맞지 않는다는 것을 의미한다. 이러한 마이그레이션 파일은 브랜치가 병합될 때 PlanetScale에서 실행하는 실제 스키마 변경 사항을 반영하지 않을 수 있다.

    > **참고**
    >
    > PlanetScale의 스키마를 변경할 때 `prisma migrate`를 사용하지 않는 것을 권장한다. 대신 `prisma db push` 명령을 사용하는 것이 좋다.

- **분석** - 기존 데이터베이스를 분석하면 보통은 테이블을 연결하는 외래 키를 기반으로 정의되기 때문에 관계가 없는 스키마를 얻게 된다. PlanetScale은 외래 키를 지원하지 않고 Prisma를 사용하여 참조 무결성을 에뮬레이트하므로 누락된 관계를 수동으로 추가해야 한다. 자세한 내용은 [분석 후 누락된 관계를 추가하는 방법](https://www.prisma.io/docs/guides/database/using-prisma-with-planetscale#how-to-add-in-missing-relations-after-introspection)을 참고한다.

## 브랜치를 사용하고 요청을 배포하는 방법

Prisma를 사용하여 PlanetScale에 연결할 때 브랜치에 올바른 연결 문자열을 사용해야 한다. 지정된 데이터베이스 브랜치에 대한 연결 URL은 PlanetScale 계정에서 브랜치 개요 페이지로 이동하고 'Connect' 드롭다운을 선택하면 찾을 수 있다. 'Passwords' 섹션에서 새 비밀번호를 생성하고 드롭다운에서 'Prisma'를 선택하여 연결 URL에 대한 Prisma 형식을 가져온다. 자세한 내용은 [시작하기](../01-시작하기/02-데이터베이스-연결하기.md)를 참고한다.

모든 PlanetScale 데이터베이스는 처음에 스키마 변경을 테스트하는 데 사용할 수 있는 개발 브랜치인 `main` 브랜치로 생성된다. 변경 사항에 만족하면 프로덕션 브랜치로 승격시킬 수 있다. 새 변경 사항은 개발 브랜치에만 푸시할 수 있다. 따라서 별도의 개발 브랜치에서 추가 변경 사항을 만든 다음 나중에 배포 요청을 사용하여 프로덕션에 배포해야 한다.

프로덕션 브랜치로 푸시하려고 하면 다음과 같은 오류 메시지가 표시된다.

```
Direct execution of DDL (Data Definition Language) SQL statements is disabled on this database.
```

## 참조 무결성 에뮬레이션을 활성화하는 방법

참조 무결성은 현재 미리보기 기능이다. 이를 활성화하려면 `schema.prisma`의 `generator` 블록 내부의 `previewFeatures` 목록에 해당 기능을 추가한 다음, `datasource` 블록의 `referentialIntegrity` 유형을 `"prisma"`로 설정한다.

```js
datasource db {
  provider             = "mysql"
  url                  = env("DATABASE_URL")
  referentialIntegrity = "prisma"
}

generator js {
  provider        = "prisma-client-js"
  previewFeatures = ["referentialIntegrity"]
}
```

## 외래 키의 인덱스를 만드는 방법

Prisma에서 참조 무결성을 에뮬레이트할 때 인덱스를 생성해야 한다.

예시로 게시물과 댓글이 있는 블로그에 대한 스키마를 살펴보겠다.

```js
model Post {
  id       Int       @id @default(autoincrement())
  title    String
  content  String
  likes    Int       @default(0)
  comments Comment[]
}

model Comment {
  id      Int    @id @default(autoincrement())
  comment String
  postId  Int
  post    Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
}
```

`Comment` 모델의 `postId` 필드는 `Post` 모델의 `id` 필드를 참조한다. 그러나 이것은 PlanetScale에서 외래 키로 구현되지 않으므로 열에 자동 인덱스가 없다. 이는 일부 쿼리가 제대로 최적화되지 않을 수 있음을 의미한다. 예를 들어 특정 게시물 `id`의 모든 댓글을 쿼리하는 경우, PlanetScale은 전체 테이블 조회를 수행해야 할 수 있다. 이는 PlanetScale이 읽기를 수행한 행의 수에 대해 요금을 부과하기 때문에 느리고 비용이 많이 들 수 있다.

이를 피하기 위해 Prisma의 `@@index` 인수를 사용하여 `postId` 필드에 인덱스를 정의할 수 있다.

```js
model Post {
  id       Int       @id @default(autoincrement())
  title    String
  content  String
  likes    Int       @default(0)
  comments Comment[]
}

model Comment {
  id      Int    @id @default(autoincrement())
  comment String
  postId  Int
  post    Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([postId])
}
```

그런 다음 `db push`를 사용하여 이 변경 사항을 스키마에 추가할 수 있다.

> **참고**
>
> 한 가지 주의해야 할 문제는 암시적 다대다 관계에는 이러한 방식으로 인덱스를 추가할 수 없다는 것이다. 쿼리 속도나 비용이 문제라면 명시적 다대다 관계를 대신 사용할 수 있다 .

## db push로 스키마를 변경하는 방법

PlanetScale에 `db push`를 사용하려면 먼저 Prisma에서 참조 무결성 에뮬레이션을 활성화해야 한다. 참조 에뮬레이션을 활성화하지 않고 브랜치로 푸시하면 다음과 같은 오류 메시지가 나타난다.

```
Foreign keys cannot be created on this database.
```

예를 들어 위의 블로그 게시물 스키마에 새 `excerpt` 필드를 추가하기로 결정했다고 가정해 보겠다. 먼저 새 개발 브랜치를 만들고 연결해야 한다.

다음으로 `schema.prisma` 파일에 다음을 추가한다.

```js
model Post {
  id       Int       @id @default(autoincrement())
  title    String
  content  String
  excerpt  String?
  likes    Int       @default(0)
  comments Comment[]
}

model Comment {
  id      Int    @id @default(autoincrement())
  comment String
  postId  Int
  post    Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([postId])
}
```

이 변경 사항을 푸시하려면 터미널에서 프로젝트 디렉토리로 이동하여 다음을 실행한다.

```shell
npx prisma db push
```

개발 브랜치의 변경 사항에 만족하면 배포 요청을 열어 프로덕션 브랜치에 배포할 수 있다.

더 많은 예시는 플래닛스케일의 [프리즈마를 이용한 자동 마이그레이션](https://docs.planetscale.com/tutorials/automatic-prisma-migrations)을 참고한다.

## 분석 후 누락된 관계를 추가하는 방법

`npx prisma db pull`로 분석한 후 얻은 스키마에 일부 관계가 누락되었을 수 있다.

예를 들어 다음 스키마에는 `User`와 `Post` 모델 간의 관계가 누락되었다.

```js
model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  title     String   @db.VarChar(255)
  content   String?
  authorId  Int

  @@index([authorId])
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}
```

이 경우 관계를 직접 추가해야 한다.

```js
model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  title     String   @db.VarChar(255)
  content   String?
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int

  @@index([authorId])
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}
```

자세한 예시는 [PlanetScale 시작하기 가이드](https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases/introspection-typescript-planetscale)를 참고한다.
