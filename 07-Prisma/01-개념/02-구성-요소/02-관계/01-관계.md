# 관계

관계는 프리즈마 스키마에서 두 모델 간의 **연결**이다.

예를 들어 한 사용자가 여러 블로그 게시물을 가질 수 있기 때문에 `User`와 `Post` 사이에는 일대다 관계가 있다.

다음 프리즈마 스키마는 `User`과 `Post` 모델 간의 일대다 관계를 정의한다.

```tsx
model User {
  id    Int    @id @default(autoincrement())
  posts Post[]
}

model Post {
  id       Int  @id @default(autoincrement())
  author   User @relation(fields: [authorId], references: [id])
  authorId Int // 관계 스칼라 필드 (위의 `@relation` 속성에 사용됨)
}
```

프리즈마 수준에서 `User`와 `Post` 관계는 다음으로 구성된다.

- 두 개의 관계 필드 - `author`와 `posts`. 관계 필드는 프리즈마 수준에서 모델 간의 연결을 정의하며 **데이터베이스에는 존재하지 않는다**. 이 필드는 프리즈마 클라이언트를 생성하는 데 사용된다.
- `@relation` 속성에서 참조하는 스칼라 `authorId` 필드이다. 이 필드는 **데이터베이스에 존재한다**. `Post`와 `User`를 연결하는 외래 키이다.

프리즈마 수준에서 두 모델 간의 연결은 항상 관계의 **양쪽**에 있는 관계 필드로 표현된다 .

## 데이터베이스의 관계

### 관계형 데이터베이스

다음 엔터티 관계 다이어그램은 관계형 데이터베이스의 `User`와 `Post` 테이블 간에 동일한 일대다 관계를 정의한다.

<이미지>

SQL에서는 **외래 키**를 사용하여 두 테이블 간의 관계를 생성한다. 외래 키는 관계의 **한쪽**에 저장된다.

위의 예시는 다음으로 구성된다.

- `Post` 테이블의 `authorId`라는 외래 키 열
- `User` 테이블의 `id`라는 주 키 열. `Post` 테이블의 `authorId`열은 `User` 테이블의 `id`열을 참조한다.

프리즈마 스키마에서 외래 키와 주 키 관계는 `author` 필드의 `@relation` 속성으로 표현된다.

```tsx
author     User        @relation(fields: [authorId], references: [id])
```

> **참고**
>
> 프리즈마 스키마의 관계는 데이터베이스의 테이블 사이에 존재하는 관계를 나타낸다. 데이터베이스에 관계가 없으면 프리즈마 스키마에도 존재하지 않는다.

## 프리즈마 클라이언트의 관계

프리즈마 클라이언트는 프리즈마 스키마에서 생성된다.

다음 예시는 프리즈마 클라이언트를 사용하여 레코드를 가져오고, 생성하고, 업데이트할 때 관계가 어떻게 나타나는지 보여준다.

다음 쿼리는 `User` 레코드와 두 개의 연결된 `Post` 레코드를 생성한다.

```tsx
const userAndPosts = await prisma.user.create({
  data: {
    posts: {
      create: [
        { title: 'Prisma Day 2020' }, // authorId를 user의 id로 채운다.
        { title: 'How to write a Prisma schema' }, // authorId를 user의 id로 채운다.
      ],
    },
  },
})
```

밑에 있는 데이터베이스에서 이 쿼리는 다음을 수행한다.

1. 자동 생성된 `id`로 `User`를 생성한다(예: `20`) .
2. 두 개의 새 `Post` 레코드를 생성하고 두 레코드의 `authorId`를 `20`으로 설정한다.

다음 쿼리는 `id`로 `User`를 검색하고 `Post` 레코드를 포함한다.

```tsx
const getAuthor = await prisma.user.findUnique({
  where: {
    id: "20",
  },
  include: {
    posts: true, // authorId == 20인 모든 포스터
  },
});
```

밑에 있는 데이터베이스에서 이 쿼리는 다음을 수행한다.

1. `id`가 `20`인 `User` 레코드를 검색한다.
2. `authorId`가 `20`인 모든 `Post` 레코드를 검색한다.

다음 쿼리는 기존 `Post` 레코드를 기존 `User` 레코드와 연결한다.

```tsx
const updateAuthor = await prisma.user.update({
  where: {
    id: 20,
  },
  data: {
    posts: {
      connect: {
        id: 4,
      },
    },
  },
})
```

밑에 있는 데이터베이스에서 이 쿼리는 다음을 수행한다.

1. `id`가 `4`인 `Post` 레코드의 `authorId`를 `20`으로 설정한다.

## 관계 유형

Prisma의 관계에는 세 가지 다른 유형(또는 카디널리티)가 있다.

- 일대일(1-1)
- 일대다(1-n)
- 다대다(m-n)

Prisma 스키마에는 모든 유형의 관계가 포함된다.

- 1-1: `User` ↔ `Profile`
- 1-n: `User` ↔ `Post`
- m-n: `Post` ↔ `Category`

관계형 데이터베이스와 MongoDB 간에 문법이 약간 다르다. 특히 다대다 관계가 그러하다.

다음 엔터티 관계 다이어그램은 샘플 Prisma 스키마에 해당하는 데이터베이스를 나타낸다.

<이미지>

## 용어

### 관계 필드

관계 필드는 스칼라 타입이 없는 Prisma 모델의 필드이다. 대신 그들의 타입은 또 다른 모델이다.

모든 관계에는 각 모델에 하나씩, 정확히 두 개의 관계 필드가 있어야 한다. 1-1 및 1-n 관계의 경우에는 `@relation` 속성의 두 관계 필드 중 하나에 의해 연결되는 추가 관계 스칼라 필드가 필요하다. 이 관계 스칼라는 기본 데이터베이스에 있는 외래 키의 직접적인 표현이다.

다음과 같은 두 모델이 있다고 가정한다.

```tsx
model User {
  id      Int      @id @default(autoincrement())
  posts   Post[]
  profile Profile?
}

model Profile {
  id     Int  @id @default(autoincrement())
  user   User @relation(fields: [userId], references: [id])
  userId Int  @unique // relation scalar field (used in the `@relation` attribute above)
}

model Post {
  id         Int        @id @default(autoincrement())
  author     User       @relation(fields: [authorId], references: [id])
  authorId   Int // relation scalar field  (used in the `@relation` attribute above)
  categories Category[]
}

model Category {
  id    Int    @id @default(autoincrement())
  posts Post[]
}
```

> **참고**
>
> [관계를 명확하게](https://www.prisma.io/docs/concepts/components/prisma-schema/relations#disambiguating-relations) 해야 하는 경우가 아니면 암시적 다대다 관계에는 `@relation` 속성이 필요하지 않다.

암시적 다대다 관계에서는 각 모델에 하나의 `@id`가 필요하다.

다음 사항을 유의해야 한다.

- [다중 필드 ID](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#id-1)를 사용할 수 없다.
- `@id` 대신 `@unique`를 사용할 수 없다.

이 기능을 사용하려면 명시적 다대다를 대신 설정해야 한다.

암시적 m-n 관계는 여전히 밑에 있는 데이터베이스의 관계 테이블에 나타난다. 그러나 이 관계 테이블은 Prisma에서 관리한다.

명시적 m-n 관계 대신 암시적 관계를 사용하면 다대다 관계에 대한 Prisma Client API가 좀 더 간단해진다. 예를 들어 [중첩 쓰기](https://www.prisma.io/docs/concepts/components/prisma-client/relation-queries#nested-writes) 내부에 중첩 수준이 하나 줄기 때문이다.

Prisma Migrate를 사용하지 않지만 분석에서 데이터 모델을 얻는 경우에도 [관계 테이블에 대한 Prisma의 컨벤션](https://www.prisma.io/docs/concepts/components/prisma-schema/relations/many-to-many-relations#conventions-for-relation-tables-in-implicit-m-n-relations)을 따르면 암시적 다대다 관계를 사용할 수 있다.

## 관계 필드

관계 필드는 스칼라 타입이 없는 Prisma 모델의 필드이다. 대신 유형은 다른 모델입니다.

모든 관계에는 각 모델에 하나씩 정확히 두 개의 관계 필드가 있어야 합니다. 1-1 및 1-n 관계 의 경우 속성 의 두 관계 필드 중 하나에 의해 연결되는 추가 *관계 스칼라 필드* 가 필요 합니다. `@relation`이 관계 스칼라는 기본 데이터베이스에 있는 *외래 키 의 직접적인 표현입니다.*

다음 두 모델을 고려하십시오.
