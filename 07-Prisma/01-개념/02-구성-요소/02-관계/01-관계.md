# 관계

관계는 프리즈마 스키마에서 두 모델 간의 **연결**이다.

예를 들어 한 사용자가 여러 블로그 게시물을 가질 수 있기 때문에 `User`와 `Post` 사이에는 일대다 관계가 있다.

다음 프리즈마 스키마는 `User`과 `Post` 모델 간의 일대다 관계를 정의한다.

```tsx
model User {
  id    Int    @id @default(autoincrement())
  posts Post[]
}

model Post {
  id       Int  @id @default(autoincrement())
  author   User @relation(fields: [authorId], references: [id])
  authorId Int // 관계 스칼라 필드 (위의 `@relation` 속성에 사용됨)
}
```

프리즈마 수준에서 `User`와 `Post` 관계는 다음으로 구성된다.

- 두 개의 관계 필드 - `author`와 `posts`. 관계 필드는 프리즈마 수준에서 모델 간의 연결을 정의하며 **데이터베이스에는 존재하지 않는다**. 이 필드는 프리즈마 클라이언트를 생성하는 데 사용된다.
- `@relation` 속성에서 참조하는 스칼라 `authorId` 필드이다. 이 필드는 **데이터베이스에 존재한다**. `Post`와 `User`를 연결하는 외래 키이다.

프리즈마 수준에서 두 모델 간의 연결은 항상 관계의 **양쪽**에 있는 관계 필드로 표현된다 .

## 데이터베이스의 관계

### 관계형 데이터베이스

다음 엔터티 관계 다이어그램은 관계형 데이터베이스의 `User`와 `Post` 테이블 간에 동일한 일대다 관계를 정의한다.

SQL에서는 **외래 키**를 사용하여 두 테이블 간의 관계를 생성한다. 외래 키는 관계의 **한쪽**에 저장된다.

위의 예시는 다음으로 구성된다.

- `Post` 테이블의 `authorId`라는 외래 키 열
- `User` 테이블의 `id`라는 주 키 열. `Post` 테이블의 `authorId`열은 `User` 테이블의 `id`열을 참조한다.

프리즈마 스키마에서 외래 키와 주 키 관계는 `author` 필드의 `@relation` 속성으로 표현된다.

```tsx
author     User        @relation(fields: [authorId], references: [id])
```

> **참고**
>
> 프리즈마 스키마의 관계는 데이터베이스의 테이블 사이에 존재하는 관계를 나타낸다. 데이터베이스에 관계가 없으면 프리즈마 스키마에도 존재하지 않는다.

## 프리즈마 클라이언트의 관계

프리즈마 클라이언트는 프리즈마 스키마에서 생성된다.

다음 예시는 프리즈마 클라이언트를 사용하여 레코드를 가져오고, 생성하고, 업데이트할 때 관계가 어떻게 나타나는지 보여준다.

다음 쿼리는 `User` 레코드와 두 개의 연결된 `Post` 레코드를 생성한다.

```tsx
const userAndPosts = await prisma.user.create({
  data: {
    posts: {
      create: [
        { title: 'Prisma Day 2020' }, // authorId를 user의 id로 채운다.
        { title: 'How to write a Prisma schema' }, // authorId를 user의 id로 채운다.
      ],
    },
  },
})
```

밑에 있는 데이터베이스에서 이 쿼리는 다음을 수행한다.

1. 자동 생성된 `id`로 `User`를 생성한다(예: `20`) .
2. 두 개의 새 `Post` 레코드를 생성하고 두 레코드의 `authorId`를 `20`으로 설정한다.

다음 쿼리는 `id`로 `User`를 검색하고 `Post` 레코드를 포함한다.

```tsx
const getAuthor = await prisma.user.findUnique({
  where: {
    id: "20",
  },
  include: {
    posts: true, // authorId == 20인 모든 포스터
  },
});
```

