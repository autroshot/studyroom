# 관계

관계는 프리즈마 스키마에서 두 모델 간의 **연결**이다.

예를 들어 한 사용자가 여러 블로그 게시물을 가질 수 있기 때문에 `User`와 `Post` 사이에는 일대다 관계가 있다.

다음 프리즈마 스키마는 `User`과 `Post` 모델 간의 일대다 관계를 정의한다.

```tsx
model User {
  id    Int    @id @default(autoincrement())
  posts Post[]
}

model Post {
  id       Int  @id @default(autoincrement())
  author   User @relation(fields: [authorId], references: [id])
  authorId Int // 관계 스칼라 필드 (위의 `@relation` 속성에 사용됨)
}
```

프리즈마 수준에서 `User`와 `Post` 관계는 다음으로 구성된다.

- 두 개의 관계 필드 - `author`와 `posts`. 관계 필드는 프리즈마 수준에서 모델 간의 연결을 정의하며 **데이터베이스에는 존재하지 않는다**. 이 필드는 프리즈마 클라이언트를 생성하는 데 사용된다.
- `@relation` 속성에서 참조하는 스칼라 `authorId` 필드이다. 이 필드는 **데이터베이스에 존재한다**. `Post`와 `User`를 연결하는 외래 키이다.

프리즈마 수준에서 두 모델 간의 연결은 항상 관계의 **양쪽**에 있는 관계 필드로 표현된다 .

## 데이터베이스의 관계

### 관계형 데이터베이스

다음 엔터티 관계 다이어그램은 관계형 데이터베이스의 `User`와 `Post` 테이블 간에 동일한 일대다 관계를 정의한다.

<이미지>

SQL에서는 **외래 키**를 사용하여 두 테이블 간의 관계를 생성한다. 외래 키는 관계의 **한쪽**에 저장된다.

위의 예시는 다음으로 구성된다.

- `Post` 테이블의 `authorId`라는 외래 키 열
- `User` 테이블의 `id`라는 주 키 열. `Post` 테이블의 `authorId`열은 `User` 테이블의 `id`열을 참조한다.

프리즈마 스키마에서 외래 키와 주 키 관계는 `author` 필드의 `@relation` 속성으로 표현된다.

```tsx
author     User        @relation(fields: [authorId], references: [id])
```

> **참고**
>
> 프리즈마 스키마의 관계는 데이터베이스의 테이블 사이에 존재하는 관계를 나타낸다. 데이터베이스에 관계가 없으면 프리즈마 스키마에도 존재하지 않는다.

## 프리즈마 클라이언트의 관계

프리즈마 클라이언트는 프리즈마 스키마에서 생성된다.

다음 예시는 프리즈마 클라이언트를 사용하여 레코드를 가져오고, 생성하고, 업데이트할 때 관계가 어떻게 나타나는지 보여준다.

다음 쿼리는 `User` 레코드와 두 개의 연결된 `Post` 레코드를 생성한다.

```tsx
const userAndPosts = await prisma.user.create({
  data: {
    posts: {
      create: [
        { title: 'Prisma Day 2020' }, // authorId를 user의 id로 채운다.
        { title: 'How to write a Prisma schema' }, // authorId를 user의 id로 채운다.
      ],
    },
  },
})
```

밑에 있는 데이터베이스에서 이 쿼리는 다음을 수행한다.

1. 자동 생성된 `id`로 `User`를 생성한다(예: `20`) .
2. 두 개의 새 `Post` 레코드를 생성하고 두 레코드의 `authorId`를 `20`으로 설정한다.

다음 쿼리는 `id`로 `User`를 검색하고 `Post` 레코드를 포함한다.

```tsx
const getAuthor = await prisma.user.findUnique({
  where: {
    id: "20",
  },
  include: {
    posts: true, // authorId == 20인 모든 포스터
  },
});
```

밑에 있는 데이터베이스에서 이 쿼리는 다음을 수행한다.

1. `id`가 `20`인 `User` 레코드를 검색한다.
2. `authorId`가 `20`인 모든 `Post` 레코드를 검색한다.

다음 쿼리는 기존 `Post` 레코드를 기존 `User` 레코드와 연결한다.

```tsx
const updateAuthor = await prisma.user.update({
  where: {
    id: 20,
  },
  data: {
    posts: {
      connect: {
        id: 4,
      },
    },
  },
})
```

밑에 있는 데이터베이스에서 이 쿼리는 다음을 수행한다.

1. `id`가 `4`인 `Post` 레코드의 `authorId`를 `20`으로 설정한다.

## 관계 유형

프리즈마의 관계에는 세 가지 다른 유형(또는 카디널리티)가 있다.

- 일대일(1-1)
- 일대다(1-n)
- 다대다(m-n)

프리즈마 스키마에는 모든 유형의 관계가 포함된다.

- 1-1: `User` ↔ `Profile`
- 1-n: `User` ↔ `Post`
- m-n: `Post` ↔ `Category`

관계형 데이터베이스와 몽고DB 간에 문법이 약간 다르다. 특히 다대다 관계가 그러하다.

다음 엔터티 관계 다이어그램은 샘플 프리즈마 스키마에 해당하는 데이터베이스를 나타낸다.

<이미지>

## 용어

### 관계 필드

관계 필드는 스칼라 타입이 없는 프리즈마 모델의 필드이다. 대신 그들의 타입은 또 다른 모델이다.

모든 관계에는 각 모델에 하나씩, 정확히 두 개의 관계 필드가 있어야 한다. 1-1 및 1-n 관계의 경우에는 `@relation` 속성의 두 관계 필드 중 하나에 의해 연결되는 추가 관계 스칼라 필드가 필요하다. 이 관계 스칼라는 밑에 있는 데이터베이스에 있는 외래 키의 직접적인 표현이다.

다음과 같은 모델이 있다고 가정한다.

```tsx
model User {
  id      Int      @id @default(autoincrement())
  posts   Post[]
  profile Profile?
}

model Profile {
  id     Int  @id @default(autoincrement())
  user   User @relation(fields: [userId], references: [id])
  userId Int  @unique // 관계 스칼라 필드 (위의 `@relation` 속성에서 사용됨)
}

model Post {
  id         Int        @id @default(autoincrement())
  author     User       @relation(fields: [authorId], references: [id])
  authorId   Int // 관계 스칼라 필드 (위의 `@relation` 속성에서 사용됨)
  categories Category[]
}

model Category {
  id    Int    @id @default(autoincrement())
  posts Post[]
}
```

> **참고**
>
> [관계를 명확하게](https://www.prisma.io/docs/concepts/components/prisma-schema/relations#disambiguating-relations) 해야 하는 경우가 아니면 암시적 다대다 관계에는 `@relation` 속성이 필요하지 않다.

암시적 다대다 관계에서는 각 모델에 하나의 `@id`가 필요하다.

다음 사항을 유의해야 한다.

- [다중 필드 ID](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#id-1)를 사용할 수 없다.
- `@id` 대신 `@unique`를 사용할 수 없다.

이 기능을 사용하려면 명시적 다대다를 대신 설정해야 한다.

암시적 m-n 관계는 여전히 밑에 있는 데이터베이스의 관계 테이블에 나타난다. 그러나 이 관계 테이블은 프리즈마에서 관리한다.

명시적 m-n 관계 대신 암시적 관계를 사용하면 다대다 관계에 대한 프리즈마 클라이언트 API가 좀 더 간단해진다. 예를 들어 [중첩 쓰기](https://www.prisma.io/docs/concepts/components/prisma-client/relation-queries#nested-writes) 내부에 중첩 수준이 하나 줄기 때문이다.

프리즈마 마이그레이트를 사용하지 않지만 분석에서 데이터 모델을 얻는 경우에도 [관계 테이블에 대한 프리즈마의 컨벤션](https://www.prisma.io/docs/concepts/components/prisma-schema/relations/many-to-many-relations#conventions-for-relation-tables-in-implicit-m-n-relations)을 따르면 암시적 다대다 관계를 사용할 수 있다.

다음과 같은 두 개의 모델이 있다고 가정한다.

```tsx
model User {
  id    Int    @id @default(autoincrement())
  email String @unique
  role  Role   @default(USER)
  posts Post[]
}

model Post {
  id       Int    @id @default(autoincrement())
  title    String
  author   User   @relation(fields: [authorId], references: [id])
  authorId Int // 관계 스칼라 필드 (위의 `@relation` 속성에서 사용됨)
}
```

이 모델들의 필드를 정리하면 다음과 같다.

| Model | Field    | Relational | Relation field           |
| :---- | :------- | :--------- | :----------------------- |
| User  | id       | Int        | 없음                     |
|       | email    | String     | 없음                     |
|       | role     | Role       | 없음                     |
|       | posts    | Post[]     | **있음** (프리스마 수준) |
| Post  | id       | Int        | 없음                     |
|       | title    | String     | 없음                     |
|       | authorId | Int        | 없음 (관계 스칼라 필드)  |
|       | author   | User       | **있음** (주석)          |

`posts`와 `author` 둘 다 타입이 스칼라 타입이 아니라 다른 모델이기 때문에 관계 필드이다.

또한 주석이 달린 관계 필드 `author`는 `@relation` 속성 내부의 `Post` 모델에 `authorId` 관계 스칼라 필드를 연결해야 한다. 관계 스칼라는 기본 데이터베이스의 외래 키를 표현한다.

다른 관계 필드인 `posts`는 순수하게 프리즈마 수준에서 정의되며 데이터베이스에는 표시되지 않는다.

### 주석이 달린 관계 필드와 관계 스칼라 필드

관계의 한쪽에 `@relation` 속성으로 주석을 달아야 하는 관계를 **주석이 달린 관계 필드**라고 한다.

주석이 달린 관계 필드에는 다음이 포함된다.

- 1-1
- 1-n
- 몽고DB 전용 m-n

`@relation` 속성으로 주석이 달린 관계 쪽은 밑에 있는 데이터베이스에 외래 키를 저장하는 쪽이다. 이 모델에는 외래 키를 나타내는 실제 필드도 필요한데 이를 **관계 스칼라 필드**라고 하며 `@relation` 속성 내부에서 참조된다.

```tsx
author     User    @relation(fields: [authorId], references: [id])
authorId   Int
```

스칼라 필드는 `@relation` 속성의 `fields`에서 사용될 때 관계 스칼라 필드가 된다.

> **참고**
>
> 관계 스칼라 필드는 생성된 프리즈마 클라이언트 API에서 읽기 전용이다. 코드에서 관계를 업데이트하려면 [중첩 쓰기](https://www.prisma.io/docs/concepts/components/prisma-client/relation-queries#nested-writes)를 사용하면 된다.

#### 관계 스칼라 명명 규칙

관계 스칼라 필드는 항상 관계 필드에 속하므로 다음 명명 규칙이 일반적이다.

- 관계 필드 - `author`
- 관계 스칼라 필드 - `authorId`(관계 필드 이름 + `Id`)

## @relation 속성

`@relation` 속성은 스칼라 필드가 아닌 관계 필드에만 사용할 수 있다.

`@relation` 속성은 다음과 같은 경우에 필요하다.

- 1-1 또는 1-n 관계를 정의하면 관계의 한쪽에 필요하다. (해당 관계 스칼라 필드에 필요)
- 관계를 명확하게 해야 한다. (예: 동일한 모델 간에 두 개의 관계가 있는 경우)
- 자기 관계를 정의한다.
- 몽고DB의 m-n을 정의한다.
- 관계 테이블이 밑에 있는 데이터베이스에서 표현되는 방식을 제어해야 한다. (예: 관계 테이블에 특정 이름 사용)

> **참고**
>
> 관계형 데이터베이스의 암시적 m-n 관계에는 `@relation` 속성이 필요하지 않다.

## 명확한 관계

두 개의 동일한 모델 간에 두 개의 관계를 정의할 때 `@relation` 속성에 `name` 인수를 추가하여 명확하게 해야 한다. 

예시:

```tsx
model User {
  id           Int     @id @default(autoincrement())
  name         String?
  writtenPosts Post[]
  pinnedPost   Post?
}

model Post {
  id         Int     @id @default(autoincrement())
  title      String?
  author     User    @relation(fields: [authorId], references: [id])
  authorId   Int
  pinnedBy   User?   @relation(fields: [pinnedById], references: [id])
  pinnedById Int?
}
```

이 경우 관계가 모호하며 이를 해석하는 방법은 다음과 같이 네 가지가 있다.

- `User.writtenPosts` ↔ `Post.author` + `Post.authorId`
- `User.writtenPosts` ↔ `Post.pinnedBy` + `Post.pinnedById`
- `User.pinnedPost` ↔ `Post.author` + `Post.authorId`
- `User.pinnedPost` ↔ `Post.pinnedBy` + `Post.pinnedById`

이러한 관계를 명확하게 하려면 `@relation` 속성으로 관계 필드에 주석을 달고 `name` 인수를 건네줘야 한다. 아무 `name`(빈 문자열 `""` 제외)으로 설정할 수 있지만 관계의 양쪽에서 동일할 필요가 있다.

```tsx
model User {
  id           Int     @id @default(autoincrement())
  name         String?
  writtenPosts Post[]  @relation("WrittenPosts")
  pinnedPost   Post?   @relation("PinnedPost")
}

model Post {
  id         Int     @id @default(autoincrement())
  title      String?
  author     User    @relation("WrittenPosts", fields: [authorId], references: [id])
  authorId   Int
  pinnedBy   User?   @relation(name: "PinnedPost", fields: [pinnedById], references: [id])
  pinnedById Int?
}
```

