# 데이터 모델

Prisma 스키마의 데이터 모델 정의 부분은 앱 모델(**Prisma 모델**이라고도 부름)을 정의한다.

모델의 역할은 다음과 같다.

- 앱 도메인 의 **엔터티**를 나타냄
- 데이터베이스의 **테이블**(PostgreSQL과 같은 관계형 데이터베이스)에 매핑
- 생성된 [Prisma Client API](https://www.prisma.io/docs/concepts/components/prisma-client)에서 사용 가능한 **쿼리**의 기초를 형성
- 타입스크립트와 함께 사용하면 Prisma Client는 모델에 대해 생성된 **타입 정의** 와 데이터베이스 접근을 완전히 안전한 타입으로 만들기 위한 모델의 [베리에이션](https://www.prisma.io/docs/concepts/components/prisma-client/advanced-type-safety/operating-against-partial-structures-of-model-types)을 제공

다음 스키마는 블로그 플랫폼을 설명한다.

```tsx
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  role    Role     @default(USER)
  posts   Post[]
  profile Profile?
}

model Profile {
  id     Int    @id @default(autoincrement())
  bio    String
  user   User   @relation(fields: [userId], references: [id])
  userId Int    @unique
}

model Post {
  id         Int        @id @default(autoincrement())
  createdAt  DateTime   @default(now())
  title      String
  published  Boolean    @default(false)
  author     User       @relation(fields: [authorId], references: [id])
  authorId   Int
  categories Category[] @relation(references: [id])
}

model Category {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[] @relation(references: [id])
}

enum Role {
  USER
  ADMIN
}
```

데이터 모델 정의는 다음으로 구성된다.

- 모델 간의 관계를 포함하여 여러 필드를 정의하는 모델
- 열거형(커넥터가 Enum을 지원하는 경우)
- 필드와 모델의 동작을 변경하는 속성과 함수

대응되는 데이터베이스는 다음과 같다.

![sample-database](https://user-images.githubusercontent.com/95019875/184317156-1bcc4bdc-d95e-44d6-8e33-14399d21d6e5.png)

하단의 쿼리는 이 데이터 모델에서 생성된 Prisma Client를 사용하여 다음을 생성한다.

- `User` 레코드
- 두 개의 중첩 `Post` 레코드
- 세 개의 중첩 `Category` 레코드

```tsx
const user = await prisma.user.create({
  data: {
    email: 'ariadne@prisma.io',
    name: 'Ariadne',
    posts: {
      create: [
        {
          title: 'My first day at Prisma',
          categories: {
            create: {
              name: 'Office',
            },
          },
        },
        {
          title: 'How to connect to a SQLite database',
          categories: {
            create: [{ name: 'Databases' }, { name: 'Tutorials' }],
          },
        },
      ],
    },
  },
})
```

데이터 모델은 앱 도메인을 반영한다.

예시:

- 전자 상거래 앱에는 `Customer`, `Order`, `Item`, `Invoice`와 같은 모델이 존재할 수 있다.
- 소셜 미디어 앱에는 `User`, `Post`, `Photo`, `Message`와 같은 모델이 존재할 수 있다.

## 분석과 마이그레이션

데이터 모델을 정의하는 방법은 두 가지가 있다.

- **데이터 모델을 직접 작성하고 Prisma Migrate 사용** - 데이터 모델을 직접 작성하고 [Prisma Migrate](https://www.prisma.io/docs/concepts/components/prisma-migrate)를 사용하여 데이터베이스에 매핑할 수 있다. 이 경우 데이터 모델은 앱 모델에 대한 믿을 만한 단일 소스이다.
- **분석을 통해 데이터 모델 생성** - 기존 데이터베이스가 있거나 데이터베이스 스키마를 SQL로 마이그레이션하는 것을 선호하는 경우 데이터베이스를 [분석](https://www.prisma.io/docs/concepts/components/introspection)하여 데이터 모델을 생성한다. 이 경우 데이터베이스 스키마는 앱 모델에 대한 믿을 만한 단일 소스이다.

## 모델 정의하기

모델은 앱 도메인의 엔터티를 나타낸다. 모델은 `model` 블록으로 표현되며 여러 필드를 정의한다. 예시 데이터 모델의 `User`, `Profile`, `Post`, `Category`가 모델이다.

블로그 플랫폼에 다음 모델을 추가하여 확장할 수 있다.

```tsx
model Comment {
  // 필드
}

model Tag {
  // 필드
}
```

### 테이블 또는 컬렉션에 모델 이름 매핑하기

Prisma 모델의 [명명 규칙(단수형, PascalCase)](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#naming-conventions)은 데이터베이스의 테이블 이름과 항상 일치하지는 않는다. 데이터베이스에서 테이블/컬렉션의 이름을 짓는 일반적인 방식은 복수형과 [snake_case](https://en.wikipedia.org/wiki/Snake_case) 표기법을 사용하는 것이다(예: `comments`). 이름이 `comments`인 테이블이 있는 데이터베이스를 분석한 Prisma 모델 결과는 다음과 같다.

```tsx
model comments {
  // 필드
}
```

그러나 [`@@map`](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#map-1) 속성을 사용하여 밑에 있는 데이터베이스의 원래 테이블 이름인 `comments`을 바꾸지 않고도 명명 규칙을 계속 준수하는 것이 가능하다.

```tsx
model Comment {
  // 필드

  @@map("comments")
}
```

이 모델 정의를 통해 Prisma는 `Comment` 모델을 밑에 있는 데이터베이스의 `comments` 테이블에 자동으로 매핑한다.

> **참고**
>
> 열 이름과 열거형 값을 [`@map`](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#map)하고 열거형을 `@@map`할 수 있다.

`@map`과 `@@map`을 사용하여 밑에 있는 데이터베이스의 테이블과 열 이름에서 모델과 필드 이름을 분리하여 [Prisma Client API의 모양을 조정할 수 있다](https://www.prisma.io/docs/concepts/components/prisma-client/working-with-prismaclient/use-custom-model-and-field-names#using-map-and-map-to-rename-fields-and-models-in-the-prisma-client-api).

## 필드 정의하기

필드는 모델의 속성으로 다음으로 구성된다.

- 필드 이름
- 필드 타입
- 선택적 타입 수정자
- [네이티브 데이터베이스 타입 속성](https://www.prisma.io/docs/concepts/components/prisma-schema/data-model#native-types-mapping)을 포함한 선택적 속성

필드 타입은 구조를 결정하며 다음 두 범주 중 하나에 속한다.

- 데이터베이스의 열(관계형 데이터베이스)에 매핑되는 스칼라 타입(enum 포함)이다. 그 예로는 `String`이나 `Int`가 있다.
- 모델 타입(이 필드를 관계 필드라고 함)이다. 그 예로는 `Post`나 `Comment[]`가 있다.

### 스칼라 필드

다음 예시는 여러 스칼라 타입으로 `Comment`와 `Tag` 모델을 확장한다. 일부 필드에는 속성이 포함된다.

```tsx
model Comment {
  id      Int    @id @default(autoincrement())
  title   String
  content String
}

model Tag {
  name String @id
}
```

[스칼라 필드 타입의 전체 목록](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#model-field-scalar-types)을 참고한다.

### 관계 필드

관계 필드의 타입은 다른 모델이다. 예를 들어 하나의 게시물(`Post`)에는 여러 댓글(`Comment[]`)이 있을 수 있다.

```tsx
model Post {
  id       Int       @id @default(autoincrement())
  // 다른 필드
  comments Comment[] // 하나의 게시물은 여러 댓글을 가질 수 있다.
}

model Comment {
  id     Int
  // 다른 필드
  Post   Post? @relation(fields: [postId], references: [id]) // 하나의 댓글은 하나의 게시물을 가질 수 있다.
  postId Int?
}
```

모델 간의 관계에 대한 자세한 예시와 정보는 [관계 문서](https://www.prisma.io/docs/concepts/components/prisma-schema/relations)를 참고한다.

### 네이티브 타입 매핑

버전 2.17.0 이상은 밑에 있는 데이터베이스 타입을 설명하는 네이티브 데이터베이스 타입 속성을 지원한다.

```tsx
model Post {
  id      Int    @id
  title   String @db.VarChar(200)
  content String
}
```

타입 속성의 사용법은 다음과 같다.

- 밑에 있는 제공자에 따라 다르다. 예를 들어 PostgreSQL은 `Boolean`으로 `@db.Boolean`를 사용하지만 MySQL은 `@db.TinyInt(1)`을 사용한다.
- PascalCase로 작성한다(예: `VarChar` 또는 `Text`).
- 접두사가 `@db`. 여기서 `db`는 스키마의 `datasource` 블록의 이름이다.

또한 분석 과정 동안, 밑에 있는 네이티브 타입이 기본 타입이 아닌 경우에만 타입 속성이 스키마에 추가된다.

예를 들어 PostgreSQL 공급자를 사용하는 경우, 밑에 있는 네이티브 타입이 `text`인 `string` 필드에는 타입 속성이 없다.

[스칼라 타입 및 공급자별 네이티브 데이터베이스 타입 속성의 전체 목록](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#model-field-scalar-types)을 참고한다.

#### 이점과 워크플로

- Prisma Migrate가 데이터베이스에서 생성하는 정확한 네이티브 타입을 제어한다. 예를 들어 `String`은 `@db.VarChar(200)`이나 `@db.Char(50)`가 될 수 있다.
- 분석할 때 풍부한 스키마를 볼 수 있다.

### 타입 수정자

필드 타입은 다음 두 수정자 중 하나를 추가하여 수정할 수 있다.

- `[]`는 필드를 목록으로 만든다.
- `?`는 필드를 선택 사항으로 만든다.

> **참고**
>
> 타입 수정자를 결합하는 것은 불가능하다. 선택적 목록은 지원되지 않는다.

#### 목록

다음 예시에는 스칼라 목록과 관련 모델의 목록이 포함되어 있다.

```tsx
model Post {
  id       Int       @id @default(autoincrement())
  // 다른 필드
  comments Comment[] // 댓글 목록
  keywords String[] // 스칼라 목록
}
```

> **참고**
>
> 스칼라 목록은 데이터베이스 커넥터가 네이티브로 또는 Prisma 수준에서 지원하는 경우에만 사용 가능하다.

#### 선택 필드와 필수 필드

```tsx
model Comment {
  id      Int     @id @default(autoincrement())
  title   String
  content String?
}

model Tag {
  name String @id
}
```

`?` 타입 수정자가 필드에 달려 있지 않으면 모델의 모든 레코드에 필드가 필요하다. 이것은 두 가지 수준에 영향을 준다.

- **데이터베이스** - 필수 필드는 밑에 있는 데이터베이스의 `NOT NULL` 제약 조건을 통해 표시된다.
- **Prisma Client** - 앱 코드에서 모델을 나타내는 Prisma Client의 생성된 타입스크립트 타입은 런타임 시 항상 값을 전달하도록 이러한 필드를 필요에 따라 정의한다.

> **참고**
>
> 선택 필드의 기본값은 `null`이다.

### 지원되지 않는 타입

관계형 데이터베이스를 분석할 때 지원되지 않는 타입은 [`Unsupported`](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#unsupported)로 추가된다.

```tsx
location    Unsupported("polygon")?
```

`Unsupported` 속성을 사용하면 Prisma에서 아직 지원하지 않는 데이터베이스 타입에 대해 Prisma 스키마의 필드를 정의할 수 있다.

예를 들어 MySQL의 `POLYGON` 타입은 현재 Prisma에서 지원되지 않지만 이제 `Unsupported("polygon")` 타입을 사용하여 Prisma 스키마에 추가하는 것이 가능하다.

`Unsupported` 필드는 생성된 Prisma Client API에서 사용할 수 없지만 여전히 Prisma의 [원시 데이터베이스 액세스](https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access) 기능을 사용하여 이런 필드를 쿼리할 수 있다.

> **참고**
>
> 모델에 필수 `Unsupported` 필드가 있는 경우, 생성된 클라이언트는 해당 모델에 대한 `create`나 `update` 메소드를 포함하지 않는다.

## 속성 정의하기

속성은 필드나 모델 블록의 동작을 변경한다.

다음 예시는 세 가지 필드 속성(`@id`, `@default`, `@unique`)과 하나의 블록 속성(`@@unique`)을 포함한다.

```tsx
model User {
  id        Int     @id @default(autoincrement())
  firstName String
  lastName  String
  email     String  @unique
  isAdmin   Boolean @default(false)

  @@unique([firstName, lastName])
}
```

일부 속성은 인수를 허용한다.

예를 들어 `@default`는 `true`나 `false`를 허용한다.

```tsx
isAdmin   Boolean @default(false) // @default(value: false)의 짧은 형식이다.
```

[필드와 블록 속성의 전체 목록](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#attributes)을 참고한다.

### ID 필드 정의하기

ID는 모델의 개별 레코드를 고유하게 식별한다. 모델은 하나의 ID만 가질 수 있다.

관계형 데이터베이스에서 ID는 단일 필드이거나 복수의 필드로 구성될 수 있다. 모델에 `@id`나 `@@id`가 없으면 대신 필수 `@unique` 필드나 `@@unique` 블록을 정의해야 한다.

#### 관계형 데이터베이스에서 ID 정의하기

관계형 데이터베이스에서 ID는 `@id` 속성을 사용하는 단일 필드나, `@@id` 속성을 사용하는 복수의 필드로 정의할 수 있다.

##### 단일 필드 ID

다음 예시에서 `User` ID는 `id` `integer` 필드로 표현된다.

```tsx
model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  role    Role     @default(USER)
  posts   Post[]
  profile Profile?
}
```

##### 복합 ID

다음 예시에서 `User` ID는 `firstName`과 `lastName` 필드의 조합으로 표현된다.

```tsx
model User {
  firstName String
  lastName  String
  email     String  @unique
  isAdmin   Boolean @default(false)

  @@id([firstName, lastName])
}
```

##### 고유 식별자 @unique 필드

다음 예시에서 사용자는 `@unique` 필드로 고유하게 식별된다. `email` 필드는 모델의 고유 식별자로 기능하기 때문에(이는 Prisma에서 필요함) 필수 필드여야 한다.

```tsx
model User {
  email   String   @unique
  name    String?
  role    Role     @default(USER)
  posts   Post[]
  profile Profile?
}
```

> **관계형 데이터베이스의 제약 조건의 이름**
>
> 원한다면 밑에 있는 데이터베이스의 [주 키 제약 조건의 이름을 커스터마이징](https://www.prisma.io/docs/concepts/components/prisma-schema/names-in-underlying-database#constraint-and-index-names)할 수 있다.

### 기본값 정의하기

`@default` 속성을 사용하여 모델의 스칼라 필드에 대한 기본값을 정의할 수 있다.

```tsx
model Post {
  id         Int        @id @default(autoincrement())
  createdAt  DateTime   @default(now())
  title      String
  published  Boolean    @default(false)
  author     User       @relation(fields: [authorId], references: [id])
  authorId   Int
  categories Category[] @relation(references: [id])
}
```

`@default` 속성은 다음 중 하나가 가능하다.

- 밑에 있는 데이터베이스(관계형 데이터베이스만 해당)의 `DEFAULT` 값을 표현한다.
- Prisma 수준 함수를 사용한다. 예를 들어 `cuid()`와 `uuid()`는 모든 커넥터에 Prisma의 [쿼리 엔진](https://www.prisma.io/docs/concepts/components/prisma-engines/query-engine)에서 제공된다.

기본값은 다음이 될 수 있다.

- 필드 타입에 해당하는 정적 값 - `5`(`Int`), `Hello`(`String`), `false`(`Boolean`)
- 정적 값의 목록 - 버전 `4.0.0` 이후에 지원되는 데이터베이스(PostgreSQL, CockroachDB, 몽고DB)에서 가능하다. 그 예시는 `[5, 6, 8]`(`Int[]`), `["Hello", "Goodbye"]`(`String`[])이다.
- 함수 - `now()`, `uuid()`

> **참고**
>
> 함수에 대한 커넥터 지원은 [속성 함수 레퍼런스 문서](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#attribute-functions)를 참고한다.

### 고유 필드 정의하기

모델에 고유 속성을 추가하여 해당 모델의 개별 레코드를 고유하게 식별할 수 있다. 고유 속성은 단일 필드에 `@unique` 속성을 사용하거나 복수의 필드(복합 고유 제약 조건으로도 불림)에 `@@unique` 속성을 사용하여 정의될 수 있다.

다음 예시에서 `email` 필드의 값은 고유해야 한다.

```tsx
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}
```

다음 예시에서 `authorId`와 `title`의 조합은 고유해야 한다.

```tsx
model Post {
  id         Int        @id @default(autoincrement())
  createdAt  DateTime   @default(now())
  title      String
  published  Boolean    @default(false)
  author     User       @relation(fields: [authorId], references: [id])
  authorId   Int
  categories Category[] @relation(references: [id])

  @@unique([authorId, title])
}
```

> **관계형 데이터베이스의 제약 조건의 이름**
>
> 원한다면 밑에 있는 데이터베이스의 [제약 조건의 이름을 커스터마이징](https://www.prisma.io/docs/concepts/components/prisma-schema/names-in-underlying-database#constraint-and-index-names)할 수 있다.

### 인덱스 정의하기

`@@index`를 이용해 모델의 하나 또는 여러 필드에 대한 인덱스를 정의할 수 있다.

다음 예시는 `title`과 `content` 필드를 기반으로 다중 열 인덱스를 정의한다.

```tsx
model Post {
  id      Int     @id @default(autoincrement())
  title   String
  content String?

  @@index([title, content])
}
```

> **관계형 데이터베이스의 제약 조건의 이름**
>
> 원한다면 밑에 있는 데이터베이스의 [인덱스의 이름을 커스터마이징](https://www.prisma.io/docs/concepts/components/prisma-schema/names-in-underlying-database#constraint-and-index-names)할 수 있다.

## 열거형 정의하기

열거형이 네이티브로 또는 Prisma 수준에서 [열거형이 데이터베이스 커넥터에 대해 지원되는 경우](https://www.prisma.io/docs/reference/database-reference/database-features#misc) 데이터 모델에서 열거형을 정의할 수 있다.

열거형은 Prisma 데이터 모델에서 스칼라 타입으로 간주된다. 따라서 기본적으로 Prisma Client 쿼리에 반환값으로 포함된다.

열거형은 `enum` 블록으로 정의된다.

예를 들어 `User`에는 `Role`이 있다.

```tsx
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  role  Role    @default(USER)
}

enum Role {
  USER
  ADMIN
}
```

## 함수 사용하기

Prisma 스키마는 여러 함수를 지원한다. 이들은 모델의 필드에 기본값을 지정하는 데 사용할 수 있다.

예를 들어 다음 `createdAt`의 기본값은 `now()`이다.

```tsx
model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
}
```

`cuid()`와 `uuid()`는 Prisma에 의해 구현되므로 밑에 있는 데이터베이스 스키마에서 **보이지 않는다**. 직접 Prisma 스키마를 변경하고 Prisma Client를 생성하여 분석을 사용할 때 여전히 해당 값을 사용할 수 있다. 이 경우 값은 Prisma의 쿼리 엔진에 의해 생성된다.

`autoincrement()`, `now()`, `dbgenerated()`에 대한 지원은 데이터베이스마다 다르다.

관계형 데이터베이스 커넥터는 데이터베이스 수준에서 `autoincrement()`, `dbgenerated()`, `now()`를 구현한다. 몽고DB 커넥터는 `autoincrement()`, `dbgenerated()`를 지원하지 않으며 `now()`는 Prisma 수준에서 구현된다. `auto()` 함수는 `ObjectId`를 생성하는 데 사용된다.

## 관계

모델 간의 관계에 대한 자세한 예시와 정보는 [관계 문서](https://www.prisma.io/docs/concepts/components/prisma-schema/relations)를 참조한다.

## Prisma 클라이언트의 모델

### 쿼리(CRUD)

데이터 모델 정의의 모든 모델은 생성된 Prisma Client API에서 여러 CRUD 쿼리를 생성한다.

- `findMany`
- `findUnique`
- `create`
- `update`
- `upsert`
- `delete`
- `updateMany`
- `deleteMany`

Prisma Client 인스턴스에서 생성된 프로퍼티를 통해 작업에 접근할 수 있다. 기본적으로 프로퍼티의 이름은 모델 이름의 소문자 형식이다(예: `User` 모델은 `user`, `Post` 모델은 `post`).

다음은 Prisma Client API의 `user` 프로퍼티 사용을 보여주는 예시이다.

```tsx
const newUser = await prisma.user.create({
  data: {
    name: 'Alice',
  },
})
const allUsers = await prisma.user.findMany()
```

### 타입 정의

Prisma Client는 모델 구조를 반영하는 타입 정의를 생성한다. 이는 생성된 [`@prisma/client`](https://www.prisma.io/docs/concepts/components/prisma-client/working-with-prismaclient/generating-prisma-client#the-prismaclient-npm-package) 노드 모듈의 일부이다.

타입스크립트를 사용할 때 이러한 타입 정의는 모든 데이터베이스 쿼리가 완전히 타입에 안전하고 컴파일 타임에 유효성이 검사되도록 한다. 이는 `select`나 `include`를 사용하는 부분적인 쿼리에도 적용된다.

순수 자바스크립트를 사용하는 경우에도 타입 정의는 여전히 `@prisma/client` 노드 모듈에 포함되어 편집기에서 인텔리센스나 자동완성과 같은 기능을 활성화한다.

> **참고**
>
> 실제 타입은 `.prisma/client` 폴더에 저장된다. `@prisma/client/index.d.ts`는 이 폴더의 내용을 내보낸다.

예를 들어 위의 `User` 모델에 대한 타입 정의는 다음과 같다.

```tsx
export type User = {
  id: number
  email: string
  name: string | null
  role: string
}
```

관계 필드 `posts`와 `profile`는 기본적으로 타입 정의에 포함되지 않는다. 그러나 `User` 타입의 베리에이션이 필요한 경우에는 Prisma Client에서 생성한 일부 헬퍼 타입을 사용하여 정의할 수 있다. 이 경우 이러한 헬퍼 타입은 `UserGetIncludePayload`와 `UserGetSelectPayload`라고 부른다.
