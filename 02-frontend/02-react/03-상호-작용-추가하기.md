# 상호 작용 추가하기

## 상태: 컴포넌트의 메모리

렌더링 간에 데이터를 기억하고 리렌더링을 유발하고 싶을 때 상태를 사용한다.

모든 리액트 훅은 반복문, 조건문, 중첩 함수 내부가 아닌 컴포넌트 최상위에서만 호출할 수 있다. 이는 리액트가 훅을 식별자가 아닌 호출 순서로 기억하기 때문이다.

동일한 컴포넌트를 다른 곳에 렌더링해도 상태는 공유되지 않는다. 상태를 공유하고 싶다면 상태 끌어올리기를 사용해야 한다.

## 렌더링과 커밋

리액트의 모든 화면 갱신은 다음 과정을 따른다.

### 1. 렌더링 트리거

렌더링을 트리거하는 것은 두 가지다.

- 초기 렌더링

- 컴포넌트(또는 상위 컴포넌트 중 하나)의 상태가 갱신됨

### 2. 컴포넌트 렌더링

리액트의 렌더링은 컴포넌트(함수) 호출을 의미한다.

초기 렌더링에서는 루트 컴포넌트를 호출한다. 후속 렌더링에서는 상태가 갱신된 컴포넌트를 호출한다.

렌더링 프로세스는 재귀적이다. 하위 컴포넌트도 렌더링된다.

### 3. DOM에 커밋

리액트는 렌더링 결과와 다른 DOM 노드만 변경한다. 즉, 리액트는 렌더링 결과가 지난번과 같으면 DOM을 건드리지 않는다.

브라우저는 갱신된 DOM에 따라 화면을 다시 그린다.

## 스냅숏으로의 상태

상태 설정은 렌더링을 트리거한다.

사용자 이벤트에 대한 응답으로 인터페이스가 직접 변경되는 대신, 상태가 변경되고 컴포넌트가 리렌더링된다.

별도의 선반에 있는 것처럼 상태는 함수 외부에 존재한다. 컴포넌트는 요청이 들어오면 상태 값을 선반에서 꺼내 갱신하고 함수를 실행한다.

다음 예시에서 버튼을 클릭하면 경고 창에서 `0`이 출력된다. 비동기일지라도 상태 변수의 값은 렌더링 내에서 절대 변경되지 않기 때문이다. 상태가 `0`일 때의 스냅숏이 찍혔다고 이해할 수 있다.

```jsx
export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 5);
        setTimeout(() => {
          alert(number);
        }, 3000);
      }}>+5</button>
    </>
  )
}
```

이벤트 처리기 내부에서 `number`를 `0`으로 치환하면 이해가 쉽다.

```jsx
setNumber(0 + 5);
setTimeout(() => {
  alert(0);
}, 3000);
```

**리액트는 단일 렌더링의 이벤트 처리기 내에서 상태 값을 '고정'한다.**

## 일련의 상태 갱신을 대기열에 추가하기

리액트는 상태 갱신 전에 이벤트 처리기의 모든 코드가 실행될 때까지 기다린다. 일괄 처리(batching)로도 불리는 이 동작은 불필요한 리렌더링을 막고 리액트 앱의 속도를 빠르게 만들어 준다.

하나의 이벤트에서 상태를 여러 번 갱신하고 싶다면 갱신(updater) 함수를 사용한다. 이는 리액트에게 '상태 값으로 무언가를 하라'고 지시하는 것이다.

```jsx
setNumber(number => number + 1);
```

