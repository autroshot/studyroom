# 알고리즘

## 그리디

탐욕법 혹은 욕심쟁이 알고리즘으로도 불린다.

**현재 상황에서 지금 당장 좋은 것만 고르는 방법이다.**

대표적인 예는 거스름돈 문제이다. 다만 그리디로 풀 수 있는 거스름돈 문제는 큰 단위가 항상 작은 단위가 배수여야 한다.

## 구현

**머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정이다.**

어떤 문제를 풀든 구현은 포함된다.

다음 두 가지가 구현에 포함된다.

- 완전 탐색: 모든 경우의 수를 다 계산함
- 시뮬레이션: 문제에서 제시한 알고리즘을 한 단계씩 차례대로 수행함

## DFS/BFS

### 사전 지식

**탐색**은 어떤 데이터들 중에서 원하는 데이터를 찾는 과정을 의미한다. 대표적인 탐색 알고리즘이 DFS와 BFS이다.

DFS/BFS를 배우기 위해서는 스택, 큐, 재귀 함수를 알아야 한다.

#### 스택과 큐

자료구조란 데이터를 표현하고 관리하고 처리하기 위한 구조이다. **스택**과 **큐**는 자료구조 중 하나이다.

|                  | 스택(Stack)                       | 큐(Queue)                          |
| ---------------- | --------------------------------- | ---------------------------------- |
| 비유             | 박스 쌓기                         | 대기 줄                            |
| 방식             | 선입후출, FILO(First In Last Out) | 선입선출, FIFO(First In First Out) |
| 관련 배열 메서드 | `push`, `pop`                     | `push`, `shift`                    |

#### 재귀 함수

**재귀 함수**는 자기 자신을 다시 호출하는 함수를 의미한다. 재귀 함수는 프랙털 구조와 흡사하다.

재귀 함수를 사용할 때는 종료 조건이 반드시 필요하다.

컴퓨터 내부에서 재귀 함수의 수행은 스택 자료구조를 이용한다. 가장 마지막에 호출된 함수가 먼저 수행을 끝내야 하기 때문이다.

재귀 함수는 수학의 점화식과 형태가 유사하다.

재귀 함수는 반복문으로 구현할 수 있지만, 보통 재귀 함수의 코드가 더 간결하다.

재귀 함수를 이용하는 대표적인 예로는 팩토리얼 문제가 있다.

#### 그래프

<img src="https://github.com/autroshot/studyroom/assets/95019875/c68d609e-042d-47e6-9612-dfe5005406d9" alt="그래프 구조" style="zoom: 25%;" />

그래프는 정점(Vertex)와 간선(Edge)로 표현된다. 정점을 노드(Node)라고 부르기도 한다.

두 정점이 간선으로 연결되어 있으면, 두 정점은 인접했다(adjacent)고 표현한다.

정점을 도시, 간선을 도로에 비유할 수 있다.

프로그래밍에서는 그래프를 크게 두 가지 방식으로 표현할 수 있다.

- 인접 행렬: 2차원 배열로 표현
- 인접 리스트: 연결 리스트(Linked List)로 표현

다음은 인접 행렬을 구현한 예시이다.

```js
// 가중치 포함

// 연결이 안 된 두 정점의 간선을 표현
const INF = 999999999;

const graph = [
    [0, 7, 5],
    [7, 0, INF],
    [5, INF, 0],
];
```

다음은 인접 리스트를 구현한 예시이다.

```js
const graph = {
	A: ['B', 'C'],
	B: ['C', 'E'],
	C: ['D'],
	D: ['E'],
};
```

또는

```js
// 가중치 포함
const graph = [
	[[1, 7], [2, 5]],
	[[0, 7]],
	[[0, 5]],
];
```

인접 행렬은 모든 관계를 저장하므로 메모리 낭비가 있다. 하지만 인접 리스트와 비교해 검색 속도가 빠르다.

### DFS

DFS(Depth First Search)는 깊이 우선 탐색으로, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.

스택과 관련있다.

### BFS

BFS(Breadth First Search)는 너비 우선 탐색으로, 가까운 노드부터 탐색하는 알고리즘이다.

큐와 관련있다.

### 비교

DFS를 재귀 함수로 구현하는 경우, 보통은 BFS가 DFS보다 조금 더 빠르다.

## 정렬

**정렬**은 데이터를 특정한 기준에 따라서 순서대로 나열하는 것을 말한다. 정렬은 이진 탐색의 전처리 과정이기도 하다.

### 선택 정렬

'가장 작은 것을 선택한다'는 의미의 선택 정렬(selection sort)이다. 가장 작은 데이터를 선택하여 맨 앞 데이터와 바꾸는 과정을 반복한다.

시간 복잡도는 $O(N^2)$이다. 뒤에서 배울 정렬에 비해서는 느린 편이다.

### 삽입 정렬

'적절한 위치에 삽입한다'는 의미의 삽입 정렬(insertion sort)이다.

시간 복잡도는 $O(N^2)$이다. 하지만 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작한다. 최선의 경우 시간 복잡도는 $O(N)$이다.

### 퀵 정렬

가장 많이 사용되는 알고리즘이다. '병합 정렬'과 함께 대부분의 정렬 라이브러리의 근간이 된다.

기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾼다.

기준을 피벗(pivot)이라고 부른다.

정렬 과정을 간단히 정리하면 다음과 같다.

1. 리스트의 첫 번째 데이터를 피벗으로 설정한다.
2. 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾아 두 데이터의 위치를 변경한다.
3. 2번을 반복하다 위치가 서로 엇갈리면 작은 데이터와 피벗의 위치를 변경한다.
4. 이제 피벗을 기준으로 분할된 두 리스트에 대해 리스트의 원소가 하나만 남을 때까지 위의 과정을 반복한다.

평균 시간 복잡도는 $O(NlogN)$이다. 앞의 두 정렬 알고리즘에 비해 훨씬 빠르다. 하지만 이미 데이터가 정렬되어 있는 최악의 경우에는 시간 복잡도는 $O(N^2)$으로 동일하다.

### 계수 정렬

특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠르다. 데이터의 범위가 크지 않고 정수 형태일 때 사용할 수 있다.

별도의 리스트에 정렬에 대한 정보는 저장한다. 리스트의 인덱스가 데이터의 범위를 포함할 수 있어야 한다.

데이터의 개수가 N, 최댓값의 크기가 K일 때, 시간 복잡도는 $O(N+k)$이다. 데이터의 범위가 한정적일 때 효과적이다. 예를 들어 데이터가 0과 1000000, 단 2개만 존재할 때는 매우 비효율적인 것을 알 수 있다.

### 정리

대부분의 경우에는 언어에 내장된 정렬 라이브러리를 사용하고, 특별한 경우에만 계수 정렬을 사용하는 것을 추천한다.
