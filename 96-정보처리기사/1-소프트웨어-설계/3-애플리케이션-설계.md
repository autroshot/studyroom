# 3장: 애플리케이션 설계

## 16섹션: 소프트웨어 아키텍처

### 소프트웨어 아키텍처의 설계

**소프트웨어 아키텍처**는 소프트웨어의 기본 구조이자, 구성 요소들 간의 관계를 표현하는 시스템의 구조이다.

설계는 다음과 같이 구분할 수 있다.

|           | 상위 설계                | 하위 설계                     |
| --------- | ------------------------ | ----------------------------- |
| 별칭      | 아키텍처 설계, 예비 설계 | 모듈 설계, 상세 설계          |
| 설계 대상 | 시스템의 전체적인 구조   | 시스템의 내부 구조 및 행위    |
| 세부 목록 | 구조, DB, 인터페이스     | 컴포넌트, 자료 구조, 알고리즘 |

아키텍처 설계의 기본 원리는 다음과 같다.

- **모듈화(Modularity)**
- **추상화(Abstraction)**
  - 과정 추상화
  - 데이터 추상화
  - 제어 추상화
- **단계적 분해(Stepwise Refinement)**: 하향식 설계 전략
- **정보 은닉(Information Hiding)**

### 소프트웨어 아키텍처의 품질 속성

- 시스템 측면: 성능, 보안, 가용성, 사용성, 변경 용이성 등
- 비즈니스 측면: 시장 적시성, 비용과 혜택, 예상 시스템 수명 등
- 아키텍처 측면: 개념적 무결성, 정확성, 완결성, 구축 가능성

### 소프트웨어 아키텍처의 설계 과정

**설계 목표 설정 → 시스템 타입 결정 → 아키텍처 패턴 적용 → 서브시스템 구체화 → 검토**

> [!NOTE]
>
> ##### 시스템 타입
>
> - 대화형 시스템: 대부분의 웹 애플리케이션
> - 이벤트 중심 시스템: 전화, 비상벨 등의 내장 소프트웨어
> - 변환형 시스템: 컴파일러, 네트워크 프로토콜
> - 객체 영속형 시스템: 서버 관리 소프트웨어
>
> ##### 협약(Contract)에 의한 설계
>
> 컴포넌트에 대한 정확한 인터페이스를 명시한다. 명세에 포함될 조건은 다음과 같다.
>
> - 선행 조건(Precondition)
> - 결과 조건(Postcondition)
> - 불변 조건(Invariant): 항상 만족되어야 하는 조건

## 17섹션: 아키텍처 패턴

### 아키텍처 패턴(Patterns)의 개요

아키텍처를 설계할 때 참조할 수 있는 **전형적인 해결 방식**이다. 아키텍처 스타일 또는 표준 아키텍처라고도 한다.

### 레이어 패턴(Layers pattern)

- 시스템을 **계층(Layer)으로 구분**하여 구성하는 고전적인 방법 중 하나다.
- 하위 계층은 상위 계층에 대한 서비스 제공자가 되고, 상위 계층은 하위 계층의 클라이언트가 된다.
- 예) OSI 참조 모델

### 클라이언트-서버 패턴(Client-Server Pattern)

- **하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트**로 구성된다.

### 파이프-필터 패턴(Pipe-Filter Pattern)

- 데이터 스트림 절차의 각 단계를 **필터(Filter)** 컴포넌트로 캡슐화하여 **파이프(Pipe)**를 통해 데이터를 전송하는 패턴이다.
- 예) UNIX의 쉘(Shell)

### 모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern)

- 모델: 서브시스템의 핵심 기능과 데이터를 **보관**
- 뷰: 사용자에게 정보를 **표시**
- 컨트롤러: 사용자로부터 **변경** 요청을 받아 모델에게 명령을 보냄

### 기타 패턴

- 마스터-슬레이브 패턴(Master-Slave Pattern): 예) 장애 허용 시스템, 병렬 컴퓨팅 시스템
- 브로커 패턴: 예) 분산 환경 시스템
- 피어-투-피어 패턴: 멀티스레딩 방식
- 이벤트-버스 패턴
- 블랙보드 패턴: 예) 음성 인식, 차량 식별, 신호 해석
- 인터프리터 패턴

## 18섹션: 객체지향(Object-Oriented)

### 객체지향의 개요

개체(Entity)를 하나의 객체(Object)로 만들어, **객체들을 조립**해서 소프트웨어를 만드는 기법이다.

재사용 및 확장이 어렵다는 기존 구조적 기법의 문제점을 해결한다.

### 객체(Object)

**데이터**(속성, 상태, 변수, 자료 구조)와 **데이터를 처리하는 함수**(메소드, 서비스, 동작, 연산)를 묶어 놓은 하나의 소프트웨어 모듈이다.

- **메시지(Message)**: 객체에게 어떤 행위를 하도록 지시하는 명령이다.

### 클래스(Class)

공통된 속성과 연산을 갖는 **객체의 집합**으로, 객체의 일반적인 타입을 의미한다.

- **인스턴스(Instance)**: 클래스에 속한 각각의 객체
- 슈퍼 클래스/서브 클래스

### 캡슐화(Encapsulation)

**데이터와 함수를 하나로 묶는 것**을 의미한다.

### 상속(Inheritance)

상위 클래스의 모든 속성과 연산을 하위 클래스가 **물려받는** 것이다.

- **다중 상속(Multiple Inheritance)**: 하나의 클래스가 두 개 이상의 상위 클래스로부터 상속받는 것

### 다형성(Polymorphism)

하나의 메시지에 대해 여러 가지 형태의 응답이 있다는 것을 의미한다.

**오버로딩**과 **오버라이딩**이 대표적인 예이다.

### 연관성(Relationship)

둘 이상의 객체들이 상호 참조하는 관계를 말한다.

- 연관화
- 분류화
- 집단화(Aggregation): 관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것
- 일반화
- 특수화/상세화

## 19섹션: 객체지향 분석 및 설계

### 객체지향 분석의 개념

객체지향 분석(OOA; Object Oriented Analysis)은 요구사항과 관련된 모든 클래스(객체)와 그들 간의 관계 등을 정의하여 모델링하는 작업이다.

### 객체지향 분석의 방법론

- **럼바우(Rumbaugh) 방법**: **가장 일반적인 방법**으로 객체 모델링 기법(OMT; Object-Modeling Technique)이라고도 한다. 분석 활동은 **객체 모델 → 동적 모델 → 기능 모델** 순으로 이루어진다.
  - **객체 모델링(Object Modeling)**: 객체 다이어그램을 이용
  - **동적 모델링(Dynamic Modeling)**: 상태 다이어그램(상태도)을 이용
  - **기능 모델링(Functional Modeling)**: 자료 흐름도(DFD)를 이용
- 부치(Booch) 방법: 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 분석 방법
- Jacobson 방법: 사용 사례(Use Case)를 사용하는 분석 방법
- **Coad와 Yourdon 방법**: **E-R 다이어그램**을 사용
- Wirfs-Brock 방법: 분석과 설계 간에 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 기법

### 객체지향 설계 원칙

앞 글자를 따 **SOLID 원칙**이라고도 부른다.

- **단일 책임 원칙(SRP; Single Responsibility Principle)**: 객체는 단 하나의 책임만 가져야 한다.
- **개방-폐쇄 원칙(OCP; Open-Closed Principle)**: 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다.
- **리스코프 치환 원칙(LSP; Liskov Substitution Principle)**: 자식 클래스는 최소한 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.
- **인터페이스 분리 원칙(ISP; Interface Segregation Principle)**: 자신이 사용하지 않는 인터페이스 또는 메소드와 의존 관계를 맺거나 영향을 받지 않아야 한다.
- **의존 역전 원칙(DIP; Dependency Inversion Principle)**: 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다.

## 20섹션: 모듈

### 모듈(Module)의 개요

모듈화를 통해 분리된 시스템의 각 기능들이다. 서브루틴, 서브시스템, 프로그램, 작업 단위로도 부른다.

- 모듈의 독립성을 높이려면 **모듈의 결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게** 만들어야 한다.

### 결합도(Coupling)

모듈 간에 **상호 의존하는 정도**를 의미한다.

종류에 따라 결합도가 약한 것부터 강한 것까지 나열하면 다음과 같다.

**자료 결합도 - 스탬프 결합도 - 제어 결합도 - 외부 결합도 - 공통 결합도 - 내용 결합도**

- 자료 결합도(Data Coupling): 모듈 간의 인터페이스가 자료 요소로만 구성됨. 매개 변수와 반환값으로 통신함
- 스탬프(검인) 결합도(Stamp Coupling): 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달됨
- 제어 결합도(Control Coupling): 제어 신호를 이용하여 통신하거나 제어 요소(Function Code, Switch, Tag, Flag)를 전달함
- 외부 결합도(External Coupling): 어떤 모듈에서 선언한 데이터(변수)를 다른 모듈에서 참조함
- 공통(공유) 결합도(Common Coupling): 두 모듈이 동일한 전역 데이터에 접근함
- 내용 결합도(Content Coupling): 한 모듈이 다른 모듈의 내용(기능이나 자료)을 참조하거나 수정함

### 응집도(Cohesion)

정보 은닉 개념을 확장한 것으로, 모듈 내부 요소들이 서로 관련되어 있는 정도를 의미한다.

종류에 따라 응집도가 약한 것부터 강한 것까지 나열하면 다음과 같다.

**우연적 응집도 - 논리적 응집도 - 시간적 응집도 - 절차적 응집도 - 교환적 응집도 - 순차적 응집도 - 기능적 응집도**

- 우연적 응집도(Coincidental Cohesion): 구성 요소들이 서로 관련 없음
- 논리적 응집도(Logical Cohesion): 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들을 모음
- 시간적 응집도(Temporal Cohesion): 특정 시간에 처리되는 기능을 모음
- 절차적 응집도(Procedural Cohesion): 구성 요소들이 그 기능을 순차적으로 수행함
- 교환(통신)적 응집도(Communication Cohesion): 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들을 모음
- 순차적 응집도(Sequential Cohesion): 한 구성 요소에서 나온 출력 데이터를 다음 구성 요소의 입력 데이터로 사용함
- 기능적 응집도(Functional Cohesion): 모든 구성 요소들이 단일 문제와 연관되어 있음

### 팬인(Fan-In)/팬아웃(Fan-Out)

- **팬인**: 어떤 모듈을 제어하는 모듈의 수 (화살표를 받음)
- **팬아웃**: 어떤 모듈에 의해 제어되는 모듈의 수 (화살표가 나감)
- 팬인이 높으면 재사용성이 좋다. 그러나 단일 장애점(SPOF; Single Point Of Failure)이 발생할 수 있으므로 중점적인 관리가 필요하다.
- 팬아웃이 높다면 단순화할 수 있는지 확인해야 한다.
- 시스템 복잡도를 낮추려면 **팬인은 높게, 팬아웃은 낮게** 설계해야 한다.

> [!NOTE]
>
> ##### N-S 차트
>
> 논리의 기술에 중점을 둔 도형을 이용한 표현 방법이다. 박스 다이어그램, Chapin Chart라고도 부른다.
>
> - GOTO나 화살표를 사용하지 않는다.
> - 읽기는 쉽지만 작성하기 어렵다.
> - 임의로 제어를 전이하는 것이 불가능하다.
> - 총체적인 구조 표현과 인터페이스를 나타내기 어렵다.
> - 단일 입구와 단일 출구로 표현한다.

## 21섹션: 공통 모듈
