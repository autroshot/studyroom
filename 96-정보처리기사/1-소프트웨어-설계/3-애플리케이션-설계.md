# 3장: 애플리케이션 설계

## 16섹션: 소프트웨어 아키텍처

### 소프트웨어 아키텍처의 설계

**소프트웨어 아키텍처**는 소프트웨어의 기본 구조이자, 구성 요소들 간의 관계를 표현하는 시스템의 구조이다.

설계는 다음과 같이 구분할 수 있다.

|           | 상위 설계                | 하위 설계                     |
| --------- | ------------------------ | ----------------------------- |
| 별칭      | 아키텍처 설계, 예비 설계 | 모듈 설계, 상세 설계          |
| 설계 대상 | 시스템의 전체적인 구조   | 시스템의 내부 구조 및 행위    |
| 세부 목록 | 구조, DB, 인터페이스     | 컴포넌트, 자료 구조, 알고리즘 |

아키텍처 설계의 기본 원리는 다음과 같다.

- **모듈화(Modularity)**
- **추상화(Abstraction)**
  - 과정 추상화
  - 데이터 추상화
  - 제어 추상화
- **단계적 분해(Stepwise Refinement)**: 하향식 설계 전략
- **정보 은닉(Information Hiding)**

### 소프트웨어 아키텍처의 품질 속성

- 시스템 측면: 성능, 보안, 가용성, 사용성, 변경 용이성 등
- 비즈니스 측면: 시장 적시성, 비용과 혜택, 예상 시스템 수명 등
- 아키텍처 측면: 개념적 무결성, 정확성, 완결성, 구축 가능성

### 소프트웨어 아키텍처의 설계 과정

**설계 목표 설정 → 시스템 타입 결정 → 아키텍처 패턴 적용 → 서브시스템 구체화 → 검토**

> [!NOTE]
>
> ##### 시스템 타입
>
> - 대화형 시스템: 대부분의 웹 애플리케이션
> - 이벤트 중심 시스템: 전화, 비상벨 등의 내장 소프트웨어
> - 변환형 시스템: 컴파일러, 네트워크 프로토콜
> - 객체 영속형 시스템: 서버 관리 소프트웨어
>
> ##### 협약(Contract)에 의한 설계
>
> 컴포넌트에 대한 정확한 인터페이스를 명시한다. 명세에 포함될 조건은 다음과 같다.
>
> - 선행 조건(Precondition)
> - 결과 조건(Postcondition)
> - 불변 조건(Invariant): 항상 만족되어야 하는 조건

## 17섹션: 아키텍처 패턴

### 아키텍처 패턴(Patterns)의 개요

아키텍처를 설계할 때 참조할 수 있는 **전형적인 해결 방식**이다. 아키텍처 스타일 또는 표준 아키텍처라고도 한다.

### 레이어 패턴(Layers pattern)

- 시스템을 **계층(Layer)으로 구분**하여 구성하는 고전적인 방법 중 하나다.
- 하위 계층은 상위 계층에 대한 서비스 제공자가 되고, 상위 계층은 하위 계층의 클라이언트가 된다.
- 예) OSI 참조 모델

### 클라이언트-서버 패턴(Client-Server Pattern)

- **하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트**로 구성된다.

### 파이프-필터 패턴(Pipe-Filter Pattern)

- 데이터 스트림 절차의 각 단계를 **필터(Filter)** 컴포넌트로 캡슐화하여 **파이프(Pipe)**를 통해 데이터를 전송하는 패턴이다.
- 예) UNIX의 쉘(Shell)

### 모델-뷰-컨트롤러 패턴(Model-View-Controller Pattern)

- 모델: 서브시스템의 핵심 기능과 데이터를 **보관**
- 뷰: 사용자에게 정보를 **표시**
- 컨트롤러: 사용자로부터 **변경** 요청을 받아 모델에게 명령을 보냄

### 기타 패턴

- 마스터-슬레이브 패턴(Master-Slave Pattern): 예) 장애 허용 시스템, 병렬 컴퓨팅 시스템
- 브로커 패턴: 예) 분산 환경 시스템
- 피어-투-피어 패턴: 멀티스레딩 방식
- 이벤트-버스 패턴
- 블랙보드 패턴: 예) 음성 인식, 차량 식별, 신호 해석
- 인터프리터 패턴

## 18섹션: 객체지향(Object-Oriented)

### 객체지향의 개요

개체(Entity)를 하나의 객체(Object)로 만들어, **객체들을 조립**해서 소프트웨어를 만드는 기법이다.

재사용 및 확장이 어렵다는 기존 구조적 기법의 문제점을 해결한다.

### 객체(Object)

**데이터**(속성, 상태, 변수, 자료 구조)와 **데이터를 처리하는 함수**(메소드, 서비스, 동작, 연산)를 묶어 놓은 하나의 소프트웨어 모듈이다.

- **메시지(Message)**: 객체에게 어떤 행위를 하도록 지시하는 명령이다.

### 클래스(Class)

공통된 속성과 연산을 갖는 **객체의 집합**으로, 객체의 일반적인 타입을 의미한다.

- **인스턴스(Instance)**: 클래스에 속한 각각의 객체
- 슈퍼 클래스/서브 클래스

### 캡슐화(Encapsulation)

**데이터와 함수를 하나로 묶는 것**을 의미한다.

### 상속(Inheritance)

상위 클래스의 모든 속성과 연산을 하위 클래스가 **물려받는** 것이다.

- **다중 상속(Multiple Inheritance)**: 하나의 클래스가 두 개 이상의 상위 클래스로부터 상속받는 것

### 다형성(Polymorphism)

하나의 메시지에 대해 여러 가지 형태의 응답이 있다는 것을 의미한다.

**오버로딩**과 **오버라이딩**이 대표적인 예이다.

### 연관성(Relationship)

둘 이상의 객체들이 상호 참조하는 관계를 말한다.

- 연관화
- 분류화
- 집단화(Aggregation): 관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것
- 일반화
- 특수화/상세화

## 섹션19: 객체지향 분석 및 설계

### 객체지향 분석의 개념

객체지향 분석(OOA; Object Oriented Analysis)은 요구사항과 관련된 모든 클래스(객체)와 그들 간의 관계 등을 정의하여 모델링하는 작업이다.

### 객체지향 분석의 방법론

- **럼바우(Rumbaugh) 방법**: **가장 일반적인 방법**으로 객체 모델링 기법(OMT; Object-Modeling Technique)이라고도 한다. 분석 활동은 **객체 모델 → 동적 모델 → 기능 모델** 순으로 이루어진다.
  - **객체 모델링(Object Modeling)**: 객체 다이어그램을 이용
  - **동적 모델링(Dynamic Modeling)**: 상태 다이어그램(상태도)을 이용
  - **기능 모델링(Functional Modeling)**: 자료 흐름도(DFD)를 이용
- 부치(Booch) 방법: 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 분석 방법
- Jacobson 방법: 사용 사례(Use Case)를 사용하는 분석 방법
- **Coad와 Yourdon 방법**: **E-R 다이어그램**을 사용
- Wirfs-Brock 방법: 분석과 설계 간에 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 기법

### 객체지향 설계 원칙

앞 글자를 따 **SOLID 원칙**이라고도 부른다.

- **단일 책임 원칙(SRP; Single Responsibility Principle)**: 객체는 단 하나의 책임만 가져야 한다.
- **개방-폐쇄 원칙(OCP; Open-Closed Principle)**: 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다.
- **리스코프 치환 원칙(LSP; Liskov Substitution Principle)**: 자식 클래스는 최소한 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.
- **인터페이스 분리 원칙(ISP; Interface Segregation Principle)**: 자신이 사용하지 않는 인터페이스 또는 메소드와 의존 관계를 맺거나 영향을 받지 않아야 한다.
- **의존 역전 원칙(DIP; Dependency Inversion Principle)**: 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다.

## 섹션20: 모듈
