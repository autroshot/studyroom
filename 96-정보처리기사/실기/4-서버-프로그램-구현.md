# 4장: 서버 프로그램 구현

## 63섹션: 소프트웨어 아키텍처

**소프트웨어 아키텍처**는 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조이다.

아키텍처 설계의 기본 원리는 다음과 같다.

- **모듈화(Modularity)**
- **추상화(Abstraction)**
  - 과정 추상화
  - 데이터 추상화
  - 제어 추상화
- **단계적 분해(Stepwise Refinement)**: 하향식 설계 전략
- **정보 은닉(Information Hiding)**

설계는 다음과 같이 구분할 수 있다.

|           | 상위 설계                | 하위 설계                     |
| --------- | ------------------------ | ----------------------------- |
| 별칭      | 아키텍처 설계, 예비 설계 | 모듈 설계, 상세 설계          |
| 설계 대상 | 시스템의 전체적인 구조   | 시스템의 내부 구조 및 행위    |
| 세부 목록 | 구조, DB, 인터페이스     | 컴포넌트, 자료 구조, 알고리즘 |

**협약(Contract)에 의한 설계**는 컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것이다.

## 64섹션: 아키텍처 패턴

**아키텍처 패턴**은 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식이다.

- **레이어 패턴**: 시스템을 계층(Layer)으로 구분하여 구성하는 고전적인 방법 중 하나다.
- **클라이언트-서버 패턴**: 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성된다.
- **파이프-필터 패턴**: 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴이다.
- **모델-뷰-컨트롤러 패턴**
- **마스터-슬레이브 패턴**: 예) 장애 허용 시스템, 병렬 컴퓨팅 시스템

## 65섹션: 객체지향

**객체지향**은 소프트웨어의 각 요소들을 객체로 만든 후, 객체들을 조립해서 소프트웨어를 만드는 기법이다.

객체지향의 구성 요소는 다음과 같다.

- **객체**
  - 데이터
  - 함수
- **클래스**: 공통된 속성과 연산을 갖는 객체의 집합
  - 인스턴스: 클래스에 속한 각각의 객체
- **메시지**: 객체들 간의 상호작용 수단

객체지향의 특징은 다음과 같다.

- **캡슐화**: 정보 은닉
- **상속**: 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것이다.
- **다형성**: 하나의 메시지에 대해 각각의 객체가 다양한 형태로 응답할 수 있다는 것을 의미한다.
- **연관성**: 둘 이상의 객체들이 상호 참조하는 관계를 말한다.

## 66섹션: 객체지향 분석 및 설계

객체지향 분석(OOA; Object Oriented Analysis)은 요구사항과 관련된 객체, 속성, 연산, 관계 등을 정의하여 모델링하는 작업이다.

객체지향 분석의 방법론은 다음과 같다.

- **Coad와 Yourdon 방법**: **E-R 다이어그램**을 사용
- **럼바우(Rumbaugh) 방법**: 그래픽 표기법을 이용하여 모델링한다. 객체 모델링 기법(OMT; Object-Modeling Technique)이라고도 한다. 분석 활동의 순서는 다음과 같다.
  1. **객체 모델링(Object Modeling)**: 정보 모델링이라고도 한다. 객체 다이어그램
  2. **동적 모델링(Dynamic Modeling)**: 상태 다이어그램(상태도)
  3. **기능 모델링(Functional Modeling)**: 자료 흐름도(DFD)

객체지향 설계 원칙은 다음과 같다. 앞 글자를 따 **SOLID 원칙**이라고도 부른다.

- **단일 책임 원칙(SRP; Single Responsibility Principle)**: 객체는 단 하나의 책임만 가져야 한다.
- **개방-폐쇄 원칙(OCP; Open-Closed Principle)**: 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다.
- **리스코프 치환 원칙(LSP; Liskov Substitution Principle)**: 자식 클래스는 최소한 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.
- **인터페이스 분리 원칙(ISP; Interface Segregation Principle)**: 자신이 사용하지 않는 인터페이스 또는 메소드와 의존 관계를 맺거나 영향을 받지 않아야 한다.
- **의존 역전 원칙(DIP; Dependency Inversion Principle)**: 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다.

## 67섹션: 모듈

**모듈**은 모듈화를 통해 분리된 시스템의 각 기능들이다. 서브루틴, 서브시스템, 프로그램, 작업 단위로도 부른다.

모듈의 독립성을 높이려면 **모듈의 결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게** 만들어야 한다.

**결합도(Coupling)**는 모듈 간에 상호 의존하는 정도를 의미한다. 종류에 따라 결합도가 약한 것부터 강한 것까지 나열하면 다음과 같다.

**자료 결합도 - 스탬프 결합도 - 제어 결합도 - 외부 결합도 - 공통 결합도 - 내용 결합도**

- 자료 결합도(Data Coupling): 모듈 간의 인터페이스가 자료 요소로만 구성됨. 매개 변수와 반환값으로 통신함
- 스탬프(검인) 결합도(Stamp Coupling): 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달됨
- 제어 결합도(Control Coupling): 제어 신호를 이용하여 통신하거나 제어 요소(Function Code, Switch, Tag, Flag)를 전달함
- 외부 결합도(External Coupling): 어떤 모듈에서 선언한 데이터(변수)를 다른 모듈에서 참조함
- 공통(공유) 결합도(Common Coupling): 두 모듈이 동일한 전역 데이터에 접근함
- 내용 결합도(Content Coupling): 한 모듈이 다른 모듈의 내용(기능이나 자료)을 참조하거나 수정함

**응집도(Cohesion)**는 모듈의 내부 요소들이 서로 관련되어 있는 정도를 의미한다. 종류에 따라 응집도가 약한 것부터 강한 것까지 나열하면 다음과 같다.

**우연적 응집도 - 논리적 응집도 - 시간적 응집도 - 절차적 응집도 - 교환적 응집도 - 순차적 응집도 - 기능적 응집도**

- 우연적 응집도(Coincidental Cohesion): 구성 요소들이 서로 관련 없음
- 논리적 응집도(Logical Cohesion): 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들을 모음
- 시간적 응집도(Temporal Cohesion): 특정 시간에 처리되는 기능을 모음
- 절차적 응집도(Procedural Cohesion): 구성 요소들이 그 기능을 순차적으로 수행함
- 교환(통신)적 응집도(Communication Cohesion): 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들을 모음
- 순차적 응집도(Sequential Cohesion): 한 구성 요소에서 나온 출력 데이터를 다음 구성 요소의 입력 데이터로 사용함
- 기능적 응집도(Functional Cohesion): 모든 구성 요소들이 단일 문제와 연관되어 있음

팬인과 팬아웃은 다음과 같다.

- **팬인**: 어떤 모듈을 제어하는 모듈의 수 (화살표를 받음)
- **팬아웃**: 어떤 모듈에 의해 제어되는 모듈의 수 (화살표가 나감)
- 시스템 복잡도를 낮추려면 **팬인은 높게, 팬아웃은 낮게** 설계해야 한다.

**N-S 차트**는 논리의 기술에 중점을 둔 도형을 이용한 표현 방법이다. 박스 다이어그램, Chapin Chart라고도 부른다.

## 68섹션: 단위 모듈

**단위 모듈**은 한 동작을 수행하는 기능을 모듈로 구현한 것이다.

**IPC**(Inter-Process Communication)는 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합이다.

**테스트 케이스**는 소프트웨어가 요구사항을 준수했는지를 확인하기 위한 테스트 항목에 대한 명세서이다.

## 69섹션: 공통 모듈
