# 4장: 서버 프로그램 구현

## 63섹션: 소프트웨어 아키텍처

**소프트웨어 아키텍처**는 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조이다.

아키텍처 설계의 기본 원리는 다음과 같다.

- **모듈화(Modularity)**
- **추상화(Abstraction)**
  - 과정 추상화
  - 데이터 추상화
  - 제어 추상화
- **단계적 분해(Stepwise Refinement)**: 하향식 설계 전략
- **정보 은닉(Information Hiding)**

설계는 다음과 같이 구분할 수 있다.

|           | 상위 설계                | 하위 설계                     |
| --------- | ------------------------ | ----------------------------- |
| 별칭      | 아키텍처 설계, 예비 설계 | 모듈 설계, 상세 설계          |
| 설계 대상 | 시스템의 전체적인 구조   | 시스템의 내부 구조 및 행위    |
| 세부 목록 | 구조, DB, 인터페이스     | 컴포넌트, 자료 구조, 알고리즘 |

**협약(Contract)에 의한 설계**는 컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것이다.

## 64섹션: 아키텍처 패턴

**아키텍처 패턴**은 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식이다.

- **레이어 패턴**: 시스템을 계층(Layer)으로 구분하여 구성하는 고전적인 방법 중 하나다.
- **클라이언트-서버 패턴**: 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성된다.
- **파이프-필터 패턴**: 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴이다.
- **모델-뷰-컨트롤러 패턴**
- **마스터-슬레이브 패턴**: 예) 장애 허용 시스템, 병렬 컴퓨팅 시스템

## 65섹션: 객체지향

**객체지향**은 소프트웨어의 각 요소들을 객체로 만든 후, 객체들을 조립해서 소프트웨어를 만드는 기법이다.

객체지향의 구성 요소는 다음과 같다.

- **객체**
  - 데이터
  - 함수
- **클래스**: 공통된 속성과 연산을 갖는 객체의 집합
  - 인스턴스: 클래스에 속한 각각의 객체
- **메시지**: 객체들 간의 상호작용 수단

객체지향의 특징은 다음과 같다.

- **캡슐화**: 정보 은닉
- **상속**: 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것이다.
- **다형성**: 하나의 메시지에 대해 각각의 객체가 다양한 형태로 응답할 수 있다는 것을 의미한다.
- **연관성**: 둘 이상의 객체들이 상호 참조하는 관계를 말한다.

## 66섹션: 객체지향 분석 및 설계

객체지향 분석(OOA; Object Oriented Analysis)은 요구사항과 관련된 객체, 속성, 연산, 관계 등을 정의하여 모델링하는 작업이다.

객체지향 분석의 방법론은 다음과 같다.

- **Coad와 Yourdon 방법**: **E-R 다이어그램**을 사용
- **럼바우(Rumbaugh) 방법**: 그래픽 표기법을 이용하여 모델링한다. 객체 모델링 기법(OMT; Object-Modeling Technique)이라고도 한다. 분석 활동의 순서는 다음과 같다.
  1. **객체 모델링(Object Modeling)**: 정보 모델링이라고도 한다. 객체 다이어그램
  2. **동적 모델링(Dynamic Modeling)**: 상태 다이어그램(상태도)
  3. **기능 모델링(Functional Modeling)**: 자료 흐름도(DFD)

객체지향 설계 원칙은 다음과 같다. 앞 글자를 따 **SOLID 원칙**이라고도 부른다.

- **단일 책임 원칙(SRP; Single Responsibility Principle)**: 객체는 단 하나의 책임만 가져야 한다.
- **개방-폐쇄 원칙(OCP; Open-Closed Principle)**: 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다.
- **리스코프 치환 원칙(LSP; Liskov Substitution Principle)**: 자식 클래스는 최소한 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.
- **인터페이스 분리 원칙(ISP; Interface Segregation Principle)**: 자신이 사용하지 않는 인터페이스 또는 메소드와 의존 관계를 맺거나 영향을 받지 않아야 한다.
- **의존 역전 원칙(DIP; Dependency Inversion Principle)**: 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다.

## 67섹션: 모듈

**모듈**은 모듈화를 통해 분리된 시스템의 각 기능들이다. 서브루틴, 서브시스템, 프로그램, 작업 단위로도 부른다.

모듈의 독립성을 높이려면 **모듈의 결합도는 약하게, 응집도는 강하게, 모듈의 크기는 작게** 만들어야 한다.

**결합도(Coupling)**는 모듈 간에 상호 의존하는 정도를 의미한다. 종류에 따라 결합도가 약한 것부터 강한 것까지 나열하면 다음과 같다.

**자료 결합도 - 스탬프 결합도 - 제어 결합도 - 외부 결합도 - 공통 결합도 - 내용 결합도**

- 자료 결합도(Data Coupling): 모듈 간의 인터페이스가 자료 요소로만 구성됨. 매개 변수와 반환값으로 통신함
- 스탬프(검인) 결합도(Stamp Coupling): 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달됨
- 제어 결합도(Control Coupling): 제어 신호를 이용하여 통신하거나 제어 요소(Function Code, Switch, Tag, Flag)를 전달함
- 외부 결합도(External Coupling): 어떤 모듈에서 선언한 데이터(변수)를 다른 모듈에서 참조함
- 공통(공유) 결합도(Common Coupling): 두 모듈이 동일한 전역 데이터에 접근함
- 내용 결합도(Content Coupling): 한 모듈이 다른 모듈의 내용(기능이나 자료)을 참조하거나 수정함

**응집도(Cohesion)**는 모듈의 내부 요소들이 서로 관련되어 있는 정도를 의미한다. 종류에 따라 응집도가 약한 것부터 강한 것까지 나열하면 다음과 같다.

**우연적 응집도 - 논리적 응집도 - 시간적 응집도 - 절차적 응집도 - 교환적 응집도 - 순차적 응집도 - 기능적 응집도**

- 우연적 응집도(Coincidental Cohesion): 구성 요소들이 서로 관련 없음
- 논리적 응집도(Logical Cohesion): 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들을 모음
- 시간적 응집도(Temporal Cohesion): 특정 시간에 처리되는 기능을 모음
- 절차적 응집도(Procedural Cohesion): 구성 요소들이 그 기능을 순차적으로 수행함
- 교환(통신)적 응집도(Communication Cohesion): 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들을 모음
- 순차적 응집도(Sequential Cohesion): 한 구성 요소에서 나온 출력 데이터를 다음 구성 요소의 입력 데이터로 사용함
- 기능적 응집도(Functional Cohesion): 모든 구성 요소들이 단일 문제와 연관되어 있음

팬인과 팬아웃은 다음과 같다.

- **팬인**: 어떤 모듈을 제어하는 모듈의 수 (화살표를 받음)
- **팬아웃**: 어떤 모듈에 의해 제어되는 모듈의 수 (화살표가 나감)
- 시스템 복잡도를 낮추려면 **팬인은 높게, 팬아웃은 낮게** 설계해야 한다.

**N-S 차트**는 논리의 기술에 중점을 둔 도형을 이용한 표현 방법이다. 박스 다이어그램, Chapin Chart라고도 부른다.

## 68섹션: 단위 모듈

**단위 모듈**은 한 동작을 수행하는 기능을 모듈로 구현한 것이다.

**IPC**(Inter-Process Communication)는 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합이다.

**테스트 케이스**는 소프트웨어가 요구사항을 준수했는지를 확인하기 위한 테스트 항목에 대한 명세서이다.

## 69섹션: 공통 모듈

**공통 모듈**은 여러 프로그램에서 공통으로 사용할 수 있는 모듈이다.

**재사용(Reuse)**은 이미 개발된 기능들을 새로운 시스템에 사용하기 적합하도록 최적화하는 작업이다. 재사용 규모에 따른 분류는 다음과 같다.

- 함수와 객체
- 컴포넌트
- 애플리케이션

## 71섹션: 디자인 패턴

**디자인 패턴**은 모듈 간의 관계 및 인터페이스를 설계할 때 참고할 수 있는 전형적인 해결 방식이다.

**GoF(Gang of Four)의 디자인 패턴**은 소프트웨어 공학이나 현업에서 가장 많이 사용되는 디자인 패턴으로 다음과 같이 구분된다.

- **생성 패턴**(Creational Pattern): 객체의 생성과 참조 과정을 정의한다.
- **구조 패턴**(Structural Pattern): 클래스나 객체들을 조합하여 더 큰 구조로 만든다.
- **행위 패턴**(Behavioral Pattern): 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의한다.

생성 패턴의 종류는 다음과 같다.

- **추상 팩토리**: 구체적인 클래스 대신 인터페이스를 통해 서로 연관된 객체들의 그룹으로 생성한다.
- 빌더: 작게 분리된 인스턴스를 조합하여 객체를 생성한다.
- **팩토리 메소드**: 객체 생성을 서브 클래스에서 처리한다.
- **프로토타입**: 원본 객체를 복제하여 객체를 생성한다.
- **싱글톤(Singleton)**: 인스턴스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화한다.

구조 패턴의 종류는 다음과 같다.

- **어댑터**
- **브리지**: 구현부에서 추상층을 분리한다.
- **컴포지트**: 복합 객체와 단일 객체를 구분 없이 다룬다.
- 데코레이터: 어떤 객체에 다른 객체들을 덧붙여서 부가적인 기능을 추가한다.
- 퍼싸드(Facade): 복잡한 서브 클래스 대신 상위에 인터페이스를 구성하여 서브 클래스의 기능을 간편하게 사용할 수 있다. Wrapper 객체가 필요하다.
- 플라이웨이트(Flyweight): 인스턴스를 매번 생성하는 대신 가능한 한 공유해서 사용한다.
- **프록시(Proxy)**

행위 패턴의 종류는 다음과 같다.

- 책임 연쇄
- **커맨드**: 요청을 객체의 형태로 캡슐화하여 재이용할 수 있도록 요청에 필요한 정보를 저장한다. 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화한다.
- 인터프리터
- **반복자(Iterator)**: 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하는 패턴이다.
- **중재자(Mediator)**: 수많은 객체들 간의 복잡한 상호작용(인터페이스)을 캡슐화하여 객체로 정의한다.
- 메멘토(Memento): 특정 시점에서의 객체 상태를 객체화함으로써 필요에 따라 해당 시점의 상태로 되돌릴 수 있다.
- **옵서버(Observer)**: 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달한다.
- **상태**: 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용한다.
- **전략(Strategy)**: 동일한 계열의 알고리즘들을 캡슐화하여 상호 교환할 수 있게 정의한다.
- **템플릿 메소드**: 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화한다.
- **방문자**: 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성한다. 분리된 처리 기능을 각 클래스를 방문(Visit)하여 수행한다.

