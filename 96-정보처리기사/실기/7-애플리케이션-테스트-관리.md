# 7장: 애플리케이션 테스트 관리

## 91섹션: 애플리케이션 테스트

**애플리케이션 테스트**는 애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차이다.

- **파레토 법칙(Pareto Principle)**: 애플리케이션의 20%의 코드에서 80%의 결함이 발견된다.
- **살충제 패러독스(Pesticide Paradox)**: 살충제를 지속적으로 뿌리면 벌레가 내성이 생기는 현상이다. 동일한 테스트 케이스로 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는다.
- 오류-부재의 궤변(Absence of Errors Fallacy): 결함을 모두 제거해도 사용자의 요구사항을 만족시키지 못하면 해당 소프트웨어는 품질이 높다고 말할 수 없다.

## 92섹션: 애플리케이션 테스트의 분류

- 프로그램 실행 여부에 따른 테스트
  - **정적 테스트**: 프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석
  - 동적 테스트
- 시각에 따른 테스트
  - **검증(Verification) 테스트**: 개발자의 시각
  - **확인(Validation) 테스트**: 사용자의 시각
- 목적에 따른 테스트
  - **강도(Stress) 테스트**

## 93섹션: 테스트 기법에 따른 애플리케이션 테스트

**화이트박스 테스트**는 모듈의 원시 코드를 오픈시킨 상태에서 코드의 논리적인 모든 경로를 테스트하는 방법이다.

화이트박스 테스트의 종류는 다음과 같다.

- **기초 경로 검사**(Base Path Testing): 대표적인 화이트박스 테스트 기법. 기초 경로는 수행 가능한 모든 경로를 의미한다.
- 제어 구조 검사(Control Structure Testing)
  - 조건 검사(Condition Testing)
  - 루프 검사(Loop Testing)
  - 데이터 흐름 검사(Data Flow Testing): 변수의 정의와 사용 위치에 초점을 맞춤

화이트 테스트의 **검증 기준**(Test Coverage)의 종류는 다음과 같다.

- **문장 검증 기준**(Statement Coverage): 모든 구문을 수행
- **결정 검증 기준**(Decision Coverage): 분기 검증 기준이라고도 함. 모든 조건문에 대해 True와 False인 경우를 수행
- **조건 검증 기준**(Condition Coverage): 조건문에 포함된 개별 조건식의 결과가 True와 False인 경우를 수행
- **변경 조건/결정 검증 기준**(Modified Condition/Decision Coverage): 개별 조건식이 다른 개별 조건식의 영향을 받지 않게 설계

**블랙박스 테스트**(기능 테스트)는 각 기능이 완전히 작동되는 것을 입증하는 테스트이다.

블랙박스 테스트의 종류는 다음과 같다.

- **동치 분할 검사(Equivalence Partitioning Testing, 동치 클래스 분해)**: **입력 자료**에 초점을 맞춰 테스트 케이스(동치 클래스)를 만들어 검사하는 방법이다. 어떤 입력 조건에 대하여 타당한 값과 그렇지 못한 값을 설정하여 올바른 결과가 출력되는지 확인한다.
- **경계값 분석(Boundary Value Analysis)**: 동치 분할 검사를 보완한다. **입력 조건의 경계값**을 테스트 케이스로 선정한다.
- **원인-효과 그래프 검사(Cause-Effect Graphing Testing)**: **입력 데이터 간의 관계와 출력에 영향을 미치는 상황**을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정한다.
- **오류 예측 검사(Error Guessing)**: **과거의 경험이나 확인자의 감각**으로 테스트한다. 데이터 확인 검사라고도 한다.

## 94섹션: 개발 단계에 따른 애플리케이션 테스트

그림은 책을 참고한다.

테스트와 개발 단계를 연결하여 표현한 것을 V-모델이라 한다. 테스트는 개발 단계에 따라 다음과 같이 분류한다.

- **단위 테스트**: 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트한다.
- **통합 테스트**: 모듈이나 컴포넌트 간의 상호 작용 오류를 검사한다.
- 시스템 테스트
- 인수 테스트
  - **알파 테스트**: 사용자가 개발자 앞에서 행하는 테스트
  - **베타 테스트**: 선정된 최종 사용자가 여러 명의 사용자 앞에서 행하는 테스트

## 95섹션: 통합 테스트

**통합 테스트**는 모듈을 통합하는 과정에서 발생하는 오류를 찾는 테스트 기법이다.

다음과 같이 두 가지 방식이 있다.

- 비점진적 통합 방식: 규모가 작은 소프트웨어에 유리하며 단시간 내에 테스트가 가능하다.
  - 빅뱅 통합 테스트
- 점진적 통합 방식
  - **하향식 통합 테스트**: **스텁(Stub)**
  - **상향식 통합 테스트**: **클러스터(Cluster), 드라이버(Driver)**
  - 혼합식 통합 테스트

**회귀 테스트(Regression Testing)**는 이미 테스트된 프로그램의 테스팅을 반복하는 것으로, 통합 테스트로 인해 변경된 모듈에 새로운 오류가 있는지 확인한다.

## 96섹션: 테스트 케이스/테스트 시나리오/테스트 오라클

**테스트 오라클**은 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값을 대입하여 비교하는 기법이다.

- 참(True) 오라클: 모든 입력 값에 대해 기대하는 결과를 제공한다.
- **샘플링 오라클**
- **추정(Heuristic) 오라클**: 샘플링 오라클을 개선한 오라클로, 특정 입력 값에 대해 기대하는 결과를 제공하고, 나머지 입력 값들에 대해서는 추정으로 처리한다.
- **일관성(Consistent) 검사 오라클**: 애플리케이션에 변경이 있을 때, 테스트 케이스의 수행 전과 후의 결과 값이 동일한지를 확인한다.

## 99섹션: 애플리케이션 성능 분석

애플리케이션 성능 측정 지표는 다음과 같다.

- **처리량**
- **응답 시간**: 요청 전달에서 응답까지 걸린 시간
- **경과 시간**: 작업 의뢰에서 완료까지 걸린 시간
- **자원 사용률**

## 100섹션: 복잡도

일반적인 알고리즘에 대해 빅오 표기법으로 시간 복잡도를 표현하면 다음과 같다.

- **O(1)**: 스탭의 삽입(Push), 삭제(Pop)
- O($\log_2n$): 이진 트리, 이진 검색
- O(n): for문
- **O($n\log_2n$)**: 힙 정렬, 2-Way 합병 정렬
- O($\boldsymbol{n^2}$): 삽입 정렬, 쉘 정렬, 선택 정렬, 버블 정렬, 퀵 정렬
- O($2^n$): 피보나치 수열

**순환 복잡도**는 맥케이브 순환도 또는 맥케이브 복잡도 메트릭이라고도 하며 제어 흐름도 이론에 기반한다. 순환 복잡도를 계산하는 식은 다음과 같다. E는 화살표 수, N은 노드의 수이다.
$$
V(G)=E-N+2
$$

또는 제어 흐름도에서 화살표로 구분되는 영역의 개수를 구하면 된다. 이 방법이 더 편하다.

## 101섹션: 애플리케이션 성능 개선

**소스 코드 최적화**는 나쁜 코드를 배제하고 클린 코드로 작성하는 것이다.

- 클린 코드(Clean Code)
- 나쁜 코드(Bad Code)
  - 스파게티 코드(Spaghetti Code): 코드의 로직 서로 복잡하게 얽혀 있는 코드
  - **외계인 코드(Alien Code)**: 아주 오래되어 유지보수가 어려운 코드

클린 코드 작성 원칙은 다음과 같다.

- **가독성**
- **단순성**
- **의존성 배제**
- **중복성 최소화**
- **추상화**

소스 코드 품질 분석 도구는 다음과 같이 분류된다.

- **정적 분석 도구(Static Analysis)**: 소스 코드를 실행하지 않고 코딩 표준, 코딩 스타일, 결함 등을 확인한다.
  - 주로 개발 초기의 결함을 찾는데 사용한다.
  - 예: pmd, cppcheck, checkstyle, SonarQube 등
- **동적 분석 도구(Dynamic Analysis)**: 소스 코드를 실행하여 코드에 존재하는 메모리 누수, 스레드 결함 등을 찾는다.
  - 예: Avalanche, Valgrind 등
