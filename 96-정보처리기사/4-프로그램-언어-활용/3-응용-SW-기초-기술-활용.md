# 3장: 응용 SW 기초 기술 활용

## 113섹션: UNIX/LINUX/MacOS

### UNIX의 개요 및 특징

- C언어로 작성되어 이식성이 높고 장치, 프로세스 간의 호환성이 좋다.
- 다중 사용자(Multi-User), 다중 작업(Multi-Tasking)을 지원한다.
- 트리 구조의 파일 시스템을 갖는다.

### UNIX 시스템의 구성

**하드웨어 → 커널 → 쉘 → 유틸리티 → 사용자**

- **커널(Kernel)**: UNIX의 가장 **핵심**적인 부분으로 프로세스, 기억장치, 파일 등 다양한 부분의 **관리**를 맡는다.
- **쉘(Shell)**: **명령어 해석기**. 시스템과 사용자 간의 **인터페이스**를 담당한다.

### LINUX의 개요 및 특징

- 소스 코드가 무료로 공개되어 있다.
- UNIX와 완벽하게 호환된다.
- 대부분의 특징이 UNIX와 동일하다.

### MacOS의 개요 및 특징

- 애플 사가 UNIX 기반으로 개발한 운영체제이다.
- 드라이버 설치 및 삭제 과정이 단순하다.

## 114섹션: 기억장치 관리의 개요

**레지스터 → 캐시 기억장치 → 주기억장치 → 보조기억장치**

**왼쪽으로 갈수록 접근 속도와 접근 시간이 빠르지만, 기억 용량이 적고 고가이다.**

- CPU는 보조기억장치에 있는 데이터에는 직접 접근할 수 없다.

### 기억장치의 관리 전략

보조기억장치의 프로그램이나 데이터를 주기억장치에 적재하는 시기, 위치 등을 지정하여 주기억장치의 공간을 효율적으로 사용하는 것을 의미한다.

- **반입(Fetch) 전략**: 언제
  - 요구 반입(Demand Fetch)
  - 예상 반입(Anticipatory Fetch)
- **배치(Placement) 전략**: 위치
  - **최초 적합(First Fit)**: 첫 번째 분할 영역
  - **최적 적합(Best Fit)**: 단편화를 가장 작게 남기는 분할 영역
  - **최악 적합(Worst Fit)**: 단편화를 가장 많이 남기는 분할 영역
- **교체(Replacement) 전략**: 이미 사용되고 있는 영역 중에서 어느 영역을 교체할 것인가

## 115섹션: 가상기억장치 구현 기법/페이지 교체 알고리즘

### 가상기억장치의 개요

용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법이다.

- **인위적 연속성(Artificial Contiguity)**: 가상주소를 실기억주소로 변환하는 주소 변환에서, 연속적인 가상주소가 연속적인 실기억주소로 변환되지 않아도 되는 것을 의미한다.
- 구현 방법은 다음과 같다. 블록의 종류에 따라 나뉜다. **페이지의 크기는 일정하지만, 세그먼트의 크기는 일정하지 않다.**
  - 페이징 기법
  - 세그먼테이션 기법

### 페이징(Paging) 기법

- **페이지(Page)**: 프로그램을 일정한 크기로 나눈 단위
- **페이지 프레임(Page Frame)**: 페이지 크기로 일정하게 나누어진 주기억장치의 단위
- 페이지 맵 테이블이 필요하다.
- 외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있다.

### 세그먼테이션(Segmentation) 기법

- **세그먼트(Segment)**: 프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위. 각 세그먼트는 고유한 이름과 크기를 갖는다.
- 세그먼트 맵 테이블이 필요하다.
- 내부 단편화는 발생하지 않으나 외부 단편화는 발생할 수 있다.
- **실기억주소 = 세그먼트 기준번지 + 변위값**

### 페이지 교체 알고리즘

**페이지 부재(Page Fault)**가 발생했을 때 어떤 페이지 프레임을 교체할 것인지를 결정하는 기법이다.

FIFO와 LRU의 페이지 부재 횟수를 구하는 방법을 알아야 한다.

#### OPT(OPTimal replacement, 최적 교체)

- 가장 오랫동안 사용하지 않을 페이지를 교체한다.
- 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘이다.

#### FIFO(First In First Out)

- 가장 오래 있었던 페이지를 교체한다.
- 이해하기 쉽고, 프로그래밍 및 설계가 간단하다.

#### LRU(Least Recently Used)

- 최근에 가장 오랫동안 사용하지 않은 페이지를 교체한다.
- 각 페이지마다 계수기(Counter)나 스택을 둔다.

#### LFU(Least Frequently Used)

- 가장 사용 빈도가 적은 페이지를 교체한다.

#### NUR(Not Used Recently)

- LRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지를 교체한다.
- LRU의 시간적인 오버헤드를 줄일 수 있다.
- 각 페이지마다 참조 비트(Reference Bit)와 변형 비트(Modified Bit, Dirty Bit)가 사용된다. 사용되었을 때 비트 값은 1이 된다.

#### SCR(Second Chance Replacement, 2차 기회 교체)

- 가장 오랫동안 있던 페이지 중 자주 사용되는 페이지의 교체를 방지한다.
- FIFO 기법의 단점을 보완한다.

## 116섹션: 가상기억장치 기타 관리 사항

### 페이지 크기

다음은 페이지 크기가 작을 경우의 특징이다.

- 장점
  - 페이지 단편화가 감소된다.
  - 한 개의 페이지를 주기억장치로 이동하는 시간이 줄어든다.
  - 효율적인 워킹 셋을 유지할 수 있다.
  - Locality가 높아서 기억장치 효율이 좋아진다.
- 단점
  - 페이지 맵 테이블의 크기가 커지고, 매핑 속도가 늦어진다.
  - 디스크 접근 횟수가 많아져서 전체적인 입·출력 시간은 늘어난다.

### Locality

Locality(국부성, 지역성)는 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론이다.

- 가상기억장치 관리와 캐시 메모리 시스템의 이론적 근거이다.

#### 시간 구역성(Temporal Locality)

- 한 번 참조한 페이지는 가까운 시간 내에 참조할 가능성이 높다.
- 예) Loop, 스택, 부 프로그램(서브 루틴), 카운팅, 집계(Totaling)

#### 공간 구역성(Spatial Locality)

- 어느 하나의 페이지를 참조하면 그 근처의 페이지를 계속 참조할 가능성이 높다.
- 예) 배열 순회, 순차적 코드의 실행, 근처에 선언된 변수들

### 위킹 셋(Working Set)

프로세스가 일정 시간 동안 **자주 참조하는 페이지들의 집합**이다.

### 페이지 부재 빈도 방식

**페이지 부재 빈도(PFF; Page Fault Frequency)**는 페이지 부재가 일어나는 횟수를 의미한다.

페이지 부재 빈도 방식은 페이지 부재율에 따라 주기억장치의 페이지 프레임의 수를 늘리거나 줄여 **페이지 부재율을 적정 수준으로 유지**하는 방식이다.

### 프리페이징(Prepaging)

처음의 과도한 페이지 부재를 방지하기 위해 필요할 것 같은 **모든 페이지를 한꺼번에 페이지 프레임에 적재**하는 기법이다.

### 스래싱(Thrashing)

프로세스의 처리 시간보다 **페이지 교체에 소요되는 시간이 더 많아지는 현상**이다.

- 페이지 부재가 자주 발생하면 스래싱이 자주 발생한다.
- 다중 프로그래밍의 정도가 높아지면 CPU의 이용률은 어느 정도까지 높아지지만, 어느 시점부터는 스래싱이 나타나고 CPU의 이용률은 급격히 감소한다(책의 그래프 참고).

## 117섹션: 프로세스의 개요

프로세스(Process)는 일반적으로 프로세서(CPU)에 의해 처리되는 **프로그램**을 의미한다. 작업(Job), 태스트(Task)라고도 한다.

### PCB(Process Control Block, 프로세스 제어 블록)

운영체제가 프로세스에 대한 중요한 정보를 저장해 놓은 곳이다.

- 프로세스가 생성될 때마다 고유한 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거된다.

### 프로세스 상태 전이

상태 전이도는 책을 참고한다.

- 제출(Submit)
- 접수(Hold)
- **준비(Ready)**
- **실행(Run)**
- **대기, 블록(Wait, Block)**: 프로세스에 입·출력 처리가 필요하면 처리가 완료될 때까지 대기한다.
- 종료(Terminated, Exit)

관련 용어는 다음과 같다.

- **Dispatch**: 준비 상태 → 실행 상태
- Wake up: 대기 상태 → 준비 상태
- Spooling: 입·출력할 데이터를 나중에 한꺼번에 입·출력하기 위해 디스크에 저장하는 과정
- 교통량 제어기(Traffic Controller): 프로세스의 상태에 대한 조사와 통보를 담당

### 스레드(Thread)

**프로세스 내의 작업 단위**로서, 실행하는 프로그램의 단위이다. 경량(Light Weight) 프로세스라고도 한다.

- 하나의 프로세스에 존재하는 스레드의 개수에 따라 단일 스레드, 다중 스레드로 나뉜다.

스레드의 분류는 다음과 같다.

- **사용자 수준의 스레드**: **사용자가 만든 라이브러리**를 사용하여 스레드를 운용한다.
  - 속도가 빠르지만 구현이 어렵다.
  - 커널 모드로의 전환이 없어 오버헤드가 줄어든다.
- **커널 수준의 스레드**: **운영체제의 커널**에 의해 스레드를 운용한다.
  - 구현이 쉽지만 속도가 느리다.
  - 독립적인 스케줄링이 가능하다.
  - 여러 스레드가 커널에 동시에 접근할 수 있다.
  - 한 프로세스가 운영체제를 호출할 때 전체 프로세스가 대기할 필요가 없다.

## 119섹션: 주요 스케줄링 알고리즘

다음 세 알고리즘은 모두 비선점 알고리즘에 속한다.

**평균 실행 시간, 평균 대기 시간, 평균 반환 시간**을 계산할 줄 알아야 한다.

반환 시간 = 대기 시간 + 실행 시간

### FCFS(First Come First Service, 선입 선출)

준비상태 큐에 도착한 순서에 따라 CPU를 할당한다.

- 가장 간단하다.
- 공평성은 유지되지만, 짧은 작업이 긴 작업을, 중요한 작업이 중요하지 않은 작업을 기다리게 된다.

### SJF(Shortest Job First, 단기 작업 우선)

실행 시간이 가장 짧은 프로세스에게 CPU를 먼저 할당한다.

- 가장 적은 평균 대기 시간을 제공한다.
- 실행 시간이 긴 프로세스는 연기 상태가 무한히 지속될 수 있다.

### HRN(Hightest Response-ratio Next)

SJF 기법을 보완한 것으로, 대기 시간과 실행 시간(서비스 시간)을 이용하는 기법이다.

다음 계산식에 따라 값이 큰 것부터 우선순위가 부여된다.
$$
우선순위 = \frac{대기시간+실행시간}{실행시간}
$$
실행 시간이 짧거나 대기 시간이 긴 프로세스에게 우선순위가 주어진다.

## 121섹션: 운영체제 기본 명령어

운영체제를 제어하는 방법은 크게 CLI와 GUI로 구분할 수 있다.

### Windows 기본 명령어

Windows의 CLI 명령은 모두 대문자이다.

### UNIX/LINUX 기본 명령어

- **fork**: 새로운 프로세스를 생성
- **uname**: 시스템 정보 출력
- cat
- chdir/cd
- chmod
- cp
- rm
- ls

## 122섹션: 인터넷

TCP/IP 프로토콜을 기반으로, 전 세계 컴퓨터와 네트워크들이 연결된 광범위한 컴퓨터 통신망이다.

### IP 주소(Internet Protocol Address)

인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소이다.

- 8비트*4부분=32비트
- A Class: 0~127로 시작
- B Class: 128~191로 시작
- **C Class: 192~223로 시작**
- D Class: 224~239로 시작. 멀티캐스트용

2^8인 256에서 시작해서 256/2, 256/2/2... 를 더하는 것으로 외우면 쉽다. C Class는 암기하자.

### 서브네팅(Subnetting)

할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용하는 것을 말한다.

**주어진 IP 주소를 서브네팅하는 문제를 푸는 방법을 책에서 참고한다.**

**CIDR(Classless Inter-Domain Routing, 클래스가 없는 도메인 간의 라우팅 기법) 사용 시 서브넷 마스크를 구하는 방법을 책에서 참고한다.**

### IPv6(Internet Protocol version 6)

- 16비트*8부분=128비트
- 각 부분을 16진수로 표현하고, `:`으로 구분한다.
- 다음 세 가지 주소 체계로 나누어진다.
  - 유니캐스트(1:1)
  - 멀티캐스트(1:n)
  - 애니캐스트(1:1, 단일 송신자와 가장 가까이 있는 단일 수신자의 통신)

### 도메인 네임(Domain Name)

IP 주소를 사람이 이해하기 쉬운 문자 형태로 표현한 것이다.

## 123섹션: OSI 참조 모델

OSI(Open System Interconnection) 참조 모델은 다른 시스템 간의 원활한 통신을 위해 ISO에서 제안한 통신 규약(Protocol)이다.

1. 물리 계층
2. 데이터 링크 계층
3. 네트워크 계층
4. 전송 계층
5. 세션 계층
6. 표현 계층
7. 응용 계층

1~3계층을 하위 계층, 4~7계층을 상위 계층이라고 한다.
