# 3장: 응용 SW 기초 기술 활용

## 113섹션: UNIX/LINUX/MacOS

### UNIX의 개요 및 특징

- C언어로 작성되어 이식성이 높고 장치, 프로세스 간의 호환성이 좋다.
- 다중 사용자(Multi-User), 다중 작업(Multi-Tasking)을 지원한다.
- 트리 구조의 파일 시스템을 갖는다.

### UNIX 시스템의 구성

**하드웨어 → 커널 → 쉘 → 유틸리티 → 사용자**

- **커널(Kernel)**: UNIX의 가장 **핵심**적인 부분으로 프로세스, 기억장치, 파일 등 다양한 부분의 **관리**를 맡는다.
- **쉘(Shell)**: **명령어 해석기**. 시스템과 사용자 간의 **인터페이스**를 담당한다.

### LINUX의 개요 및 특징

- 소스 코드가 무료로 공개되어 있다.
- UNIX와 완벽하게 호환된다.
- 대부분의 특징이 UNIX와 동일하다.

### MacOS의 개요 및 특징

- 애플 사가 UNIX 기반으로 개발한 운영체제이다.
- 드라이버 설치 및 삭제 과정이 단순하다.

## 114섹션: 기억장치 관리의 개요

**레지스터 → 캐시 기억장치 → 주기억장치 → 보조기억장치**

**왼쪽으로 갈수록 접근 속도와 접근 시간이 빠르지만, 기억 용량이 적고 고가이다.**

- CPU는 보조기억장치에 있는 데이터에는 직접 접근할 수 없다.

### 기억장치의 관리 전략

보조기억장치의 프로그램이나 데이터를 주기억장치에 적재하는 시기, 위치 등을 지정하여 주기억장치의 공간을 효율적으로 사용하는 것을 의미한다.

- **반입(Fetch) 전략**: 언제
  - 요구 반입(Demand Fetch)
  - 예상 반입(Anticipatory Fetch)
- **배치(Placement) 전략**: 위치
  - **최초 적합(First Fit)**: 첫 번째 분할 영역
  - **최적 적합(Best Fit)**: 단편화를 가장 작게 남기는 분할 영역
  - **최악 적합(Worst Fit)**: 단편화를 가장 많이 남기는 분할 영역
- **교체(Replacement) 전략**: 이미 사용되고 있는 영역 중에서 어느 영역을 교체할 것인가

## 115섹션: 가상기억장치 구현 기법/페이지 교체 알고리즘

### 가상기억장치의 개요

용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법이다.

- **인위적 연속성(Artificial Contiguity)**: 가상주소를 실기억주소로 변환하는 주소 변환에서, 연속적인 가상주소가 연속적인 실기억주소로 변환되지 않아도 되는 것을 의미한다.
- 구현 방법은 다음과 같다. 블록의 종류에 따라 나뉜다. **페이지의 크기는 일정하지만, 세그먼트의 크기는 일정하지 않다.**
  - 페이징 기법
  - 세그먼테이션 기법

### 페이징(Paging) 기법

- **페이지(Page)**: 프로그램을 일정한 크기로 나눈 단위
- **페이지 프레임(Page Frame)**: 페이지 크기로 일정하게 나누어진 주기억장치의 단위
- 페이지 맵 테이블이 필요하다.
- 외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있다.

### 세그먼테이션(Segmentation) 기법

- **세그먼트(Segment)**: 프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위. 각 세그먼트는 고유한 이름과 크기를 갖는다.
- 세그먼트 맵 테이블이 필요하다.
- 내부 단편화는 발생하지 않으나 외부 단편화는 발생할 수 있다.
- **실기억주소 = 세그먼트 기준번지 + 변위값**

### 페이지 교체 알고리즘

**페이지 부재(Page Fault)**가 발생했을 때 어떤 페이지 프레임을 교체할 것인지를 결정하는 기법이다.

FIFO와 LRU의 페이지 부재 횟수를 구하는 방법을 알아야 한다.

#### OPT(OPTimal replacement, 최적 교체)

- 가장 오랫동안 사용하지 않을 페이지를 교체한다.
- 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘이다.

#### FIFO(First In First Out)

- 가장 오래 있었던 페이지를 교체한다.
- 이해하기 쉽고, 프로그래밍 및 설계가 간단하다.

#### LRU(Least Recently Used)

- 최근에 가장 오랫동안 사용하지 않은 페이지를 교체한다.
- 각 페이지마다 계수기(Counter)나 스택을 둔다.

#### LFU(Least Frequently Used)

- 가장 사용 빈도가 적은 페이지를 교체한다.

#### NUR(Not Used Recently)

- LRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지를 교체한다.
- LRU의 시간적인 오버헤드를 줄일 수 있다.
- 각 페이지마다 참조 비트(Reference Bit)와 변형 비트(Modified Bit, Dirty Bit)가 사용된다. 사용되었을 때 비트 값은 1이 된다.

#### SCR(Second Chance Replacement, 2차 기회 교체)

- 가장 오랫동안 있던 페이지 중 자주 사용되는 페이지의 교체를 방지한다.
- FIFO 기법의 단점을 보완한다.

## 116섹션: 가상기억장치 기타 관리 사항

### 페이지 크기

다음은 페이지 크기가 작을 경우의 특징이다.

- 장점
  - 페이지 단편화가 감소된다.
  - 한 개의 페이지를 주기억장치로 이동하는 시간이 줄어든다.
  - 효율적인 워킹 셋을 유지할 수 있다.
  - Locality가 높아서 기억장치 효율이 좋아진다.
- 단점
  - 페이지 맵 테이블의 크기가 커지고, 매핑 속도가 늦어진다.
  - 디스크 접근 횟수가 많아져서 전체적인 입·출력 시간은 늘어난다.

### Locality

Locality(국부성, 지역성)는 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론이다.

- 가상기억장치 관리와 캐시 메모리 시스템의 이론적 근거이다.

#### 시간 구역성(Temporal Locality)

- 한 번 참조한 페이지는 가까운 시간 내에 참조할 가능성이 높다.
- 예) Loop, 스택, 부 프로그램(서브 루틴), 카운팅, 집계(Totaling)

#### 공간 구역성(Spatial Locality)

- 어느 하나의 페이지를 참조하면 그 근처의 페이지를 계속 참조할 가능성이 높다.
- 예) 배열 순회, 순차적 코드의 실행, 근처에 선언된 변수들

### 위킹 셋(Working Set)

프로세스가 일정 시간 동안 **자주 참조하는 페이지들의 집합**이다.

### 페이지 부재 빈도 방식

**페이지 부재 빈도(PFF; Page Fault Frequency)**는 페이지 부재가 일어나는 횟수를 의미한다.

페이지 부재 빈도 방식은 페이지 부재율에 따라 주기억장치의 페이지 프레임의 수를 늘리거나 줄여 **페이지 부재율을 적정 수준으로 유지**하는 방식이다.

### 프리페이징(Prepaging)

처음의 과도한 페이지 부재를 방지하기 위해 필요할 것 같은 **모든 페이지를 한꺼번에 페이지 프레임에 적재**하는 기법이다.

### 스래싱(Thrashing)

프로세스의 처리 시간보다 **페이지 교체에 소요되는 시간이 더 많아지는 현상**이다.

- 페이지 부재가 자주 발생하면 스래싱이 자주 발생한다.
- 다중 프로그래밍의 정도가 높아지면 CPU의 이용률은 어느 정도까지 높아지지만, 어느 시점부터는 스래싱이 나타나고 CPU의 이용률은 급격히 감소한다(책의 그래프 참고).

## 117섹션: 프로세스의 개요
