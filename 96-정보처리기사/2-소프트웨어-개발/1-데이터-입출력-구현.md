# 1장: 데이터 입출력 구현

## 28섹션: 자료 구조

### 자료 구조의 정의

자료 구조는 자료를 기억장치의 공간 내에 저장하는 방법을 결정한다.

- 선형 구조(Linear Structure)
  - 배열
  - 선형 리스트
    - 연속 리스트
    - 연결 리스트
  - 스택
  - 큐
  - 데크
- 비선형 구조(Non-Linear Structure)
  - 트리
  - 그래프

### 배열(Array)

동일한 자료형의 데이터들이 같은 크기로 나열되어 순서를 갖고 있는 집합이다.

- 정적인 자료 구조이다. 기억장소의 추가가 어렵고, 데이터 삭제 시 메모리의 낭비가 발생한다.
- 첨자를 이용하여 데이터에 접근한다.

### 선형 리스트(Linear List)

#### 연속 리스트(Contiguous List)

배열과 같이 연속적인 기억장소에 저장되는 자료 구조이다.

- 기억장소 이용 효율은 밀도가 1로서 가장 좋다.

#### 연결 리스트(Linked List)

임의의 기억공간에 기억시키되, 자료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결한 자료 구조이다.

- 노드의 삽입·삭제 작업이 용이하다.
- 접근 속도가 느리다.

### 스택(Stack)

리스트의 한쪽 끝으로만 자료의 삽입·삭제 이루어지는 자료 구조이다.

- **후입선출(LIFO; Last In First Out)**
- **오버플로(Overflow)**: 스택의 기억 공간이 가득 찬 상태에서 데이터가 삽입됨
- **언더플로(Underflow)**: 더 이상 삭제할 데이터가 없는 상태에서 데이터를 삭제함
- **TOP**: 가장 마지막으로 삽입된 자료가 기억된 위치를 가리킴
- **Bottom**: 스택의 가장 밑바닥
- **M**: 스택의 크기
- **Top**: 스택 포인터
- **X**: 스택의 이름
- 응용 분야: 재귀 호출, 후위 표현의 연산, 깊이 우선 탐색, 함수 호출의 순서 제어, 인터럽트의 처리, 수식 계산 및 수식 표기법, 컴파일러를 이용한 언어 번역 등

### 큐(Queue)

리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는 삭제 작업이 이루어지는 자료 구조이다.

- **선입선출(FIFO; First In First Out)**
- 시작과 끝을 표시하는 두 개의 포인터가 있다.
- **프런트(F, Front) 포인터**: 삭제 작업을 할 때 사용
- **리어(R, Rear) 포인터**: 삽입 작업을 할 때 사용
- 응용 분야: 운영체제의 작업 스케줄링

### 데크(Deque)

삽입과 삭제가 리스트의 양쪽 끝에서 모두 발생할 수 있는 자료 구조이다. Double Ended Queue의 약자이다.

- 스택과 큐의 장점만 따서 구성한 것이다.
- 입력 제한 데크는 Scroll, 출력 제한 데크는 Shelf이다.

### 그래프(Graph)

그래프 G는 정점 V(Vertex)와 간선 E(Edge)의 두 집합으로 이루어진다.

- 간선의 방향성 유무에 따라 방향 그래프와 무방향 그래프로 구분된다.
- 트리(Tree)는 사이클이 없는 그래프이다.

그래프의 최대 간선 수를 구하는 식은 다음과 같다.

- 방향 그래프: $n(n-1)$
- 무방향 그래프: $n(n-1)/2$

## 29섹션: 트리(Tree)

### 트리의 개요

트리는 정점(Node, 노드)과 선분(Branch, 가지)을 이용하며 사이클이 없는 그래프의 특수한 형태이다.

트리 관련 용어는 다음과 같다.

- 노드
- 근 노드(Root Node)
- 디그리(Degree, 차수): 각 노드에서 뻗어 나온 가지의 수
- 단말 노드(Terminal Node), 잎 노드(Leaf Node): 디그리가 0인 노드
- 자식 노드
- 부모 노드
- 형제 노드: 같은 부모를 갖는 노드들
- 트리의 디그리: 가장 큰 디그리 수

### 트리의 운행법(Traversal)

트리를 구성하는 각 노드들을 찾아가는 방법이다.

이진 트리의 운행법은 다음 세 가지가 있다. Root 위치에 따라 이름이 정해진다.

- **Preorder 운행**: Root → Left →  Right
- **Inorder 운행**: Left → Root → Right
- **Postorder 운행**: Left → Right → Root

### 수식의 표기법

산술식을 계산하기 위해 기억공간에 기억시키는 방법으로 이진 트리를 많이 사용한다.

$X=A/B*(C+D)+E$

- Infix → Prefix: $=X+/*AB+CDE$
- Infix → Postfix: $XAB/CD+*E+=$

$ABC-/DEF+*+$

- Postfix → Infix: $A/(B-C)+D*(E+F)$

## 30섹션: 정렬(Sort)

### 삽입 정렬(Insertion Sort)

- 키워드: **이미 순서화된 파일에...**, **n번째 키를 앞의 n-1개의 키와 비교하여...**
- 평균 수행 시간 복잡도: $O(n^2)$
- 최악의 수행 시간 복잡도: $O(n^2)$

### 쉘 정렬(Shell Sort)

- 삽입 정렬을 확장한 개념이다.
- 키워드: **매개변수**
- 평균 수행 시간 복잡도: $O(n^{1.5})$
- 최악의 수행 시간 복잡도: $O(n^2)$

### 선택 정렬(Selection Sort)

- 키워드: **n개의 레코드 중에서 최솟값을 찾아서...**
- 평균 수행 시간 복잡도: $O(n^2)$
- 최악의 수행 시간 복잡도: $O(n^2)$

### 버블 정렬(Bubble Sort)

- 키워드: **인접한 두 개의 레코드...**
- 평균 수행 시간 복잡도: $O(n^2)$
- 최악의 수행 시간 복잡도: $O(n^2)$

### 퀵 정렬(Quick Sort)

- 가장 빠른 정렬 방식이다.
- 스택을 사용한다.
- 분할과 정복 방식을 사용한다.
- 키워드: **하나의 파일을 부분적으로 나누어...**
- 평균 수행 시간 복잡도: $O(n\log_2n)$
- 최악의 수행 시간 복잡도: $O(n^2)$

### 힙 정렬(Heap Sort)

- 키워드: **전이진 트리(Complete Binary Tree)**
- 평균 수행 시간 복잡도: $O(n\log_2n)$
- 최악의 수행 시간 복잡도: $O(n\log_2n)$

### 2-Way 합병 정렬(Merge Sort)

- 키워드: **이미 정렬된 두 개의 파일을 한 개의 파일로...**
- 평균 수행 시간 복잡도: $O(n\log_2n)$
- 최악의 수행 시간 복잡도: $O(n\log_2n)$

### 기수 정렬(Radix Sort, Bucket Sort)

- 큐를 이용하여 자릿수(Digit) 별로 정렬하는 방식이다.
- 키워드: **버킷**
- 평균 수행 시간 복잡도: $O(dn)$
- 최악의 수행 시간 복잡도: $O(dn)$

### 검색-이분 검색/해싱

### 이분 검색
