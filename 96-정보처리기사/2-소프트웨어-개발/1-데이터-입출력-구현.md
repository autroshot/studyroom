# 1장: 데이터 입출력 구현

## 28섹션: 자료 구조

### 자료 구조의 정의

자료 구조는 자료를 기억장치의 공간 내에 저장하는 방법을 결정한다.

- 선형 구조(Linear Structure)
  - 배열
  - 선형 리스트
    - 연속 리스트
    - 연결 리스트
  - 스택
  - 큐
  - 데크
- 비선형 구조(Non-Linear Structure)
  - 트리
  - 그래프

### 배열(Array)

동일한 자료형의 데이터들이 같은 크기로 나열되어 순서를 갖고 있는 집합이다.

- 정적인 자료 구조이다. 기억장소의 추가가 어렵고, 데이터 삭제 시 메모리의 낭비가 발생한다.
- 첨자를 이용하여 데이터에 접근한다.

### 선형 리스트(Linear List)

#### 연속 리스트(Contiguous List)

배열과 같이 연속적인 기억장소에 저장되는 자료 구조이다.

- 기억장소 이용 효율은 밀도가 1로서 가장 좋다.

#### 연결 리스트(Linked List)

임의의 기억공간에 기억시키되, 자료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결한 자료 구조이다.

- 노드의 삽입·삭제 작업이 용이하다.
- 접근 속도가 느리다.

### 스택(Stack)

리스트의 한쪽 끝으로만 자료의 삽입·삭제 이루어지는 자료 구조이다.

- **후입선출(LIFO; Last In First Out)**
- **오버플로(Overflow)**: 스택의 기억 공간이 가득 찬 상태에서 데이터가 삽입됨
- **언더플로(Underflow)**: 더 이상 삭제할 데이터가 없는 상태에서 데이터를 삭제함
- **TOP**: 가장 마지막으로 삽입된 자료가 기억된 위치를 가리킴
- **Bottom**: 스택의 가장 밑바닥
- **M**: 스택의 크기
- **Top**: 스택 포인터
- **X**: 스택의 이름
- 응용 분야: 재귀 호출, 후위 표현의 연산, 깊이 우선 탐색, 함수 호출의 순서 제어, 인터럽트의 처리, 수식 계산 및 수식 표기법, 컴파일러를 이용한 언어 번역 등

### 큐(Queue)

리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는 삭제 작업이 이루어지는 자료 구조이다.

- **선입선출(FIFO; First In First Out)**
- 시작과 끝을 표시하는 두 개의 포인터가 있다.
- **프런트(F, Front) 포인터**: 삭제 작업을 할 때 사용
- **리어(R, Rear) 포인터**: 삽입 작업을 할 때 사용
- 응용 분야: 운영체제의 작업 스케줄링

### 데크(Deque)

삽입과 삭제가 리스트의 양쪽 끝에서 모두 발생할 수 있는 자료 구조이다. Double Ended Queue의 약자이다.

- 스택과 큐의 장점만 따서 구성한 것이다.
- 입력 제한 데크는 Scroll, 출력 제한 데크는 Shelf이다.

### 그래프(Graph)

그래프 G는 정점 V(Vertex)와 간선 E(Edge)의 두 집합으로 이루어진다.

- 간선의 방향성 유무에 따라 방향 그래프와 무방향 그래프로 구분된다.
- 트리(Tree)는 사이클이 없는 그래프이다.

그래프의 최대 간선 수를 구하는 식은 다음과 같다.

- 방향 그래프: $n(n-1)$
- 무방향 그래프: $n(n-1)/2$

## 29섹션: 트리(Tree)

### 트리의 개요

트리는 정점(Node, 노드)과 선분(Branch, 가지)을 이용하며 사이클이 없는 그래프의 특수한 형태이다.

트리 관련 용어는 다음과 같다.

- 노드
- 근 노드(Root Node)
- 디그리(Degree, 차수): 각 노드에서 뻗어 나온 가지의 수
- 단말 노드(Terminal Node), 잎 노드(Leaf Node): 디그리가 0인 노드
- 자식 노드
- 부모 노드
- 형제 노드: 같은 부모를 갖는 노드들
- 트리의 디그리: 가장 큰 디그리 수

### 트리의 운행법(Traversal)

트리를 구성하는 각 노드들을 찾아가는 방법이다.

이진 트리의 운행법은 다음 세 가지가 있다. Root 위치에 따라 이름이 정해진다.

- **Preorder 운행**: Root → Left →  Right
- **Inorder 운행**: Left → Root → Right
- **Postorder 운행**: Left → Right → Root

### 수식의 표기법

산술식을 계산하기 위해 기억공간에 기억시키는 방법으로 이진 트리를 많이 사용한다.

$X=A/B*(C+D)+E$

- Infix → Prefix: $=X+/*AB+CDE$
- Infix → Postfix: $XAB/CD+*E+=$

$ABC-/DEF+*+$

- Postfix → Infix: $A/(B-C)+D*(E+F)$

## 30섹션: 정렬(Sort)

### 삽입 정렬(Insertion Sort)

- 키워드: **이미 순서화된 파일에...**, **n번째 키를 앞의 n-1개의 키와 비교하여...**
- 평균 수행 시간 복잡도: $O(n^2)$
- 최악의 수행 시간 복잡도: $O(n^2)$

### 쉘 정렬(Shell Sort)

- 삽입 정렬을 확장한 개념이다.
- 키워드: **매개변수**
- 평균 수행 시간 복잡도: $O(n^{1.5})$
- 최악의 수행 시간 복잡도: $O(n^2)$

### 선택 정렬(Selection Sort)

- 키워드: **n개의 레코드 중에서 최솟값을 찾아서...**
- 평균 수행 시간 복잡도: $O(n^2)$
- 최악의 수행 시간 복잡도: $O(n^2)$

### 버블 정렬(Bubble Sort)

- 키워드: **인접한 두 개의 레코드...**
- 평균 수행 시간 복잡도: $O(n^2)$
- 최악의 수행 시간 복잡도: $O(n^2)$

### 퀵 정렬(Quick Sort)

- 가장 빠른 정렬 방식이다.
- 스택을 사용한다.
- 분할과 정복 방식을 사용한다.
- 키워드: **하나의 파일을 부분적으로 나누어...**
- 평균 수행 시간 복잡도: $O(n\log_2n)$
- 최악의 수행 시간 복잡도: $O(n^2)$

### 힙 정렬(Heap Sort)

- 키워드: **전이진 트리(Complete Binary Tree)**
- 평균 수행 시간 복잡도: $O(n\log_2n)$
- 최악의 수행 시간 복잡도: $O(n\log_2n)$

### 2-Way 합병 정렬(Merge Sort)

- 키워드: **이미 정렬된 두 개의 파일을 한 개의 파일로...**
- 평균 수행 시간 복잡도: $O(n\log_2n)$
- 최악의 수행 시간 복잡도: $O(n\log_2n)$

### 기수 정렬(Radix Sort, Bucket Sort)

- 큐를 이용하여 자릿수(Digit) 별로 정렬하는 방식이다.
- 키워드: **버킷**
- 평균 수행 시간 복잡도: $O(dn)$
- 최악의 수행 시간 복잡도: $O(dn)$

### 검색-이분 검색/해싱

### 이분 검색(Binary Search)

이분 검색(이진 검색)은 전체 파일을 두 개의 서브파일로 분리해가면서 Key 레코드를 검색하는 방식이다.

- 반드시 **순서화된 파일**어어야 검색할 수 있다.
- 찾고자 하는 Key 값을 파일의 **중간 레코드** Key 값과 비교하면서 검색한다.
- 중간 레코드 번호 $M=(F+L)/2$

### 해싱(Hashing)

해싱은 해시 테이블이라는 기억공간을 할당하고, 해시 함수를 이용하여 저장이나 검색 작업을 수행한다. 키-주소 변환 방법이라고도 한다.

#### 해시 테이블(Hash Table)

레코드를 한 개 이상 보관할 수 있는 버킷들로 구성된 기억공간이다. 보조기억장치나 주기억장치에 구성할 수 있다.

- 버킷(Bucket): 하나의 주소를 갖는 파일의 한 구역이다.
- 슬롯(Slot): 한 개의 레코드를 저장할 수 있는 공간으로 슬롯이 모여 하나의 버킷을 형성한다.
- Collision(충돌 현상): 두 레코드가 같은 주소를 갖는 현상이다.
- Synonym: 충돌로 인해 같은 Home Address를 갖는 레코드들의 집합이다.
- Overflow: Home Address의 버킷 내에 저장할 기억공간이 없는 상태이다.

> [!NOTE]
>
> ##### Collision 해결 방법
>
> - **체이닝**: 버킷에 할당된 연결 리스트에 데이터를 저장한다.
> - 개방 주소법(Open Addressing): 순차적으로 그 다음 빈 버킷을 찾아 데이터를 저장한다.
> - 재해싱(Rehashing): 새로운 해싱 함수로 새로운 홈 주소를 구한다.

### 해싱 함수(Hashing Function)

다음은 홈 주소를 구하는 방법에 따라 분류한 것이다. K는 레코드 키 값을 의미한다.

- **제산법(Division)**: K를 해시표의 크기보다 큰 수 중에서 **가장 작은 소수(Prime, Q)**로 나눈 나머지
- **제곱법(Mid-Square)**: K를 **제곱**한 후 그 중간 부분의 값
- **폴딩법(Folding)**: K를 **여러 부분으로 나눈 후** 각 부분의 값을 더하거나 XOR한 값
- 기수 변환법(Radix): 키 숫자의 진수를 다른 진수로 변환시켜 초과한 높은 자릿수는 절단
- 대수적 코딩법(Algebraic Coding): K의 각 자리의 비트 수를 한 다항식의 계수로 간주하여 계산
- **숫자 분석법(Digit Analysis, 계수 분석법)**: K를 이루는 **숫자의 분포를 분석**하여 비교적 고른 자리를 필요한 만큼 택함
- 무작위법(Random)

## 32섹션: 데이터베이스 개요

### 데이터저장소

소프트웨어 개발 과정에서 다루어야 할 데이터들을 논리적인 구조로 조직화하거나, 물리적인 공간에 구축한 것이다.

- 논리 데이터저장소와 물리 데이터저장소로 구분된다.

### 데이터베이스

특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임이다.

- **통합된 데이터(Integrated Data)**: 중복을 배제한 데이터
- **저장된 데이터(Stored Data)**: 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료
- **운영 데이터(Operational Data)**: 조직의 업무를 수행하는 데 반드시 필요한 자료
- **공용 데이터(Shared Data)**: 여러 시스템들이 공동으로 소유한 자료

### DBMS(DataBase Management System; 데이터베이스 관리 시스템)

DBMS는 사용자와 데이터베이스 사이에 있는 소프트웨어이다.

- 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성의 문제를 해결한다.
- 데이터베이스의 구성, 접근 방법, 유지관리에 대한 책임을 진다.
- 필수 기능은 다음과 같다.
  - 정의(Definition) 기능
  - 조작(Manipulation) 기능: 데이터 검색, 갱신, 삽입, 삭제 등
  - 제어(Control) 기능
    - 무결성
    - 권한 검사
    - 병행 제어(Concurrency Control)

### DBMS의 장단점

단점은 다음과 같다.

- 전문가 부족
- 전산화 비용
- 과부하
- 예비와 회복이 어려움
- 복잡한 시스템

### 스키마(Schema)

스키마는 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터의 집합이다.

다음과 같이 구분할 수 있다.

- 외부 스키마: 사용자나 개발자의 입장에서 본 데이터베이스 구조
- 개념 스키마: 하나만 존재. 데이터베이스 전체를 정의한 것
- 내부 스키마: 물리적 저장장치의 입장에서 본 데이터베이스 구조

