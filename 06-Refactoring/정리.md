## 1. 리팩터링: 첫 번째 예시

리팩터링은 겉으로 드러나는 코드의 기능은 바꾸지 않으면서 내부 구조를 개선하는 것이다. 코드를 작성하고 난 뒤에 설계를 개선하는 일이다.

프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링한다.

리팩터링하기 전에 테스트부터 마련한다. 테스트는 자가진단하도록 만든다.

리팩터링은 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.

하나의 리팩터링을 끝낼 때마다 커밋한다. 이런 자잘한 변경들이 쌓여서 의미 있는 단위가 되면 공유 저장소로 푸시한다.

함수의 반환 값에서 `result`를 사용한다.

리팩터링으로 인한 성능 문제는 일단 무시하는 것이 좋다. 나중에 문제가 되면 성능을 개선하면 된다.

항시 코드베이스를 작업하기 전보다 더 건강하게 고친다. "도착했을 때보다 깔끔하게 정돈하고 떠난다"는 캠핑 규칙의 변형이다.

좋은 코드를 가늠하는 확실한 방법은 '얼마나 수정하기 쉬운가'다.

## 2. 리팩터링 원칙

***리팩터링은 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법이다.***

소프트웨어를 개발하는 동안 '기능 추가'와 '리팩터링'라는 두 모자를 자주 바꿔 쓸 수 있다.

리팩터링을 하는 이유는 다음과 같다.

1. 소프트웨어 설계가 좋아진다.
2. 소프트웨어를 이해하기 쉬워진다.
3. 버그를 쉽게 찾을 수 있다.
4. 프로그래밍 속도를 높일 수 있다.

다음 그래프는 리팩터링과 프로그래밍 속도의 관련성을 보여준다.

<img src="https://user-images.githubusercontent.com/95019875/174960175-5b1cda28-4c1f-45ec-9636-2fba5b60422c.png" alt="좋은 설계 나쁜 설계 그래프" style="zoom: 33%;" />

**설계 지구력 가설** - 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다.

리팩터링은 코드를 명확하게 만드는 과정이다.

**3의 법칙** - 비슷한 일을 세 번 하게 되면 리팩터링한다.

리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.

**CI**(Continuous Integration)는 지속적 통합으로 TBD(Trunk-Based Development) 트렁크 기반 개발이라고도 불린다. CI와 리팩터링을 합쳐 **XP**(eXtreme Programming)라고 부른다. XP는 애자일 소프트웨어 방법론 중 하나이다.

리팩터링을 위해서는 자가 테스트 코드(self-testing code)가 필요하다.

유연성 메커니즘 - 다양한 예상 시나리오에 대응하기 위해 함수의 매개변수가 그 예이다.

유연성 메커니즘과 대비되는 것이 애그니(YAGNI: you aren't going to need it)이다. 애그니는 간결한 설계, 점진적 설계이다. 변화를 대비해서 유연성을 넣지 않고 지금의 요구사항만을 해결하는 소프트웨어를 만드는 것이다. 리팩터링의 뒷받침이 필요하다.

자가 테스트 코드, 지속적 통합, 리팩터링의 세 가지 기법을 통해 YAGIN 설계 방식으로 개발을 할 수 있다.

진화형 아키텍처(evolutionary architecture) - 아키텍처 관련 결정을 시간을 두고 반복해 내릴 수 있다는 장점을 활용하는 패턴과 실천법을 추구한다.

**TDD**(Test-Driven Development) - 테스트 주도 개발로 자가 테스트 코드와 리팩터링을 묶은 것이다.

코드 전체를 최적화한다면 그중 90%는 효과가 거의 없는 시간 낭비이다.

## 3. 코드에서 나는 악취

| 악취                                 | 탈취용 리팩터링 기법                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| 기이한 이름                          | 함수 선언 바꾸기, 변수 이름 바꾸기, 필드 이름 바꾸기         |
| 중복 코드                            | 함수 추출하기, 문장 슬라이드하기, 메서드 올리기              |
| 긴 함수                              | 함수 추출하기(99%), 임시 변수를 질의 함수로 바꾸기, 매개변수 객체 만들기, 객체 통째로 넘기기, 함수를 명령으로 바꾸기, 조건문 분해하기, 함수 추출하기, 조건부 로직을 다형성으로 바꾸기, 반복문 쪼개기 |
| 긴 매개변수 목록                     | 매개변수를 질의 함수로 바꾸기, 객체 통째로 넘기기, 매개변수 객체 만들기, 플래그 인수 제거하기, 여러 함수를 클래스로 묶기 |
| 전역 데이터                          | 변수 캡슐화하기                                              |
| 가변 데이터                          | 변수 캡슐화하기, 변수 쪼개기, 문장 슬라이드하기, 함수 추출하기, 질의 함수와 변경 함수 분리하기, 세터 제거하기, 파생 함수를 질의 함수로 바꾸기, 여러 함수를 클래스로 묶기, 여러 함수를 변환 함수로 묶기, 참조를 값으로 바꾸기 |
| 뒤엉킨 변경                          | 단계 쪼개기, 함수 옮기기, 함수 추출하기, 클래스 추출하기     |
| 산탄총 수술                          | 함수 옮기기, 필드 옮기기, 여러 함수를 클래스로 묶기, 여러 함수를 변환 함수로 묶기, 단계 쪼개기, 함수 인라인하기, 클래스 인라인하기 |
| 기능 편애                            | 함수 옮기기, 함수 추출하기, 함수 옮기기                      |
| 데이터 뭉치                          | 클래스 추출하기, 매개변수 객체 만들기, 객체 통째로 넘기기    |
| 기본형 집착                          | 기본형을 객체로 바꾸기, 타입 코드를 서브클래스로 바꾸기, 조건부 로직을 다형성으로 바꾸기, 클래스 추출하기, 매개변수 객체 만들기 |
| 반복되는 switch문                    | 조건부 로직을 다형성으로 바꾸기                              |
| 반복문                               | 반복문을 파이프라인으로 바꾸기                               |
| 성의 없는 요소                       | 함수 인라인하기, 클래스 인라인하기, 계층 합치기              |
| 추측성 일반화                        | 계층 합치기, 함수 인라인하기, 클래스 인라인하기, 함수 선언 바꾸기, 죽은 코드 제거하기 |
| 임시 필드                            | 클래스 추출하기, 함수 옮기기, 특이 케이스 추가하기           |
| 메시지 체인                          | 위임 숨기기, 함수 추출하기, 함수 옮기기                      |
| 중개자                               | 중개자 제거하기, 함수 인라인하기                             |
| 내부자 거래                          | 함수 옮기기, 필드 옮기기, 위임 숨기기, 서브클래스를 위임으로 바꾸기, 슈퍼클래스를 위임으로 바꾸기 |
| 거대한 클래스                        | 클래스 추출하기, 슈퍼클래스 추출하기, 타입 코드를 서브클래스로 바꾸기 |
| 서로 다른 인터페이스의 대안 클래스들 | 함수 선언 바꾸기, 함수 옮기기, 슈퍼클래스 추출하기           |
| 데이터 클래스                        | 레코드 캡슐화하기, 세터 제거하기, 함수 옮기기, 함수 추출하기, 단계 쪼개기 |
| 상속 포기                            | 메서드 내리기, 필드 내리기, 서브클래스를 위임으로 바꾸기, 슈퍼클래스를 위임으로 바꾸기 |
| 주석                                 | 함수 추출하기, 함수 선언 바꾸기, 어서션 추가하기             |

### 1. 기이한 이름

마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.

### 3. 긴 함수

짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다.

주석을 달아야 할 만한 부분은 함수로 만든다. 함수의 본문에는 원래 주석으로 설명하려던 코드가 담기고, 함수 이름은 동작 방식이 아닌 '의도'가 드러나게 짓는다.

원래 코드보다 길어지더라도 함수로 뽑는다. 핵심은 함수의 길이가 아닌, 함수의 목적(의도)과 구현 코드의 괴리가 얼마나 큰가다. '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리하다.

### 5. 전역 데이터

전역 데이터는 악취 중 가장 지독한 축에 속한다. 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제다.

### 7. 뒤엉킨 변경

뒤엉킨 변경은 단일 책임 원칙(Single Responsibility Principle)이 제대로 지켜지지 않을 때 나타난다.

예컨대 지원해야 할 데이터베이스가 추가될 때마다 함수 세 개를 바꿔야 한다면 뒤엉킨 변경이 발생했다는 뜻이다.

### 8. 산탄총 수술

|                 | 뒤엉킨 변경             | 산탄총 수술          |
| --------------- | ----------------------- | -------------------- |
| 원인            | 맥락을 잘 구분하지 못함 | 동일                 |
| 해법(원리)      | 맥락을 명확히 구분      | 동일                 |
| 발생 과정(현상) | 한 코드에 섞여 들어감   | 여러 코드에 흩뿌려짐 |
| 해법(실제 행동) | 맥락별로 분리           | 맥락별로 모음        |

### 9. 기능 편애

기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용을 할 일이 더 많을 때 풍기는 냄새다.

### 10. 데이터 뭉치

데이터 항목 서너 개가 여러 곳에서 항상 함께 뭉쳐 다니는 모습을 보이면 보금자리를 따로 마련해줘야 마땅하다.

### 11. 기본형 집착

전화번호를 단순히 문자열로만 표현하는 것이 대표적인 예시이다.

### 14. 성의 없는 요소

함수, 클래스, 인터페이스와 같은 프로그램 요소가 필요 없을 때도 있다.

### 16. 임시 필드

간혹 특정 상황에서만 값이 설정되는 필드를 가진 클래스가 있다.

### 17. 메시지 체인

메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.

### 19. 내부자 거래

개발자는 모듈 사이의 벽을 두껍게 세우기를 좋아하며, 모듈 사이의 데이터 거래가 많으면 결합도(coupling)가 높아진다고 투덜댄다.

### 24. 주석

**주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.**

## 4. 테스트 구축하기

모든 테스트를 완전히 자동화하고 그 결과까지 스스로 검사하게 만들자.

테스트 스위트(suite)는 강력한 버그 검출 도구로, 버그를 찾는 데 걸리는 시간을 대폭 줄여준다.

테스트를 작성하기 가장 좋은 시점은 프로그래밍을 시작하기 전이다. 테스트를 작성하다 보면 원하는 기능을 추가하기 위해 무엇이 필요한지 고민하게 된다. 구현보다 인터페이스에 집중하게 된다는 장점도 있다.

TDD - 테스트를 작성하고, 이 테스트를 통과하게끔 코드를 작성하고, 결과 코드를 최대한 깔끔하게 리팩터링하는 과정을 짧은 주기로 반복한다. 즉 테스트-코딩-리팩터링 과정을 거친다.

실패해야 할 상황에서는 반드시 실패하게 만들자. 테스트가 실패하는 모습도 한 번 확인해본다.

테스트끼리 상호작용하게 하는 공유 픽스처는 가급적 사용하지 말아야 한다.

문제가 생길 가능성이 있는 경계 조건을 생각해봐야 한다. 예를 들어 숫자형이라면 0, 음수, NaN, 또는 다른 타입의 값이 들어오는 경우를 상상할 수 있다.

버그 리포트를 받으면 가장 먼저 그 버그를 드러내는 단위 테스트부터 작성하자.
