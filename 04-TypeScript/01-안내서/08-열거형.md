# 열거형

열거형(Enum)으로 이름이 있는 상수들의 집합을 정의할 수 있다. 열거형을 사용하면 의도를 문서화 하거나 구분되는 사례 집합을 더 쉽게 만들수 있다. 타입스크립트는 숫자와 문자열 기반의 열거형을 제공한다.

### 숫자 열거형

열거형은 `enum` 키워드를 사용해 정의할 수 있다.

```tsx
enum Direction {
    Up = 1,
    Down,
    Left,
    Right,
}
```

위 코드에서 `Up`이 `1` 로 초기화된 숫자 열거형을 선언했다. 뒤따르는 멤버들은 자동으로 증가된 값을 갖는다. 즉 `Direction.Up` 은 `1`, `Down` 은 `2`, `Left` 는 `3`, `Right` 은 `4` 를 값으로 가진다.

원한다면 전부 초기화하지 않을 수도 있다.

```tsx
enum Direction {
    Up,
    Down,
    Left,
    Right,
}
```

이 경우에는 `Up` 값은 `0`, `Down` 은 `1` 이 된다. 자동 증가하는 기능은 멤버 값 자체는 상관없지만, 각 값이 같은 열거형의 다른 값과 구별되야 하는 경우에 유용하다.

열거형을 사용하는 것은 간단하다. 프로퍼티로 어떤 멤버에도 접근하며, 열거형의 이름을 사용해 타입을 선언할 수 있다.

```tsx
enum Response {
    No = 0,
    Yes = 1,
}

function respond(recipient: string, message: Response): void {
    // ...
}

respond('Princess Caroline', Response.Yes)
```

숫자 열거형은 나중에 배울 [계산된 멤버와 상수 멤버]()를 섞어서 사용할 수 있다.

다만 초기화되지 않은 열거형은 첫 번째이거나, 숫자 상수 또는 기타 상수 열거형 멤버로 초기화된 숫자 열거형 다음에 와야 한다.

즉 다음 방식은 허용되지 않는다.

```tsx
enum E {
    A = getSomeValue(),
    B, // 오류! 앞에 나온 A가 계산된 멤버이므로 초기화가 필요하다.
}
```

### 문자열 열거형

문자열 열거형은 유사한 개념이지만 아래 설명된 대로 약간의 [런타임에서의 차이]()가 존재한다.

문자열 열거형에서 각 멤버들은 문자열 리터럴 또는 다른 문자열 열거형의 멤버로 상수 초기화되어야 한다.

```tsx
enum Direction {
    Up = 'UP',
    Down = 'DOWN',
    Left = 'LEFT',
    Right = 'RIGHT',
}
```

문자열 열거형은 자동 증가하는 기능은 없지만 '직렬화'가 잘 된다는 이점이 있다.

디버깅 과정에서 숫자 열거형의 런타임 값을 읽어야 하는 경우, 그 값이 불분명할 때가 있다. 자체적으로 유용한 의미를 전달하지 않는다([역 매핑]()이 도움이 될 수 있다).

이때 문자열 열거형을 사용하면 코드를 실행할 때, 열거형 멤버 자체의 이름과 관계없이 의미 있고 읽을 수 있는 값을 제공할 수 있다.

### 잡다한 열거형

기술적으로 열거형은 문자열과 숫자 멤버를 섞어서 사용할 수 있지만 굳이 그렇게 할 이유는 없다.

```tsx
enum BooleanLikeHeterogeneousEnum {
    No = 0,
    Yes = 'YES',
}
```

정말 똑똑한 방법으로 자바스크립트 런타임 동작을 이용하려는 것이 아니라면, 이렇게 하지 않는 것을 권장한다.