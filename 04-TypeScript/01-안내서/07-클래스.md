# 클래스

## 클래스

다음은 간단한 클래스 예시이다.

```tsx
class Greeter {
    greeting: string;
    
    constructor(message: string) {
        this.greeting = message;
    }
    
    greet() {
        return 'Hello, '' + this.greeting;
    }
}

let greeter = new Greeter('world');
```

새로운 클래스 `Greeter`를 선언했다. 이 클래스는 3개의 멤버를 가지고 있다. `greeting` 프로퍼티, 생성자, `greet` 메서드이다.

클래스 안에서 클래스의 멤버를 참조할 때 `this.`를 앞에 덧붙인다. 이는 멤버에 접근하는 것을 의미한다.

마지막 줄에서 `new`를 사용하여 `Greeter` 클래스의 인스턴스를 생성한다. 이 코드는 이전에 정의한 생성자를 호출하여 `Greeter` 형태의 새로운 객체를 만들고 인수로 초기화한다.

## 상속

타입스크립트에서는 일반적인 객체 지향 패턴을 사용할 수 있다. 클래스 기반 프로그래밍의 가장 기본적인 패턴 중 하나는 상속을 이용하여 이미 존재하는 클래스를 확장해 새로운 클래스를 만드는 것이다.

예시:

```tsx
class Animal {
    move(distanceInMeters: number = 0) {
        console.log(`Animal moved ${distanceInMeters}m.`);
    }
}

class Dog extends Animal {
    bark() {
        console.log('Woof! Woof!');
    }
}

const dog = new Dog();
dog.bark();
dog.move(10);
dog.bark();
```

클래스는 기초 클래스로부터 프로퍼티와 메서드를 상속받는다.

예시의 `Dog`는 `extends` 키워드를 사용하여 `Animal`이라는 기초 클래스로부터 파생된 파생 클래스이다. 파생된 클래스는 하위 클래스(subclasses), 기초 클래스는 상위 클래스(superclasses)라고 부르기도 한다.

`Dog`는 `Animal`의 기능을 확장하기 때문에, `bark()`와 `move()`를 모두 가진 `Dog` 인스턴스를 생성할 수 있다.

다음은 조금 더 복잡한 예시이다.

```tsx
class Animal {
    name: string;
    
    constructor(theName: string) { this.name = theName; }
    
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    
    move(distanceInMeters = 5) {
        console.log("Slithering...");
        super.move(distanceInMeters);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    
    move(distanceInMeters = 45) {
        console.log('Galloping...'');
        super.move(distanceInMeters);
    }
}

let sam = new Snake('Sammy the Python');
let tom: Animal = new Horse('Tommy the Palomino');

sam.move();
tom.move(34);
```

이번에도 `extends` 키워드를 사용하여 `Animal`의 하위클래스, `Horse`와 `Snake`를 생성한다.

파생된 클래스의 생성자 함수는 기초 클래스의 생성자를 실행할 `super()`를 호출해야 한다. 생성자 내에서 `this`에 있는 프로퍼티에 접근하기 전에 `super()`를 먼저 호출해야 한다. 이는 타입스크립트에서 중요한 규칙이다.

이 예시는 기초 클래스의 메서드를 하위 클래스에 특화된 메서드로 **오버라이드**하는 방법을 보여준다.

여기서 `Snake`와 `Horse`는 `Animal`의 `move`를 오버라이드해서 각각 클래스의 특성에 맞는 기능을 가진 `move`를 생성한다. `tom`은 `Animal`로 선언되었지만 `Horse`의 값을 가지므로 `tom.move(34)`는 `Horse`의 오버라이딩 메서드를 호출한다.

따라서 결과는 다음과 같다.

```
Slithering...
Sammy the Python moved 5m.
Galloping...
Tommy the Palomino moved 34m.
```

## public, private, protected 지정자

### 기본값은 public

타입스크립트에서는 기본적으로 각 멤버는 `public`이다.

명시적으로 멤버를 `public`으로 표시할 수도 있다.

이전 섹션의 `Animal` 클래스를 다음과 같은 방식으로 작성할 수 있다.

```tsx
class Animal {
    public name: string;
    
    public constructor(theName: string) { this.name = theName; }
    
    public move(distanceInMeters: number) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}
```

### ECMAScript private 필드

타입스크립트 3.8에서 비공개 필드를 위한 자바스크립트의 새로운 문법을 지원한다.

```tsx
class Animal {
    #name: string;
    constructor(theName: string) { this.#name = theName; }
}

new Animal('Cat').#name; // 프로퍼티 '#name'은 비공개 식별자이기 때문에 'Animal' 클래스 외부에서 접근할 수 없다.
```

### 타입스크립트의 private 이해하기

타입스크립트에는 클래스 외부에서 멤버에 접근하지 못하도록 멤버를 `private`으로 표시할 수 있다.

```tsx
class Animal {
    private name: string;
    
    constructor(theName: string) { this.name = theName; }
}

new Animal('Cat').name; // 오류: 'name'은 비공개로 선언되어 있다.
```

타입스크립트는 구조적인 타입 시스템이다. 두 개의 다른 타입을 비교할 때 어디서 왔는지와 상관없이 모든 멤버의 타입이 호환 된다면, 그 타입들 자체가 호환 가능하다고 본다.

그러나 `private` 및 `protected` 멤버가 있는 타입들을 비교할 때는 타입을 다르게 처리한다. 호환된다고 판단되는 두 개의 타입 중 한 쪽에서 `private` 멤버를 가지고 있다면, 다른 한 쪽도 무조건 동일한 선언에 `private` 멤버를 가지고 있어야 한다. 이것은 `protected` 멤버에도 적용된다.

예시:

```tsx
class Animal {
    private name: string;
    
    constructor(theName: string) { this.name = theName; }
}

class Rhino extends Animal {
    constructor() { super('Rhino'); }
}

class Employee {
    private name: string;
    
    constructor(theName: string) { this.name = theName; }
}

let animal = new Animal('Goat');
let rhino = new Rhino();
let employee = new Employee('Bob');

animal = rhino;
animal = employee; // 오류: 'Animal'과 'Employee'은 호환될 수 없다.
```

이 예시에는 `Animal`과 `Animal`의 하위클래스인 `Rhino`가 있다. `Animal`과 형태가 같아보이는 `Employee`라는 클래스도 있다. 이 클래스들의 인스턴스를 생성하여 할당하고 어떻게 작동하는지 살펴보겠다.

`Animal`과 `Rhino`는 `Animal`의 `private name:string`이라는 동일한 선언으로 `private` 부분을 공유하기 때문에 호환이 가능하다. 하지만 `Employee`의 경우는 다르다. `Employee`를 `Animal`에 할당하면 타입이 호환되지 않는다는 오류가 발생한다. `Employee`는 `name`이라는 `private` 멤버를 가지고 있지만 `Animal`에서 선언한 것이 아니기 때문이다.

### protected 이해하기

`protected` 지정자는 `protected`로 선언된 멤버를 파생된 클래스 내에서 접근할 수 있다는 점만 제외하면 `private` 지정자와 매우 유사하게 동작한다.

예시:

```tsx
class Person {
    protected name: string;
    
    constructor(name: string) { this.name = name; }
}

class Employee extends Person {
    private department: string;

    constructor(name: string, department: string) {
        super(name);
        this.department = department;
    }

    public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    }
}

let howard = new Employee('Howard', 'Sales');
console.log(howard.getElevatorPitch());
console.log(howard.name); // 오류
```

`Person` 외부에서는 `name`을 사용할 수 없다. 반면 `Employee`는 `Person`에서 파생되었기 때문에 `Employee`의 인스턴스 메서드 내에서는 여전히 사용할 수 있다.

생성자도 `protected`로 표시할 수 있다. 이는 클래스 외부에서 인스턴스를 만드는 것은 불가능하지만 확장은 가능하다는 것을 의미한다.

예시:

```tsx
class Person {
    protected name: string;
    
    protected constructor(theName: string) { this.name = theName; }
}

// Employee는 Person을 확장할 수 있다.
class Employee extends Person {
    private department: string;

    constructor(name: string, department: string) {
        super(name);
        this.department = department;
    }

    public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    }
}

let howard = new Employee('Howard', 'Sales');
let john = new Person('John'); // 오류: 'Person'의 생성자는 protected이다.
```

## 읽기전용 지정자

`readonly` 키워드를 사용하여 프로퍼티를 읽기전용으로 만들 수 있다. 읽기전용 프로퍼티는 선언이나 생성자에서 초기화해야 한다.

```tsx
class Octopus {
    readonly name: string;
    readonly numberOfLegs: number = 8;
    
    constructor(theName: string) {
        this.name = theName;
    }
}
let dad = new Octopus('Man with the 8 strong legs');
dad.name = 'Man with the 3-piece suit'; // 오류: name은 읽기전용이다.
```

## 매개변수 프로퍼티

위 예시의 `Octopus` 클래스 내에서 `name`이라는 읽기전용 멤버와 `theName`이라는 생성자 매개변수를 선언했다. 이 매개변수는 `Octopus`의 생성자가 수행된 후에 `theName`의 값에 접근하기 위해서 필요하다. 

매개변수 프로퍼티를 사용하면 한 곳에서 멤버를 만들고 초기화할 수 있다. 

다음은 매개변수 프로퍼티를 사용한 `Octopus`클래스이다.

```tsx
class Octopus {
    readonly numberOfLegs: number = 8;
    
    constructor(readonly name: string) {
    }
}
```

생성자에 짧아진 `readonly name: string` 파라미터를 사용하여 `theName`을 제거하고 `name` 멤버를 생성하고 초기화했다. 즉 선언과 할당을 한 곳으로 통합했다.

매개변수 프로퍼티는 접근 지정자나 `readonly`, 또는 둘 모두를 생성자 매개변수에 접두어로 붙여 선언한다. 매개변수 프로퍼티에 `private`을 사용하면 비공개 멤버를 선언하고 초기화한다. `public`, `protected`, `readonly`도 동일하게 사용할 수 있다.