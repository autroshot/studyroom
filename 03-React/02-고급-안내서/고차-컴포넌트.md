# 고차 컴포넌트

고차 컴포넌트(HOC, Higher-Order Component)는 컴포넌트 로직을 재사용하기 위한 리액트의 고급 기술이다. HOC는 리액트 API의 일부가 아니라 리액트의 구성적 특성에서 나오는 패턴이다.

**고차 컴포넌트는 컴포넌트를 받아서 새 컴포넌트를 반환하는 함수이다.**

```js
const EnhancedComponent = higherOrderComponent(WrappedComponent);
```

컴포넌트는 props를 UI로 변환하는 반면, 고차 컴포넌트는 컴포넌트를 다른 컴포넌트로 변환한다.

HOC는 리덕스의 [`connect`](https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect)와 릴레이의 [`createFragmentContainer`](https://relay.dev/docs/v10.1.3/fragment-container/#createfragmentcontainer)와 같은 타사 리액트 라이브러리에서 흔하게 볼 수 있다.

이 문서에서는 고차 컴포넌트가 유용한 이유와 직접 작성하는 방법에 대해 설명한다.

## 횡단 관심사에 HOC 사용하기

컴포넌트는 리액트에서 코드 재사용의 기본 단위이다. 그러나 일부 패턴은 기존 컴포넌트에 적합하지 않다.

예를 들어 주석 목록을 렌더링하기 위해 외부 데이터 소스를 구독하는 `CommentList` 구성 요소가 있다고 가정해 보겠다.

```jsx
class CommentList extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {
      // DataSource는 전역 데이터 소스이다.
      comments: DataSource.getComments()
    };
  }

  componentDidMount() {
    // 변경을 구독한다.
    DataSource.addChangeListener(this.handleChange);
  }

  componentWillUnmount() {
    // 리스너를 정리한다.
    DataSource.removeChangeListener(this.handleChange);
  }

  handleChange() {
    // 데이터 소스가 변경될 때마다 컴포넌트의 상태를 업데이트한다.
    this.setState({
      comments: DataSource.getComments()
    });
  }

  render() {
    return (
      <div>
        {this.state.comments.map((comment) => (
          <Comment comment={comment} key={comment.id} />
        ))}
      </div>
    );
  }
}
```

이후에 유사한 패턴을 따르는 단일 블로그 게시물을 구독하기 위한 구성 요소를 작성한다.

```jsx
class BlogPost extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {
      blogPost: DataSource.getBlogPost(props.id)
    };
  }

  componentDidMount() {
    DataSource.addChangeListener(this.handleChange);
  }

  componentWillUnmount() {
    DataSource.removeChangeListener(this.handleChange);
  }

  handleChange() {
    this.setState({
      blogPost: DataSource.getBlogPost(this.props.id)
    });
  }

  render() {
    return <TextBlock text={this.state.blogPost} />;
  }
}
```

`CommentList`와 `BlogPost` 동일하지 않다. `DataSource`의 다른 메서드를 호출하고 렌더링하는 것이 다르다. 그러나 구현의 대부분은 동일하다.

- 마운트 시 `DataSource`에 변경 리스너를 추가한다.
- 리스너 내부에서 데이터 소스가 변경될 때마다 `setState`를 호출한다.
- 마운트 해제 시 변경 리스너를 제거한다.

대형 앱에서 `DataSource`를 구독하고 `setState`를 호출하는 동일한 패턴이 계속 반복된다고 상상할 수 있다. 우리는 이 로직을 한 곳에서 정의하고 여러 구성 요소에서 공유할 수 있는 추상화를 원한다. 바로 여기에 고차 구성 요소를 사용할 수 있다.

`DataSource`를 구독하는 `CommentList`와 `BlogPost` 같은 구성 요소를 생성하는 함수를 만들 수 있다. 이 함수는 구독 데이터를 프랍으로 받는 자식 구성 요소를 인수로 받는다. `withSubscription` 함수를 호출해 보겠다.

```jsx
const CommentListWithSubscription = withSubscription(
  CommentList,
  (DataSource) => DataSource.getComments()
);

const BlogPostWithSubscription = withSubscription(
  BlogPost,
  (DataSource, props) => DataSource.getBlogPost(props.id)
);
```

첫 번째 매개변수는 래핑된 컴포넌트이다. 두 번째 매개변수는 주어진 `DataSource`와 현재 프랍에서 원하는 데이터를 검색한다.

`CommentListWithSubscription`과 `BlogPostWithSubscription`이 렌더링되면 `DataSource`에서 검색된 최신 데이터가 포함된 `data` 프랍이 `CommentList`와 `BlogPost`에 전달된다.

```jsx
// 이 함수는 컴포넌트를 받는다.
function withSubscription(WrappedComponent, selectData) {
  // 다른 컴포넌트를 반환한다.
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.handleChange = this.handleChange.bind(this);
      this.state = {
        data: selectData(DataSource, props)
      };
    }

    componentDidMount() {
      // 구독을 담당한다.
      DataSource.addChangeListener(this.handleChange);
    }

    componentWillUnmount() {
      DataSource.removeChangeListener(this.handleChange);
    }

    handleChange() {
      this.setState({
        data: selectData(DataSource, this.props)
      });
    }

    render() {
      // 최신 데이터가 포함된 래핑된 컴포넌트를 렌더링한다.
      // 추가 props를 건네주는 것을 주목해야 한다.
      return <WrappedComponent data={this.state.data} {...this.props} />;
    }
  };
}
```

HOC는 입력 구성 요소를 수정하지 않으며 동작을 복사하기 위해 상속을 사용하지도 않는다. 오히려 HOC는 원래 구성 요소를 컨테이너 구성 요소에 **래핑**하여 구성한다. HOC는 부작용이 없는 순수 함수이다.

래핑된 구성 요소는 렌더링에 사용하는 새 `data` 프랍과 함께 컨테이너의 모든 프랍을 받는다. HOC는 데이터가 사용되는 방법이나 이유에 관심이 없으며 래핑된 구성 요소는 데이터의 출처에 관심이 없다.

`withSubscription`는 일반적인 함수이므로 원하는 만큼 인수를 추가할 수 있다. 예를 들어 래핑된 구성 요소에서 HOC를 추가로 분리하기 위해 `data` 프랍의 이름을 설정 가능하게 만들 수 있다. 또는 `shouldComponentUpdate`를 설정하는 인수나 데이터 소스를 설정하는 인수를 받을 수 있다. HOC가 구성 요소가 정의되는 방식을 완전히 제어하기 때문에 이 모든 것이 가능하다.

구성 요소와 마찬가지로 `withSubscription`와 래핑된 구성 요소 간의 계약은 전적으로 프랍에 기반한다. 이렇게 하면 래핑된 구성 요소에 동일한 프랍을 제공하는 한 HOC를 쉽게 교체할 수 있다. 예를 들어 데이터 가져오기 라이브러리를 변경할 때 유용할 수 있다.