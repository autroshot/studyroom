# 고차 컴포넌트

고차 컴포넌트(HOC, Higher-Order Component)는 컴포넌트 로직을 재사용하기 위한 리액트의 고급 기술이다. HOC는 리액트 API의 일부가 아니라 리액트의 구성적 특성에서 나오는 패턴이다.

**고차 컴포넌트는 컴포넌트를 받아서 새 컴포넌트를 반환하는 함수이다.**

```js
const EnhancedComponent = higherOrderComponent(WrappedComponent);
```

컴포넌트는 props를 UI로 변환하는 반면, 고차 컴포넌트는 컴포넌트를 다른 컴포넌트로 변환한다.

HOC는 리덕스의 [`connect`](https://github.com/reduxjs/react-redux/blob/master/docs/api/connect.md#connect)와 릴레이의 [`createFragmentContainer`](https://relay.dev/docs/v10.1.3/fragment-container/#createfragmentcontainer)와 같은 타사 리액트 라이브러리에서 흔하게 볼 수 있다.

이 문서에서는 고차 컴포넌트가 유용한 이유와 직접 작성하는 방법에 대해 설명한다.

## 횡단 관심사에 HOC 사용하기

컴포넌트는 리액트에서 코드 재사용의 기본 단위이다. 그러나 일부 패턴은 기존 컴포넌트에 적합하지 않다.

예를 들어 주석 목록을 렌더링하기 위해 외부 데이터 소스를 구독하는 `CommentList` 컴포넌트가 있다고 가정해 보겠다.

```jsx
class CommentList extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {
      // DataSource는 전역 데이터 소스이다.
      comments: DataSource.getComments()
    };
  }

  componentDidMount() {
    // 변경을 구독한다.
    DataSource.addChangeListener(this.handleChange);
  }

  componentWillUnmount() {
    // 리스너를 정리한다.
    DataSource.removeChangeListener(this.handleChange);
  }

  handleChange() {
    // 데이터 소스가 변경될 때마다 컴포넌트의 상태를 업데이트한다.
    this.setState({
      comments: DataSource.getComments()
    });
  }

  render() {
    return (
      <div>
        {this.state.comments.map((comment) => (
          <Comment comment={comment} key={comment.id} />
        ))}
      </div>
    );
  }
}
```

이후에 유사한 패턴을 따르는 단일 블로그 게시물을 구독하기 위한 컴포넌트를 작성한다.

```jsx
class BlogPost extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.state = {
      blogPost: DataSource.getBlogPost(props.id)
    };
  }

  componentDidMount() {
    DataSource.addChangeListener(this.handleChange);
  }

  componentWillUnmount() {
    DataSource.removeChangeListener(this.handleChange);
  }

  handleChange() {
    this.setState({
      blogPost: DataSource.getBlogPost(this.props.id)
    });
  }

  render() {
    return <TextBlock text={this.state.blogPost} />;
  }
}
```

`CommentList`와 `BlogPost`는 동일하지 않다. `DataSource`의 다른 메서드를 호출하고 렌더링하는 것이 다르다. 그러나 구현의 대부분은 동일하다.

- 마운트 시 `DataSource`에 변경 리스너를 추가한다.
- 리스너 내부에서 데이터 소스가 변경될 때마다 `setState`를 호출한다.
- 마운트 해제 시 변경 리스너를 제거한다.

대형 앱에서 `DataSource`를 구독하고 `setState`를 호출하는 동일한 패턴이 계속 반복된다고 상상할 수 있다. 우리는 이 로직을 한 곳에서 정의하고 여러 컴포넌트에서 공유할 수 있는 추상화를 원한다. 바로 여기에 고차 컴포넌트를 사용할 수 있다.

`DataSource`를 구독하는 `CommentList`와 `BlogPost` 같은 컴포넌트를 생성하는 함수를 만들 수 있다. 이 함수는 구독 데이터를 프랍으로 받는 자식 컴포넌트를 인수로 받는다. `withSubscription` 함수를 호출해 보겠다.

```jsx
const CommentListWithSubscription = withSubscription(
  CommentList,
  (DataSource) => DataSource.getComments()
);

const BlogPostWithSubscription = withSubscription(
  BlogPost,
  (DataSource, props) => DataSource.getBlogPost(props.id)
);
```

첫 번째 매개변수는 래핑될 컴포넌트이다. 두 번째 매개변수는 주어진 `DataSource`와 현재 프랍에서 원하는 데이터를 검색한다.

`CommentListWithSubscription`과 `BlogPostWithSubscription`이 렌더링되면 `DataSource`에서 검색된 최신 데이터가 포함된 `data` 프랍이 `CommentList`와 `BlogPost`에 전달된다.

```jsx
// 이 함수는 컴포넌트를 받는다.
function withSubscription(WrappedComponent, selectData) {
  // 다른 컴포넌트를 반환한다.
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.handleChange = this.handleChange.bind(this);
      this.state = {
        data: selectData(DataSource, props)
      };
    }

    componentDidMount() {
      // 구독을 담당한다.
      DataSource.addChangeListener(this.handleChange);
    }

    componentWillUnmount() {
      DataSource.removeChangeListener(this.handleChange);
    }

    handleChange() {
      this.setState({
        data: selectData(DataSource, this.props)
      });
    }

    render() {
      // 최신 데이터가 포함된 래핑된 컴포넌트를 렌더링한다.
      // 추가 props를 건네주는 것을 주목해야 한다.
      return <WrappedComponent data={this.state.data} {...this.props} />;
    }
  };
}
```

HOC는 입력 컴포넌트를 수정하지 않으며 동작을 복사하기 위해 상속을 사용하지도 않는다. 오히려 HOC는 원래 컴포넌트를 컨테이너 컴포넌트에 **래핑**하여 구성한다. HOC는 부작용이 없는 순수 함수이다.

래핑된 컴포넌트는 렌더링에 사용하는 새 `data` 프랍과 함께 컨테이너의 모든 프랍을 받는다. HOC는 데이터가 사용되는 방법이나 이유에 관심이 없으며 래핑된 컴포넌트는 데이터의 출처에 관심이 없다.

`withSubscription`는 일반적인 함수이므로 원하는 만큼 인수를 추가할 수 있다. 예를 들어 래핑된 컴포넌트에서 HOC를 추가로 분리하기 위해 `data` 프랍의 이름을 설정 가능하게 만들 수 있다. 또는 `shouldComponentUpdate`를 설정하는 인수나 데이터 소스를 설정하는 인수를 받을 수 있다. HOC가 컴포넌트가 정의되는 방식을 완전히 제어하기 때문에 이 모든 것이 가능하다.

컴포넌트와 마찬가지로 `withSubscription`와 래핑된 컴포넌트 간의 계약은 전적으로 프랍에 기반한다. 이렇게 하면 래핑된 컴포넌트에 동일한 프랍을 제공하는 한 HOC를 쉽게 교체할 수 있다. 예를 들어 데이터 가져오기 라이브러리를 변경할 때 유용할 수 있다.

## 원본 컴포넌트를 변경하지 말고 합성을 사용한다

HOC 내에서 컴포넌트의 프로토타입을 수정(또는 변경)하려는 유혹에 저항해야 한다.

```jsx
function logProps(InputComponent) {
  InputComponent.prototype.componentDidUpdate = function(prevProps) {
    console.log('Current props: ', this.props);
    console.log('Previous props: ', prevProps);
  };
  // 원래의 입력값을 반환한다는 것은 그것이 변경되었다는 암시이다.
  return InputComponent;
}

// EnhancedComponent는 프랍을 받을 때마다 로그를 출력할 것이다.
const EnhancedComponent = logProps(InputComponent);
```

여기에는 몇 가지 문제가 있다. 하나는 입력 컴포넌트를 향상된 컴포넌트와 별도로 재사용할 수 없다는 것이다. 더 중요한 것은 `EnhancedComponent`에 `componentDidUpdate`를 **변경**하는 다른 HOC를 적용하면 첫 번째 HOC의 기능이 무시된다는 것이다. 이 HOC는 수명 주기 메서드가 없는 함수 컴포넌트에서도 작동하지 않는다.

원본을 변경하는 HOC는 구멍이 난 추상화이다. 사용자는 다른 HOC와의 충돌을 피하기 위해 구현 방식을 알아야 한다.

HOC는 인자로 받은 컴포넌트를 컨테이너 컴포넌트에 래핑하는 합성을 사용해야 한다.

```jsx
function logProps(WrappedComponent) {
  return class extends React.Component {
    componentDidUpdate(prevProps) {
      console.log('Current props: ', this.props);
      console.log('Previous props: ', prevProps);
    }
    render() {
      // 인자로 받은 컴포넌트를 변경하지 않고 컨테이너에 래핑한다.
      return <WrappedComponent {...this.props} />;
    }
  }
}
```

이 HOC는 원본을 변경하는 버전과 동일한 기능을 가지며 충돌 가능성을 피한다. 클래스 및 함수 컴포넌트에 동일하게 잘 작동한다. 그리고 순수 함수이기 때문에 다른 HOC나 자기 자신과 함께 구성이 가능하다.

HOC와 컨테이너 컴포넌트라는 패턴 사이의 유사점을 발견했을 수 있다. 컨테이너 컴포넌트는 상위 수준 문제와 하위 수준 문제 간에 책임을 분리하는 전략의 일부이다. 컨테이너는 구독이나 상태 같은 것들을 관리하고, UI 렌더링과 같은 것들을 처리하는 컴포넌트에 프랍을 전달한다. HOC는 구현의 일부로 컨테이너를 사용한다. HOC는 컨테이너 컴포넌트 정의가 매개변수화된 것으로 생각할 수 있다.

