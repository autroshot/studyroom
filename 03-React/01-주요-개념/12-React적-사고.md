# React적 사고

React는 JavaScript로 크고 빠른 웹 앱을 만드는 최고의 방법이다. React는 Facebook과 Instagram을 통해 확장성을 입증했다.

React의 멋진 점 중 하나는 앱을 설계하는 방식이다. 이 문서에서는 React를 이용해 상품을 검색할 수 있는 데이터 테이블을 만드는 과정을 살펴볼 것이다.

## 프로토타입으로 시작하기

JSON API와 프로토타입을 디자이너로부터 받았다고 가정해 보겠다.

프로토타입은 다음과 같다.

![thinking-in-react-mock](https://user-images.githubusercontent.com/95019875/172376893-9ff71966-9b17-468c-9fad-2a304ff8d800.png)

JSON API는 다음과 같은 데이터를 반환한다.

```
[
  {category: "Sporting Goods", price: "$49.99", stocked: true, name: "Football"},
  {category: "Sporting Goods", price: "$9.99", stocked: true, name: "Baseball"},
  {category: "Sporting Goods", price: "$29.99", stocked: false, name: "Basketball"},
  {category: "Electronics", price: "$99.99", stocked: true, name: "iPod Touch"},
  {category: "Electronics", price: "$399.99", stocked: false, name: "iPhone 5"},
  {category: "Electronics", price: "$199.99", stocked: true, name: "Nexus 7"}
];
```

## 1단계: UI를 컴포넌트 계층 구조로 나누기

가장 먼저 할 일은 프로토타입의 모든 컴포넌트(와 하위 컴포넌트)를 박스로 감싸고 이름을 붙이는 것이다. 디자이너와 함께 일하고 있다면, 디자이너가 이미 이 작업을 했을 수 있으므로 가서 이야기해 볼 필요가 있다. Photoshop의 레이어 이름이 React 컴포넌트의 이름이 될 수 있다.

하지만 어떤 것이 컴포넌트가 되어야 하는지 어떻게 알 수 있을까? 새로운 함수나 객체를 만들 때 썼던 방식을 따라하면 된다. 한 가지 방법은  [단일 책임 원칙](https://ko.wikipedia.org/wiki/%EB%8B%A8%EC%9D%BC_%EC%B1%85%EC%9E%84_%EC%9B%90%EC%B9%99)이다. 이는 하나의 컴포넌트는 하나의 일을 한다는 원칙이다. 하나의 컴포넌트가 너무 커지면 작은 하위 컴포넌트들로 분해해야 한다.

JSON 데이터 모델을 사용자에게 보여주는 경우가 많다. 따라서 모델이 올바르게 만들어졌다면, UI( 및 컴포넌트 구조)가 잘 매핑될 것이다. 이는 UI와 데이터 모델이 동일한 정보 구조(information architecture)를 가지는 경향이 있기 때문이다. UI를 컴포넌트로 쪼개서 각 컴포넌트가 데이터 모델의 한 부분과 일치하게 만든다.

![thinking-in-react-components](https://user-images.githubusercontent.com/95019875/172376916-34a00206-c370-4371-a30c-d52020d4dab4.png)

앱을 다섯 개의 컴포넌트로 나눠 보았다. 각 컴포넌트가 나타내는 데이터는 이탤릭체로 표시했다. 이미지의 숫자는 아래 숫자에 해당된다.

1.  **`FilterableProductTable`(노란색)**: 예시 전체를 담는다.
2.  **`SearchBar`(파란색)**: 모든 **사용자 입력**을 받는다.
3.  **`ProductTable`(연두색)**:  _사용자 입력_을 기반으로  **데이터 컬렉션**을 필터링해서 표시한다.
4.  **`ProductCategoryRow`(하늘색)**: 각  **카테고리**의 제목을 표시한다.
5.  **`ProductRow`(빨강색)**: 각 **제품의** 행을 표시한다.

`ProductTable`을 보면 테이블 헤더(`Name`과 `Price` 레이블)만의 컴포넌트는 없는 것을 알 수 있다. 이것은 선택의 문제로 두 선택 모두 논쟁의 여지가 있다. 이 예시에서는 헤더를 `ProductTable`의 일부로 남겨뒀다. 헤더가 `ProductTable`이 책임지는 데이터 컬렉션의 일부이기 때문이다. 그러나 헤더가 복잡해지면(정렬 기능 추가라든지) 헤더만의 `ProductTableHeader` 컴포넌트를 만드는 것이 합리적일 것이다.

이제 프로토타입에서 컴포넌트를 식별했으므로 이를 계층 구조로 나열해 보겠다. 프로토타입에서 다른 컴포넌트 안에 있는 컴포넌트는 계층 구조에서 자식이 된다.

-   `FilterableProductTable`
    -   `SearchBar`
    -   `ProductTable`
        -   `ProductCategoryRow`
        -   `ProductRow`

## 2단계: React로 정적 버전 만들기

[CodePen](https://codepen.io/gaearon/pen/BwWzwm)에서 코드를 확인할 수 있다.

컴포넌트 계층 구조가 완성되었으므로 이제 앱을 구현할 시간이다. 가장 쉬운 방법은 데이터 모델을 사용하고 UI를 렌더링하지만 상호 작용이 없는 버전을 만들어 보는 것이다. 

정적 버전을 만드는 것은 많은 타이핑이 필요하지만 생각할 것이 적고, 상호 작용을 넣는 것은 많은 생각이 필요하지만 타이핑할 것이 적다. 따라서 두 작업은 분리하는 것이 좋다.

데이터 모델을 렌더링하는 앱의 정적 버전을 만들기 위해, 다른 컴포넌트를 재사용하는 컴포넌트를 만들고 props를 이용해 데이터를 건네준다. props는 부모가 자식에게 데이터를 넘겨줄 때 사용한다. 정적 버전을 만들 때는 **상태를 전혀 사용하지 말아야 한다.** 상태는 오직 상호 작용을 위한, 시간에 따라 변하는 데이터를 위한 것이다.

앱을 만들 때 하향식(top-down)이나 상향식(bottom-up)으로 만들 수 있다. 다시 말해 계층 구조의 상단에 있는 컴포넌트(`FilterableProductTable`)부터 만들거나 하단에 있는 컴포넌트(`ProductRow`)부터 만들 수 있다. 간단한 예시에서는 보통 하향식으로 만드는 게 쉽지만, 큰 프로젝트에서는 상향식으로 만들고 테스트를 작성하며 개발하는 것이 더 쉽다.

이 단계가 끝나면 데이터 모델을 렌더링하며 재사용이 가능한 컴포넌트들의 라이브러리를 얻게 된다. 지금은 앱의 정적 버전이므로 컴포넌트는  `render()`  메서드만 가지고 있다. 계층 구조의 최상단 컴포넌트(`FilterableProductTable`)는 prop으로 데이터 모델을 받는다. 근원이 되는 데이터 모델에 변화를 주면  `root.render()`가 다시 호출되고 UI가 업데이트된다. UI가 어떻게 업데이트되고 어디에서 변화를 줘야 하는지를 쉽게 파악할 수 있다. React의 <strong>단방향 데이터 흐름(one-way data flow)</strong>(또는 단방향 바인딩)은 모든 것을 모듈화하고 빠르게 만든다.

## 3단계: UI 상태에 대한 최소한의, 하지만 완전한 표현 찾기

UI에 상호 작용을 넣으려면 근원이 되는 데이터 모델에 변화를 줄 수 있어야 한다. React는 <strong>상태(state)</strong>로 이것을 가능하게 한다.

앱을 올바르게 만들기 위해서는 앱에 필요한 상태의 최소 집합을 찾아야 한다. 여기서 핵심은 [중복 배제](https://ko.wikipedia.org/wiki/%EC%A4%91%EB%B3%B5%EB%B0%B0%EC%A0%9C) 원칙이다. 앱에 필요한 상태의 최소 표현을 파악하고 나머지는 필요에 따라 계산되게 만든다.

예를 들어 TODO 리스트를 만든다고 하면, TODO 항목의 배열만 두고 항목의 개수를 위한 별도의 변수는 만들지 않는다. 개수는 배열의 길이로 구할 수 있다.

예시의 앱에 있는 모든 데이터 조각은 다음과 같다.

-   제품의 원본 리스트
-   사용자가 입력한 검색어
-   체크박스의 값
-   필터링된 제품 리스트

하나씩 살펴보며 어떤 것이 상태인지 파악해 보겠다. 다음 세 가지 중 하나라도 해당되면 상태가 아닐 확률이 높다.

1. props을 통해 부모로부터 받는다.
2. 시간에 따라 변하지 않는다.
3. 컴포넌트의 다른 상태나 props로 계산이 가능하다.

제품의 원본 리스트는 props를 통해 전달되므로 상태가 아니다. 검색어와 체크박스는 시간에 따라 변하고 다른 것들로부터 계산할 수 없으므로 상태로 볼 수 있다. 마지막으로 필터링된 리스트는 상태가 아니다. 제품의 원본 리스트, 검색어, 체크박스의 값을 조합해서 계산할 수 있기 때문이다.

최종적으로 남은 상태는 다음과 같다.

-   사용자가 입력한 검색어
-   체크박스의 값

## 4단계: 상태가 있어야 할 곳을 알아내기

[CodePen](https://codepen.io/gaearon/pen/qPrNQZ)에서 코드를 확인할 수 있다.

이제 앱에 필요한 상태의 최소 집합을 찾아냈다. 다음으로 어떤 컴포넌트가 이 상태를 변경하거나 소유할지를 알아내야 한다.

React는 항상 컴포넌트 계층 구조를 따라 내려가는 단방향 데이터 흐름을 따른다. 어떤 컴포넌트가 어떤 상태를 소유해야 하는지 바로 파악하기 어려울 수 있다. 많은 입문자가 이 부분을 가장 어려워하는데, 다음 단계를 따라가면 알아낼 수 있다.

앱의 각 상태에 대해 다음을 수행한다.

- 상태를 기반으로 뭔가를 렌더링하는 모든 컴포넌트를 찾는다.
- 해당 컴포넌트들의 공통되는 부모 컴포넌트를 찾는다.
- 상태를 소유할 만한 부모 컴포넌트가 없다면 새 컴포넌트를 하나 만들어서 부모로 추가한다.

이 전략을 예시의 앱에 적용해 보겠다.

- `ProductTable`은 상태에 기반해 상품 리스트를 필터링해야 하고  `SearchBar`는 검색어와 체크박스의 상태를 표시해야 한다.
- 공통된 부모 컴포넌트는 `FilterableProductTable`이다.
- 개념적으로도 `FilterableProductTable`이 검색어와 체크박스의 값을 가지는 것이 타당하다.

상태를 `FilterableProductTable`에 두기로 했다.  먼저 인스턴스 프로퍼티인  `this.state = { filterText: '', inStockOnly: false }`를  `FilterableProductTable`의  `constructor`에 추가하여 앱의 초기 상태를 반영한다. 그리고 나서  `filterText`와  `inStockOnly`를  `ProductTable`와  `SearchBar`에 prop으로 전달한다. 마지막으로 이 props를 이용해  `ProductTable`의 행을 필터링하고  `SearchBar`의 폼 필드의 값을 지정한다.

## 5단계: 역방향 데이터 흐름 추가하기

[CodePen](https://codepen.io/gaearon/pen/LzWZvb)에서 코드를 확인할 수 있다.

지금까지는 계층 구조를 따라 아래로 흐르는 props와 상태에 의해 올바르게 렌더링되는 앱을 만들었다. 이제 다른 방향으로 흐르는 데이터를 지원할 시간이다. 계층 구조의 깊은 곳에 있는 폼 컴포넌트가 `FilterableProductTable`의 상태를 업데이트해야 한다.

React는 전통적인 양방향 데이터 바인딩에 비해 약간 더 많은 타이핑을 필요로 한다. 하지만 React는 역방향 데이터 흐름을 명시적으로 만들어 프로그램이 어떻게 동작하는지 쉽게 파악할 수 있다.

4단계의 예시에서 타이핑하거나 박스를 체크하면 입력이 무시되는 것을 볼 수 있다. input의 `value` prop가 `FilterableProductTable`에서 건네받은 상태와 항상 같도록 설정했기 때문이다.

우리가 원하는 것은 사용자가 폼을 변경할 때마다 사용자의 입력을 반영하도록 상태를 업데이트하는 것이다. 컴포넌트는 자신의 상태만 업데이트해야 한다. 따라서 `FilterableProductTable`는  `SearchBar`에게 상태 업데이트가 필요할 때마다 호출될 콜백을 건네준다. input의 `onChange` 이벤트가 이 때를 알려준다. `FilterableProductTable`로부터 건네받은 콜백은 `setState()`를 호출할 것이고, 앱은 업데이트될 것이다.

## 마무리

이 글을 통해 React로 컴포넌트와 애플리케이션를 만드는 방법에 대한 아이디어를 얻었을 것이다. 이전보다 더 많은 타이핑을 해야 할 수도 있지만, 코드는 작성하는 것보다 읽을 일이 훨씬 많다는 것을 기억해야 한다. 모듈화되고 명시적인 코드는 읽기가 쉽다. 거대한 컴포넌트 라이브러리를 만들기 시작하면 이 명시성과 모듈성의 힘을 느끼게 될 것이다. 또한 코드를 재사용하면 코드의 양이 줄어들기 시작할 것이다.
