# 사이프러스 소개

## 요소 쿼리하기

### 사이프러스는 jQuery와 같다

이전에 jQuery를 사용한 적이 있다면 다음과 같은 요소 쿼리가 익숙할 것이다.

```js
$('.my-selector')
```

사이프러스에서의 요소 쿼리가 동일하다.

```js
cy.get('.my-selector')
```

사이프러스는 jQuery를 기본으로 제공하고 많은 DOM 탐색 방법을 지원하므로 이미 익숙한 API를 사용하여 복잡한 HTML 구조에서 쉽게 작업할 수 있다.

```js
cy.get('#main-content').find('.article').children('img[src^="/static"]').first()
```

> **핵심 개념**
>
> 사이프러스는 jQuery의 강력한 selector 엔진을 활용하여 최신 웹 개발자에게 친숙하고 읽기 쉬운 테스트를 제공한다.
>
> 요소 선택에 대한 모범 사례는 [이곳](https://docs.cypress.io/guides/references/best-practices#Selecting-Elements)에서 확인할 수 있다.

### 사이프러스는 jQuery와 다르다

jQuery에서는 일치하는 DOM 요소를 찾지 못하면 빈 jQuery 컬렉션을 반환한다.

반면 사이프러스에서는 다음 중 하나가 될 때까지 쿼리를 자동으로 재시도한다.

#### 1. 요소가 발견됨

```js
cy
  // cy.get()는 '#element'을 찾는 쿼리를 반복한다...
  .get('#element')

  // ...일치하는 요소를 찾을 때까지!
  // 이제 .then을 이용해서 요소를 다룰 수 있다.
  .then(($myElement) => {
    doSomething($myElement)
  })
```

#### 2. 설정된 타임아웃에 도달함

```js
cy
  // cy.get()는 '#element-does-not-exist'을 찾는 쿼리를 반복한다...
  // ...타임아웃 전에 요소를 찾지 못한다.
  // 사이프러스는 중지되고 테스트에 실패한다.
  .get('#element-does-not-exist')

  // ...이 코드는 실행되지 않는다...
  .then(($myElement) => {
    doSomething($myElement)
  })
```

이런 방식은 사이프러스를 견고하게 만들고 다른 테스트 도구에서 발생하는 일반적인 문제에 내성을 갖게 한다.

- DOM이 아직 로드되지 않음
- 프레임워크의 부트스트랩이 아직 완료되지 않음
- XHR 요청에 대한 응답이 아직 오지 않음
- 애니메이션이 아직 완료되지 않음

사이프러스는 내장 재시도 및 [사용자 지정이 가능한 타임아웃](https://docs.cypress.io/guides/references/configuration#Timeouts) 기능을 통해 이런 문제들을 피할 수 있다.

> **핵심 개념**
>
> 사이프러스는 실제 웹 앱의 작동 방식에 잘 맞는 강력한 재시도 및 타임아웃 로직으로 모든 DOM 쿼리를 래핑한다. 모든 테스트에 대한 안정성을 높이는 대신 DOM 요소를 찾는 방법이 약간 다르다.

> **참고**
>
> 사이프러스에서 DOM 요소와 직접 상호 작용하려면, 요소를 첫 번째 인수로 받는 콜백 함수로 [`.then()`](https://docs.cypress.io/api/commands/then)을 호출한다. 재시도 및 타임아웃 기능을 완전히 건너뛰고 기존의 동기식 작업을 수행하려면 [`Cypress.$`](https://docs.cypress.io/api/utilities/$)을 사용한다.

### 텍스트 콘텐츠로 쿼리하기

더 인간적인 방법으로 요소를 찾는 또 다른 방법은 콘텐츠로, 사용자가 페이지에서 볼 수 있는 것으로 찾는 것이다. 이를 위한 편리한 [`cy.contains()`](https://docs.cypress.io/api/commands/contains) 명령어가 있다. 

예시:

```js
// 'New Post' 텍스트가 포함된 요소를 문서에서 찾는다.
cy.contains('New Post')

// 'New Post' 텍스트가 포함된 요소를 '.main' 내부에서 찾는다.
cy.get('.main').contains('New Post')
```

이는 앱과 상호 작용하는 사용자의 관점에서 테스트를 작성할 때 유용하다.

사용자는 그저 "제출"이라고 표시된 버튼을 클릭하고 싶을 것이다. 사용자는 `submit`라는 `type` 속성이나 `my-submit-button`라는 CSS 클래스를 전혀 모르기 때문이다.

### 요소가 없는 경우

사이프러스는 웹 앱의 비동기적 특성을 예상하고 요소를 처음 발견하지 못하는 즉시 실패하지 않는다. 대신 Cypress는 앱이 수행하는 모든 작업을 완료할 수 있는 시간을 제공한다.

이를 `timeout`이라고 하며 대부분의 명령어는 타임아웃([기본값은 4초](https://docs.cypress.io/guides/references/configuration#Timeouts)) 시간을 별도로 지정할 수 있다.

```js
// 해당 요소가 나타날 때까지 10초를 준다.
cy.get('.my-slow-selector', { timeout: 10000 })
```

[환경 설정: `defaultCommandTimeout`](https://docs.cypress.io/guides/references/configuration#Timeouts)을 통해 타임아웃 시간을 전역으로 설정할 수 있다. 

> **핵심 개념**
>
> 웹 앱의 작동 방식과 동일하게 Cypress는 비동기식이며 앱이 예상한 상태로 전환될 때까지 기다리기 위해 타임아웃을 사용한다. 
>
> 타임아웃 시간은 전역으로 설정하거나 명령어별로 설정할 수 있다.

## 명령어 체인

Cypress가 명령어 체인을 사용하는 메커니즘을 이해할 필요가 있다. 사이프러스는 사용자를 대신하여 프라미스 체인을 관리한다. 체인이 종료되거나 오류가 발생할 때까지 각 명령어가 다음 명령어에 대한 'subject'를 생성(yield)한다.

### 요소와 상호 작용하기

Cypress에서 [`cy.get()`](https://docs.cypress.io/api/commands/get) 또는 [`cy.contains()`](https://docs.cypress.io/api/commands/contains) 명령어와 [`.click()`](https://docs.cypress.io/api/commands/click) 또는 [`.type()`](https://docs.cypress.io/api/commands/type) 명령어를 사용해 페이지의 요소를 클릭하거나 입력할 수 있다. 이는 연쇄의 좋은 예이다.

```js
cy.get('textarea.post-body').type('This is an excellent post.')
```

다음은 사이프러스에서 제공하는 앱과의 상호 작용을 위한 동작 명령어들이다.

- [`.blur()`](https://docs.cypress.io/api/commands/blur) - 포커스된 DOM 요소가 포커스를 잃게 만든다.
- [`.focus()`](https://docs.cypress.io/api/commands/focus) - DOM 요소가 포커스를 얻는다.
- [`.clear()`](https://docs.cypress.io/api/commands/clear) - input이나 textarea의 값을 지운다.
- [`.check()`](https://docs.cypress.io/api/commands/check) - 체크박스나 라디오를 체크한다.
- [`.uncheck()`](https://docs.cypress.io/api/commands/uncheck) - 체크박스의 체크를 해제한다.
- [`.select()`](https://docs.cypress.io/api/commands/select) - `<select>`의 `<option>`을 선택한다.
- [`.dblclick()`](https://docs.cypress.io/api/commands/dblclick) - DOM 요소를 더블클릭한다.
- [`.rightclick()`](https://docs.cypress.io/api/commands/rightclick) - DOM 요소를 오른쪽 클릭한다.

이런 명령어들은 동작을 수행하기 전에 요소의 상태를 몇 가지 확인한다.

예를 들어 [.click()](https://docs.cypress.io/api/commands/click) 명령어에서 Cypress는 (실제 사용자가 하는 것처럼) 요소가 상호 작용할 수 있는지 확인한다. 다음과 같이 요소가 '동작 가능' 상태에 도달할 때까지 자동으로 기다린다.

- hidden이 아님
- 상위 요소에게 덮여 있지 않음
- disabled가 아님
- 애니메이션 중이 아님

또한 테스트에서 앱과 상호 작용할 때 플레이크(flake)를 방지하는 데 도움이 된다. 일반적으로 `force`옵션을 사용하여 이 동작을 재정의할 수 있다.

> **핵심 개념**
>
> Cypress는 [요소와 상호 작용할](https://docs.cypress.io/guides/core-concepts/interacting-with-elements) 때 간단하지만 강력한 알고리즘을 제공한다 .

### 요소에 대한 어설션

어설션(assertion)을 사용하면 요소가 표시 여부, 특정 속성이나 CSS 클래스, 특정 상태에 있는지를 확인하는 작업을 수행할 수 있다. 어설션은 앱이 어떤 상태에 있기를 원하는지를 설명하는 명령어이다.

Cypress는 요소가 해당 상태에 도달할 때까지 자동으로 기다리다가 어설션이 통과하지 못하면 테스트에 실패한다.

예시:

```js
cy.get(':checkbox').should('be.disabled')

cy.get('form').should('have.class', 'form-horizontal')

cy.get('input').should('not.have.value', 'US')
```

Cypress는 각 어설션이 통과할 때까지 자동으로 대기한다는 점을 유의해야 한다. 요소가 원하는 상태에 도달하는 정확한 순간을 알 필요가 없어진다.

### subject 관리

새로운 사이프러스 체인은 항상 `cy.[command]`로 시작한다. `command`에 의해 이후에 체인으로 올 수 있는 명령어가 결정된다.

[`cy.clearCookies()`](https://docs.cypress.io/api/commands/clearcookies)와 같은 메서드는 `null`을 생성하므로 체이닝이 불가능하다.

[`cy.get()`](https://docs.cypress.io/api/commands/get)나 [`cy.contains()`](https://docs.cypress.io/api/commands/contains) 같은 메서드는 DOM 요소를 생성하므로 [`.click()`](https://docs.cypress.io/api/commands/click)나 [`cy.contains()`](https://docs.cypress.io/api/commands/contains)을 체인으로 연결할 수 있다.

#### 일부 명령어는 다음 뒤에서만 체인이 가능하다...

- `cy`만 가능. subject 뒤에 올 수 없음 - [`cy.clearCookies()`](https://docs.cypress.io/api/commands/clearcookies)

- DOM 요소와 같은 특정 종류의 subject를 생성하는 명령어 - [`.type()`](https://docs.cypress.io/api/commands/type)

- `cy`와 subject를 생성하는 명령어 모두 가능 - [`cy.contains()`](https://docs.cypress.io/api/commands/contains)

#### 일부 명령어가 생성하는 것은...

- `null`, 이 커맨드 뒤에서는 체이닝이 불가능함 - [`cy.clearCookie()`](https://docs.cypress.io/api/commands/clearcookie)

- 이전 subject와 동일한 subject - [`.click()`](https://docs.cypress.io/api/commands/click)

- 명령어에 적합한 새로운 subject - [`.wait()`](https://docs.cypress.io/api/commands/wait)

예시:

```js
cy.clearCookies() // 'null'이 생성되어 체이닝이 불가능하다.

cy.get('.main-container') // 일치하는 DOM 요소의 배열을 생성한다.
  .contains('Headlines') // 해당 콘텐츠를 가진 첫 번째 DOM 요소를 생성한다.
  .click() // 이전 명령어와 동일한 DOM 요소를 생성한다.
```

> **핵심 개념**
>
> Cypress 명령어는 subject를 **반환하지 않고 생성한다.** Cypress 명령어는 비동기식이며 나중에 실행할 수 있도록 대기열에 추가된다. 테스트에서 subject는 하나의 명령어에서 다음 명령어로 넘어가며, 모든 것이 순서대로 작동하는지 확인하기 위해 각 명령어 사이에서 많은 Cypress 코드가 실행된다.

> 요소를 참조하고 싶을 때는 [별칭](https://docs.cypress.io/guides/core-concepts/variables-and-aliases)이라는 기능을 이용할 수 있다. 별칭은 요소 참조를 저장해 나중에 사용할 수 있다.

#### [`.then()`](https://docs.cypress.io/api/commands/then)을 사용해 subject 다루기

subject를 직접 다루고 싶다면 명령어 체인에 [.then()](https://docs.cypress.io/api/commands/then)을 추가하면 된다. 이전 명령어가 이행되면, 생성된 subject를 첫 번째 인수로 갖는 콜백 함수가 호출된다.

[.then()](https://docs.cypress.io/api/commands/then) 이후에 명령어 체이닝을 지속하고 싶다면, 해당 명령어에서 생성하고 싶은 subject을 명시해야 한다. `null`이나 `undefined` 이외의 값을 반환해야 한다.

예시:

```js
cy
  // id가 'some-link'인 요소를 찾는다.
  .get('#some-link')

  .then(($myElement) => {
    // ...subject를 다루는 코드...

    // href 프로퍼티를 얻는다.
    const href = $myElement.prop('href')

    // '#'와 그 이후의 글자를 모두 삭제한다.
    return href.replace(/(#.*)/, '')
  })
  .then((href) => {
    // href는 이제 새로운 subject이며 원하는 작업을 수행할 수 있다.
  })
```

#### 별칭을 사용해 이전 subject 참조하기

사이프러스에는 과거의 subject를 빠르게 참조할 수 있는 [별칭](https://docs.cypress.io/guides/core-concepts/variables-and-aliases)이라는 기능이 있다.

예시:

```js
cy.get('.my-selector')
  .as('myElement') // 별칭을 설정한다.
  .click()

/* 많은 작업 */

cy.get('@myElement') // 이전과 동일한 DOM을 쿼리한다.
  .click()
```

요소가 아직 DOM에 있을 때 이 기능을 사용하면 DOM 쿼리를 재사용해서 테스트가 더 빨라진다. DOM에서 일치하는 요소를 바로 찾을 수 없을 때는 쿼리를 자동으로 재시도한다.

이 기능은 재렌더링을 많이 하는 프론트엔드 프레임워크를 다룰 때 특히 유용하다.

### 명령어는 비동기적이다

Cypress 명령어는 호출되는 순간에는 아무 일도 하지 않고 나중에 실행되도록 대기열에 추가한다.

```js
it('hides the thing when it is clicked', () => {
  cy.visit('/my/resource/path') // 아직 아무 일도 일어나지 않는다.

  cy.get('.hides-when-clicked') // 아직 아무 일도 일어나지 않는다.
    .should('be.visible') // 아직 아무 일도 일어나지 않는다.
    .click() // 아직 아무 일도 일어나지 않는다.
    .should('not.be.visible') // 아직 아무 일도 일어나지 않는다.
})

// 테스트 함수가 실행을 마쳤다...
// 모든 명령어가 대기열에 들어갔고 이제 사이프러스는
// 순서대로 명령어를 실행하기 시작한다!
```

#### 비동기 코드와 동기 코드 같이 사용하기

동기 코드는 자신의 위에 있는 Cypress 명령어가 실행될 때까지 기다리지 않고 즉시 실행된다.

:heavy_multiplication_x: **잘못된 사용법**

다음 예시에서는 `cy.visit()`이 실행되기 전에 `el`이 즉시 평가되므로 항상 빈 배열로 평가된다.

```js
it('does not work as we expect', () => {
  cy.visit('/my/resource/path') // 아직 아무 일도 일어나지 않는다.

  cy.get('.awesome-selector') // 아직 아무 일도 일어나지 않는다.
    .click() // 아직 아무 일도 일어나지 않는다.

  // Cypress.$는 동기적이므로 즉시 평가된다.
  let el = Cypress.$('.new-el') // evaluates immediately as []

  if (el.length) {
    // 즉시 0으로 평가된다.
    cy.get('.another-selector')
  } else {
    // 코드가 실행될 때는 'el.length'가 0이므로
    // 이 코드가 항상 실행된다.
    cy.get('.optional-selector')
  }
})
```

:heavy_check_mark: **올바른 사용법**

```js
it('does not work as we expect', () => {
  cy.visit('/my/resource/path') // 아직 아무 일도 일어나지 않는다.

  cy.get('.awesome-selector') // 아직 아무 일도 일어나지 않는다.
    .click() // 아직 아무 일도 일어나지 않는다.
    .then(() => {
      // .then() 내부에 코드를 배치하는 것은
      // 해당 코드가 사이프러스의 '실행' 명령어 이후에
      // 실행되다는 것을 의미한다.
      let el = Cypress.$('.new-el') // .then() 이후에 평가된다.

      if (el.length) {
        cy.get('.another-selector')
      } else {
        cy.get('.optional-selector')
      }
    })
})
```

:heavy_multiplication_x: **잘못된 사용법**

다음 예시에서는 `cy.visit()`이 실행되기 전에 `username` 값이 즉시 평가되므로 항상 `undefined`로 평가된다.

```js
it('test', () => {
  let username = undefined // 즉시 undefined로 평가된다.

  cy.visit('https://app.com') // 아직 아무 일도 일어나지 않는다.
  cy.get('.user-name') // 아직 아무 일도 일어나지 않는다.
    .then(($el) => {
      // 아직 아무 일도 일어나지 않는다.
      // 이 코드는 .then()이 실행된 이후에 평가된다.
      username = $el.text()
    })

  // 이 코드는 위의 .then() 이전에 평가된다.
  // 따라서 username은 여전히 undefined이다.
  if (username) {
    // 즉시 undefined로 평가된다.
    cy.contains(username).click()
  } else {
    // username이 항상 undefined로 평가되므로
    // 항상 이 코드가 실행된다.
    cy.contains('My Profile').click()
  }
})
```

:heavy_check_mark: **올바른 사용법**

```js
it('test', () => {
  let username = undefined // 즉시 undefined로 평가된다.

  cy.visit('https://app.com') // 아직 아무 일도 일어나지 않는다.
  cy.get('.user-name') // 아직 아무 일도 일어나지 않는다.
    .then(($el) => {
      // 아직 아무 일도 일어나지 않는다.
      // 이 코드는 .then()이 실행된 이후에 평가된다.
      username = $el.text()

      // 이 코드는 .then()이 실행된 이후에 평가된다.
      // $el.text()에서 얻은 올바른 값이 username에 들어있다.
      if (username) {
        cy.contains(username).click()
      } else {
        cy.get('My Profile').click()
      }
    })
})
```

> **핵심 개념**
>
> 각 사이프러스 명령어는 나중에 실행할 명령 대기열에만 추가되며 즉시 반환된다.
>
> 의도적으로 명령어의 반환값으로 유용한 작업을 수행할 수 없다. 명령어는 대기열에 추가되고 완전히 장막 뒤에서 관리된다.

#### 반복문 피하기

`while`과 같은 자바스크립트 반복문을 사용하면 예기치 않은 결과가 발생할 수 있다. 

앱이 로드 시 임의의 숫자를 표시한다고 가정해 보겠다. 숫자 7을 찾으면 테스트가 중지되기를 원한다. 다른 숫자가 표시되면 테스트에서 페이지를 다시 로드하고 확인한다.

:heavy_multiplication_x: **잘못된 테스트**

다음 테스트는 작동하지 않으며 브라우저가 충돌할 가능성이 높다.

```js
let found7 = false

while (!found7) {
  // 이 코드는 무한히 많은 "cy.get..." 명령어를 예약하며,
  // 결국 그 중 하나가 실행되어서 found7가 true가 되기 전에 충돌을 일으킨다.
  cy.get('#result')
    .should('not.be.empty')
    .invoke('text')
    .then(parseInt)
    .then((number) => {
      if (number === 7) {
        found7 = true
        cy.log('lucky **7**')
      } else {
        cy.reload()
      }
    })
}
```

`while` 반복문은 사이프러스가 첫 번째 `cy.get(...)` 명령어의 실행을 시작하도록 허용하지 않는다.

:heavy_check_mark: **올바른 테스트**

계속해야 하는지 결정하기 전에 몇 가지 명령을 실행할 수 있는 기회를 테스트에 제공해야 한다. 따라서 올바른 테스트는 재귀를 사용한다.

```js
const checkAndReload = () => {
  // 요소의 텍스트를 얻어서 숫자로 변환한다.
  cy.get('#result')
    .should('not.be.empty')
    .invoke('text')
    .then(parseInt)
    .then((number) => {
      // 원하는 숫자가 나오면
      // 명령어를 추가하는 것을 멈춘다.
      if (number === 7) {
        cy.log('lucky **7**')

        return
      }

      // 그렇지 않으면 새로고침 후에 함수를 호출해서
      // 사이프러스 명령어를 추가한다.
      cy.wait(500, { log: false })
      cy.reload()
      checkAndReload()
    })
}

cy.visit('public/index.html')
checkAndReload()
```

### 명령어들은 순차적으로 실행된다

사이프러스는 앱의 상태가 명령어가 예상하는 것과 일치하는지 확인하기 위해 많은 추가 작업을 수행한다. 일부 명령어는 빠르게 이행될 수 있지만, 일부 명령어는 이행되는 데 몇 초 또는 수십 초가 걸릴 수 있다.

> **핵심 개념**
>
> 단계가 성공했는지 확인하는 데 필요한 모든 대기나 재시도는 다음 단계가 시작되기 전에 완료되어야 한다. 타임아웃이 끝나기 전에 성공적으로 완료되지 않으면 테스트가 실패한다.

### Cypress 명령어 대기열

`then()` 문법 때문에 API가 프라미스와 비슷해 보일 수 있지만 사이프러스 명령어는 프라미스가 아니다. 이는 나중에 비동기적으로 실행되도록 중앙 대기열로 전달되는 직렬 명령어이다.

거의 모든 명령어에는 [재시도 기능](https://docs.cypress.io/guides/core-concepts/retry-ability)이 내장되어 있다. 재시도 기능이 없다면 어설션이 무작위로 실패할 것이다.

또한 명령어에는 프라미스 기반 테스트에 익숙한 개발자가 예기치 않게 발견할 수 있는 몇 가지 디자인 선택 사항이 있다.

#### 동시에 여러 명령을 실행하거나 경주시킬 수 없다

많은 사이프러스 명령어는 어떤 방식으로든 브라우저의 상태를 변경한다.

- [`cy.request()`](https://docs.cypress.io/api/commands/request)
- [`cy.clearCookies()`](https://docs.cypress.io/api/commands/clearcookies)
- [`.click()`](https://docs.cypress.io/api/commands/click)

위의 명령어들은 멱등성(idempotent)이 없다. 모두 부작용을 일으킨다.

일관성을 만들기 위해서는 명령어를 제어된 직렬 방식으로 실행해야 하기 때문에 경주 명령은 불가능하다.

#### 실패한 명령어에 대한 에러 핸들러 `.catch`를 추가할 수 없다

Cypress에는 실패한 명령어에 대한 에러 복구 기능이 내장되어 있지 않다. 명령어와 어설션은 모두 통과하거나, 하나가 실패하면 나머지 명령어가 실행되지 않고 테스트가 실패한다.

> 참고
>
> 조건부 테스트를 수행하는 방법은 [이곳](https://docs.cypress.io/guides/core-concepts/conditional-testing)에서 확인할 수 있다.

## 어설션

***어설션은 요소, 객체, 앱의 원하는 상태를 설명한다.***

어설션을 경비원으로 생각할 수 있다. 경비원을 사용해 앱이 어떻게 생겼는지 설명하면 사이프러스가 해당 상태에 도달할 때까지 자동으로 차단, 대기, 재시도를 한다.

### 영어로 어설션하기

어설션을 영어로 설명하는 방법을 살펴보겠다.

> *After clicking on this* `<button>`*, I expect its class to eventually be* `active`*.*

사이프러스에서는 이를 표현하려면 다음과 같이 작성한다.

```js
cy.get('button').click().should('have.class', 'active')
```

위의 테스트는 `.active` 클래스가 버튼에 비동기식으로, 혹은 불확실한 시간이 지난 후에 적용되어도 성공할 것이다.

```javascript
$('button').on('click', (e) => {
  setTimeout(() => {
    $(e.target).addClass('active')
  }, 2000)
})
```

다음은 다른 예시이다.

> *After making an HTTP request to my server, I expect the response body to equal* `{name: 'Jane'}`

이를 어설션으로 표현하면 다음과 같다.

```js
cy.request('/users/1').its('body').should('deep.eq', { name: 'Jane' })
```

### 언제 어설션을 사용할까

Cypress가 제공하는 수많은 어설션에도 불구하고 때로는 테스트에 어설션이 들어가지 않아도 된다.

예시:

```js
cy.visit('/home')

cy.get('.main-menu').contains('New Project').click()

cy.get('.title').type('My Awesome Project')

cy.get('form').submit()
```

단 하나의 명시적 어설션 없이도 이 테스트는 실패할 수 있는 방법이 수십 가지가 된다.

> **핵심 개념**
>
> Cypress를 사용하면 유용한 테스트를 위해 어설션을 사용하지 않아도 된다. 어설션이 없더라도 몇 줄의 Cypress로 수천 줄의 코드가 클라이언트와 서버에서 제대로 작동하는지 확인할 수 있다.
>
> 이는 많은 명령어에 높은 수준의 보증을 제공하는 기본 어설션이 내장되어 있기 때문이다.

### 기본 어설션

많은 명령어에는 기본적으로 내장 어설션이 있거나, 명시적 어설션 없이도 실패할 수 있는 요구 사항이 있다.

