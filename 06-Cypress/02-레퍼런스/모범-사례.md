# 모범 사례

## 테스트 구성, 로그인, 상태 제어

> ❌ **안티 패턴** - 페이지 개체를 공유, UI를 사용하여 로그인하고 지름길을 사용하지 않는다.
>

> :heavy_check_mark: **모범 사례** - 개별적으로 사양을 테스트하고, 프로그래밍 방식으로 앱에 로그인하고, 앱 상태를 제어한다.

[로그인 레시피](https://github.com/cypress-io/cypress-example-recipes#logging-in-recipes)에서 몇 가지 예시를 살펴볼 수 있다.

## 요소 선택하기

> ❌ **안티 패턴** - 변경될 수 있는 불안정한 선택자를 사용한다.

> :heavy_check_mark: **모범 사례** - `data-*` 속성을 사용하여 선택자에 컨텍스트를 제공하고 CSS나 JS의 변경으로부터 독립시킨다.

작성하는 모든 테스트에는 요소에 대한 선택자가 포함된다. 많은 골칫거리를 줄이려면 변화에 탄력적인 선택자를 작성해야 한다.

종종 다음과 같은 이유로 사용자가 요소를 타겟팅하는 데 문제가 발생한다.

- 앱이 변경되는 동적 클래스나 ID를 사용할 수 있다.
- 선택자가 개발 중  CSS 스타일이나 JS 동작의 변경으로 인해 작동하지 않는다.

운 좋게도 이 두 가지 문제를 모두 피할 수 있는 방법이 있다.

1. CSS 속성을 기반으로 요소를 타겟팅하지 않는다. (`id`, `class`, `tag`)
2. `textContent`가 변경될 수 있는 요소를 타겟팅하지 않는다.
3. 요소를 더 쉽게 타겟팅할 수 있도록 `data-*` 속성을 추가한다.

### 작동 원리

다음의 버튼과 상호작용하고 싶다고 가정해 보겠다.

```html
<button
  id="main"
  class="btn btn-large"
  name="submission"
  role="button"
  data-cy="submit"
>
  Submit
</button>
```

타겟팅할 수 있는 방법을 다음과 같다.

| 선택자                                  | 추천                           | 설명                                                         |
| --------------------------------------- | ------------------------------ | ------------------------------------------------------------ |
| `cy.get('button').click()`              | ❌비추천                        | 최악이다. 너무 일반적이고 컨텍스트가 없다.                   |
| `cy.get('.btn.btn-large').click()`      | ❌비추천                        | 나쁘다. 스타일링과 결합했다. 변경될 가능성이 높다.           |
| `cy.get('#main').click()`               | ⚠아주 가끔                     | 더 낫다. 그러나 여전히 스타일링이나 JS 이벤트 리스너와 연결되어 있다. |
| `cy.get('[name="submission"]').click()` | ⚠아주 가끔                     | HTML 시맨틱이 있는 `name` 속성과 연결되었다.                 |
| `cy.contains('Submit').click()`         | :heavy_check_mark: 상황에 따라 | 훨씬 낫다. 그러나 여전히 변경될 수 있는 텍스트 콘텐츠와 연결된다. |
| `cy.get('[data-cy="submit"]').click()`  | :heavy_check_mark: 언제나      | 최고이다. 모든 변경에서 독립된다.                            |

위의 요소를 `tag`, `class`, `id`로 타겟팅하는 것은 매우 불안정하고 변경될 수 있다. 요소를 교체하거나, CSS를 리팩터링하고 ID를 업데이트하거나, 요소의 스타일에 영향을 주는 클래스를 추가/제거할 수 있기 때문이다.

대신 요소에 `data-cy` 속성을 추가하면 테스트에만 사용되는 전용 선택자가 생긴다.

`data-cy` 속성은 CSS 스타일이나 JS 동작 변경의 영향을 받지 않는다. 즉, 요소의 **동작**이나 **스타일**과 연결되지 않는다.

또한 이 요소가 테스트 코드에서 직접 사용된다는 것을 모든 사람에게 분명히 할 수 있다.

### 텍스트 콘텐츠

위의 규칙을 읽고 나면 다음과 같은 궁금증이 생길 수 있다.

항상 데이터 속성을 사용해야 한다면 `cy.contains()`는 언제 사용할까?

경험에 따르면 다음의 질문에 답해보는 것이다.

요소의 내용이 **변경**되면 테스트가 실패하기를 원하는가?

- 예 - `cy.contains()`를 사용
- 아니오 - 데이터 속성을 사용

위의 버튼 예시를 다시 살펴보겠다.

```html
<button id="main" class="btn btn-large" data-cy="submit">Submit</button>
```

문제는 테스트에서 `Submit`의 텍스트 콘텐츠가 얼마나 중요한가라는 것이다.

텍스트가 `Submit`에서 `Save`로 변경되면 테스트가 실패하기를 원하는가?

`Submit`이라는 단어가 중요하며 변경되면 안 되기 때문에 대답이 **예**라면 `cy.contains()`를 이용해 요소를 타겟팅한다.

텍스트가 변경될 수 있기 때문에 대답이 **아니오**라면 `cy.get()`과 데이터 속성을 사용한다. 텍스트를 `Save`로 변경해도 테스트가 실패하지 않는다.