# 5장 웹 서버

웹 서버는 월드 와이드 웹의 일꾼이다.

## 1. 다채로운 웹 서버

웹 서버는 HTTP 요청을 처리하고 응답을 제공한다. '웹 서버'라는 용어는 웹 서버 소프트웨어와 웹페이지 제공에 특화된 장비(컴퓨터와 같은) 양쪽 모두를 가리킨다.

웹 서버는 HTTP 프로토콜을 구현하고, 웹 리소스를 관리하고, 웹 서버 관리 기능을 제공한다. 웹 서버는 TCP 커넥션 관리에 대한 책임을 운영체제와 나눠 갖는다.

## 3. 진짜 웹 서버가 하는 일

웹 서버가 하는 일은 다음과 같다.

1. **커넥션을 맺는다.** 클라이언트의 접속을 받거나, 원치 않는 클라이언트라면 닫는다.
2. **요청을 받는다.** HTTP 요청 메시지를 네트워크로부터 읽어 들인다.
3. **요청을 처리한다.** 요청 메시지를 해석하고 행동을 취한다.
4. **리소스에 접근한다.** 메시지에서 지정한 리소스에 접근한다.
5. **응답을 만든다.** 올바른 헤더를 포함한 HTTP 응답 메시지를 생성한다.
6. **응답을 보낸다.** 응답을 클라이언트에게 돌려준다.
7. **트랜잭션을 로그로 남긴다.** 로그파일에 트랜잭션 완료에 대한 기록을 남긴다.

### 1단계: 클라이언트 커넥션 수락

클라이언트가 이미 서버에 대해 지속적 커넥션을 갖고 있다면, 클라이언트는 해당 커넥션을 사용할 수 있다. 그렇지 않다면, 클라이언트는 서버에 대한 새 커넥션을 열 필요가 있다.

#### 새 커넥션 다루기

클라이언트가 웹 서버에 TCP 커넥션을 요청하면, 웹 서버는 그 커넥션을 맺고 TCP 커넥션에서 IP 주소를 추출하여 클라이언트를 확인한다. 클라이언트의 IP 주소나 호스트 명이 인가되지 않았거나 악의적이라고 판단하면 커넥션을 닫는다.

#### 클라이언트 호스트 명 식별

대부분의 웹 서버는 '역방향 DNS(reverse DNS)'를 사용하여 클라이언트의 IP 주소를 호스트 명으로 변환한다. 웹 서버는 이 호스트 명을 구체적인 접근 제어와 로깅을 위해 사용할 수 있다.

호스트 명 룩업(hostname lookup)은 시간이 오래 걸리는 작업이므로 대부분의 웹 서버는 호스트 명 분석(hostname resolution)을 꺼두거나 특정 콘텐츠에 대해서만 켜놓는다.

### 2단계: 요청 메시지 수신

요청 메시지를 파싱할 때, 웹 서버는 다음과 같은 일을 한다.

- 요청줄을 파싱하여 요청 메서드, 리소스의 식별자(URI), 버전 번호를 찾는다.
- 메시지 헤더들을 읽는다.
- 헤더의 끝을 의미하는 빈 줄을 찾는다.
- 요청 본문이 있다면 읽는다. (길이는 Content-Length 헤더로 정의된다.)

요청 메시지를 파싱할 때, 웹 서버는 입력 데이터를 네트워크로부터 불규칙하게 받는다. 네트워크 커넥션은 언제라도 무효화될 수 있다. 웹 서버는 메시지 일부분을 메모리에 임시 저장할 필요가 있다.

#### 메시지의 내부 표현

몇몇 웹 서버는 요청 메시지를 쉽게 다룰 수 있도록 내부의 자료 구조에 저장한다.

#### 커넥션 입력/출력 처리 아키텍처

요청이 언제라도 도착할 수 있기 때문에 웹 서버는 항상 새 요청을 주시하고 있다. 웹 서버 아키텍처의 차이에 따라 요청을 처리하는 방식도 달라진다.

- 단일 스레드 웹 서버: 한 번에 하나씩 요청을 처리한다. 처리 도중에 모든 다른 커넥션은 무시된다.
- 멀티프로세스와 멀티스레드 웹 서버: 여러 요청을 동시에 처리하기 위해 여러 개의 프로세스 혹은 고효율 스레드를 할당한다.

> 프로세스란 어떤 프로그램의 자신만의 변수 집합을 갖는 하나의 독립된 제어 흐름이다. 스레드는 프로세스의 더 빠르고 더 효율적인 버전이다.

- 다중 I/O 서버: 대량의 커넥션을 지원하기 위해, 많은 웹 서버는 다중 아키텍처를 채택했다. 다중 아키텍쳐에서는 모든 커넥션이 동시에 감시당한다. 커넥션의 상태가 바뀌면, 그 커넥션에 대해 작은 양의 처리가 수행된다.
- 다중 멀티스레드 웹 서버: 몇몇 시스템은 여러 CPU의 이점을 살리기 위해 멀티스레딩과 다중화(multiplexing)를 결합한다. 여러 개의 스레드는 각각 열려있는 커넥션을 감시하고 각 커넥션에 대해 조금씩 작업을 수행한다.

### 3단계: 요청 처리

서버는 파싱된 요청을 적절하게 처리한다.

### 4단계: 리소스의 매핑과 접근

웹 서버는 리소스 서버다. 웹 서버는 HTML 페이지나 JPEG 이미지 같은 미리 만들어진 콘텐츠나 동적 콘텐츠를 제공한다.

웹 서버가 클라이언트에 콘텐츠를 전달하려면, 그전에 요청 메시지의 URI에 대응하는 콘텐츠나 콘텐츠 생성기를 웹 서버에서 찾아서 원천을 식별해야 한다.

#### Docroot

리소스 매핑의 가장 단순한 형태는 요청 URI를 웹 서버의 파일 시스템 안에 있는 파일 이름으로 사용하는 것이다. 웹 콘텐츠를 위해 예약해 둔 특별한 폴더를 문서 루트 혹은 docroot라고 부른다. 웹 서버는 요청 URI를 문서 루트 뒤에 붙인다.

예를 들어 어떤 웹 서버가 문서 루트 `/usr/local/httpd/files`를 갖고 있다고 가정해 보겠다. `/specials/saw-blade.gif`에 대한 요청이 오면, 웹 서버는 `/usr/local/httpd/files/specials/saw-blade.gif` 파일을 반환한다.

#### 디렉터리 목록

웹 서버는 클라이언트가 디렉터리 URL을 요청했을 때 다음과 같은 행동을 취할 수 있다.

- 오류를 반환한다.
- 디렉터리 대신 특별한 색인 파일을 반환한다.
- 디렉터리를 탐색해서 그 내용을 담은 HTML 페이지를 반환한다.

대부분의 웹 서버는 디렉터리 안에서 `index.html` 혹은 `index.htm`으로 이름 붙은 파일을 찾는다.

#### 동적 콘텐츠 리소스 매핑

웹 서버는 URI를 동적 리소스에 매핑할 수도 있다. 즉, 요청에 맞게 콘텐츠를 생성하는 프로그램에 URI를 매핑하는 것이다.

#### 서버사이드 인클루드(Server-Side Includes, SSI)

만약 어떤 리소스가 서버사이드 인클루드를 포함하고 있는 것으로 설정되어 있다면, 서버는 그 리소스의 콘텐츠를 클라이언트에게 보내기 전에 처리한다. 서버는 콘텐츠에 변수 이름이나 내장된 스크립트가 될 수 있는 어떤 특별한 패턴이 있는지 검사를 받는다.

#### 접근 제어

웹 서버는 각각의 리소스에 접근 제어를 할당할 수 있다.

### 5단계: 응답 만들기

응답 메세지는 응답 상태 코드, 응답 헤더, 그리고 응답 본문(존재한다면)을 포함한다.

#### 응답 엔터티

만약 응답 본문이 있다면, 응답 메시지는 주로 다음을 포함한다.

- Content-Type 헤더: 응답 본문의 MIME 타입
- Content-Length 헤더: 응답 본문의 길이
- 실제 응답 본문의 내용

#### MIME 타입 결정하기

다음은 MIME 타입과 리소스를 연결하는 여러 가지 방법이다.

- mime.types: 파일 이름의 확장자를 사용한다. 가장 흔한 방법이다.
- 매직 타이핑(Magic typing): 파일의 내용을 검사해서 알려진 패턴에 대한 테이블(매직 파일)에 해당하는 패턴이 있는지 찾는다.
- 유형 명시(Explicit typing): 특정 파일이나 디렉터리 안의 파일들이 어떤 MIME 타입을 갖도록 설정한다.
- 유형 협상(Type negotiation): 사용자와의 협상을 통해 사용하기 가장 좋은 형식을 판별한다.

#### 리디렉션

웹 서버는 종종 브라우저가 다른 곳으로 가도록 리디렉트할 수 있다. 리디렉션 응답은 3XX 상태 코드로 지칭된다. Location 응답 헤더는 콘텐츠의 새로운 위치를 나타낸다.

리디렉션은 다음의 경우에 유용하다.

- 리소스가 영구히 옮겨진 경우
- 리소스가 임시로 옮겨진 경우: 서버는 클라이언트가 나중에는 원래 URL로 찾아오고 북마크도 갱신하지 않기를 원한다. 303, 307 상태 코드
- URL 증강: 서버는 상태 정보를 내포한 새 URL을 생성하고 사용자를 이 새 URL로 리디렉트한다. 303, 307 상태 코드
- 부하 균형: 부하가 덜 걸린 서버로 리다이렉트한다. 303, 307 상태 코드
- 친밀한 다른 서버가 있을 때
- 디렉터리 이름 정규화: 끝에 빗금을 빠뜨렸다면 빗금을 추가한 URI로 리디렉트한다.

리소스가 영구히 옮겨진 경우에만 301 상태 코드를 사용하고 대부분의 경우에는 303, 307 상태 코드를 사용한다.

### 6단계: 응답 보내기

서버는 커넥션 상태를 추적해야 하며 지속적인 커넥션은 특별히 주의할 필요가 있다.

### 7단계: 로깅

트랜잭션이 완료되었을 때 웹 서버는 트랜잭션 로그를 로그파일에 기록한다.
