# 7장 캐시

웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치다. 웹 요청이 캐시에 도착했을 때, 캐시된 로컬 사본이 존재한다면, 그 문서는 원 사본이 아니라 그 캐시로부터 제공된다.

캐시는 다음과 같은 혜택을 준다.

- 네트워크 요금으로 인한 비용 절감
- 네트워크 병목 감소
- 원 서버에 대한 요청을 줄여줌
- 거리로 인한 지연을 줄여줌

## 1. 불필요한 데이터 전송

복수의 클라이언트가 자주 쓰이는 원 서버 페이지에 접근할 때, 서버는 같은 문서를 클라이언트에게 각각 한 번씩 전송하게 된다.

캐시를 이용하면 첫 번째 서버 응답은 캐시에 보관된다. 캐시된 사본이 뒤이은 요청들에 대한 응답으로 사용된다.

## 2. 대역폭 병목

캐시는 광역 통신망의 제한된 대역폭으로 인한 병목을 개선할 수 있다.

## 3. 갑작스런 요청 쇄도(Flash Crowds)

캐싱은 갑작스런 요청 쇄도에 대처하기 위해 특히 중요하다. 갑작스런 사건으로 인해 많은 사람이 거의 동시에 웹 문서에 접근할 때 이런 일이 발생한다.

## 4. 거리로 인한 지연

모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킨다. 그리고 빛의 속도 그 자체가 유의미한 지연을 유발한다.

예를 들어 일본에서 미국의 서버에 접속한다면, 거리가 10,000km이므로 지연이 600밀리초에 이른다.

## 5. 적중과 부적중

캐시는 유용하다. 그러나 캐시가 세상 모든 문서의 사본을 저장할 수는 없다.

캐시에 요청이 도착했을 때, 그에 대응하는 사본이 있다면 사본을 이용하여 요청이 처리된다. 이것을 **캐시 적중(cache hit)**이라고 부른다. 대응하는 사본이 없다면 요청이 그냥 원 서버로 전달될 뿐이다. 이것을 **캐시 부적중(cache miss)**이라고 부른다.

### 재검사(Revalidation)

원 서버 콘텐츠는 변경될 수 있기 때문에, 캐시는 반드시 갖고 있는 사본이 최신인지 서버를 통해 때때로 점검할 필요가 있다. 이러한 신선도 검사를 HTTP 재검사라고 부른다.

대부분의 캐시는 클라이언트가 사본을 요청하였으며 그 사본이 검사를 할 필요가 있을 정도로 충분히 오래된 경우에만 재검사를 한다.

캐시는 재검사가 필요할 때 원 서버에 작은 재검사 요청을 보낸다. 콘텐츠가 변경되지 않았다면 서버는 아주 작은 304 Not Modified 응답을 보낸다. 이제 캐시는 즉각 사본이 신선하다고 임시로 다시 표시한 뒤 그 사본을 클라이언트에게 제공한다. 이를 재검사 적중 혹은 느린 적중이라고 부른다. 재검사 적중은 순수 캐시 적중보다는 느리고 캐시 부적중보다는 빠르다.

HTTP에서 캐시된 객체를 재확인하기 위해 가장 많이 쓰이는 도구는 If-Modified-Since 헤더이다. 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미이다.

다음은 GET If-Modified-Since 요청이 서버에 도착했을 때 일어날 수 있는 세 가지 상황이다.

- 재검사 적중: 서버 객체가 변경되지 않았다면, 서버는 클라이언트에게 작은 HTTP 304 Not Modified 응답을 보낸다.
- 재검사 부적중: 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 평범한 HTTP 200 OK 응답을 클라이언트에게 보낸다.
- 객체 삭제: 서버 객체가 삭제되었다면, 서버는 404 Not Found 응답을 돌려보내며 캐시는 사본을 삭제한다.

### 적중률

캐시가 요청을 처리하는 비율을 캐시 적중률(캐시 적중비), 혹은 문서 적중률(문서 적중비)이라고 부르기도 한다. 흔히 퍼센트로 표현된다. 0%는 모든 요청이 캐시 부적중임을, 100%는 모든 요청이 캐시 적중임을 의미한다.

대개 적중률과 재검사 적중률은 별도로 측정된다.

오늘날 적중률 40%면 웹 캐시로 괜찮은 편이다.

### 바이트 적중률

문서들이 모두 같은 크기이지는 않기 때문에 문서 적중률이 모든 것을 말해주지 않는다. 어떤 사람들은 바이트 단위 적중률 측정값을 더 선호한다. 특히 트래픽의 모든 바이트에 요금이 매겨지는 경우에 그렇다.

문서 적중률은 얼마나 많은 웹 트랜잭션을 외부로 내보내지 않았는지 보여준다. 트랜잭션은 고정된 소요 시간을 포함하게 되는데, 문서 적중률을 개선하면 전체 대기시간(지연)이 줄어든다. 반면 바이트 단위 적중률은 얼마나 많은 바이트가 인터넷으로 나가지 않았는지 보여준다. 바이트 단위 적중률의 개선은 대역폭 절약을 최적화한다.

### 적중과 부적중의 구별

불행히도 HTTP는 클라이언트에게 응답이 캐시 적중인지 원 서버 접근인지 말해줄 수 있는 방법을 제공하지 않는다. 두 경우 모두 응답 코드는 200 OK가 될 것이다.

응답이 캐시에서 왔는지 알아내는 한 가지 방법은 Date 헤더나 Age헤더를 이용하는 것이다. 현재 시각과 비교해서 응답의 생성일이 오래되었다면 응답이 캐시된 것임을 알아낼 수 있다.

## 6. 캐시 토폴로지

### 개인 전용 캐시

웹브라우저는 개인 전용 캐시를 내장하고 있다. 대부분의 브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시해 놓고, 사용자가 캐시 사이즈와 설정을 수정할 수 있도록 허용한다.

### 공용 프락시 캐시

공용 캐시는 흔히 프락시라고 불리는 특별한 종류의 공유된 프락시 서버다. 프락시 캐시는 로컬 캐시에서 문서를 제공하거나 사용자의 입장에서 서버에 접근한다.

### 프락시 캐시 계층들

작은 캐시에서 캐시 부적중이 발생했을 때 부모 캐시가 걸러진 트래픽을 처리하도록 하는 계층을 만드는 방식이 합리적인 경우가 많다. 클라이언트 주위에는 작고 저렴한 캐시를 사용하고, 계층 상단에는 더 크고 강력한 캐시를 사용한다.

### 캐시망, 콘텐츠 라우팅, 피어링

몇몇 네트워크 아키텍처는 단순한 캐시 계층 대신 복잡한 캐시망을 만든다. 캐시망의 프락시 캐시는 복잡한 방법으로 서로 대화하여 어떤 부모 캐시와 대화할 것인지, 아니면 요청이 캐시를 우회하여 원 서버로 바로 가게 할 것인지 동적으로 결정한다.

## 7. 캐시 처리 단계

다음은 HTTP GET 메시지 하나를 처리하는 기본적인 캐시 처리 절차이다.

1. 요청 받기
2. 파싱
3. 검색
4. 신선도 검사
5. 응답 생성
6. 발송
7. 로깅

이 과정을 플로 차트로 그리면 다음과 같다.

![캐시-GET-요청-플로-차트](https://github.com/user-attachments/assets/c864b276-0879-42dc-acf7-cd3af2c2bd7a)
