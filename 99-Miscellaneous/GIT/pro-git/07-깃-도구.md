# 깃 도구

## 리비전 조회하기

깃은 커밋 하나를 가리키거나 여러 커밋을 가리키는 다양한 방법을 갖고 있다.

### 리비전 하나 가리키기

#### SHA-1 줄여 쓰기

깃은 해시 값의 앞 몇 글자만으로도 어떤 커밋인지 충분히 식별할 수 있다. SHA-1이 중복될 확률은 극히 작다.

```bash
git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
git show 1c002dd4b536e7479f
git show 1c002d
```

#### 브랜치로 가리키기

커밋을 가리키는 방법 중에 가장 많이 사용하는 방법이다. 다음 명령은 `topic1` 브랜치의 최근 커밋을 보여준다.

```bash
git show topic1
```

#### 레프로그로 가리키기

깃은 자동으로 브랜치와 HEAD가 지난 몇 달 동안에 가리켰던 커밋을 모두 기록하는데 이 로그를 레프로그(Reflog)라고 부른다.

```bash
$ git reflog
734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated
d921970 HEAD@{1}: merge phedders/rdocs: Merge made by the 'recursive' strategy.
1c002dd HEAD@{2}: commit: added some blame and merge stuff
1c36188 HEAD@{3}: rebase -i (squash): updating HEAD
95df984 HEAD@{4}: commit: # This is a combination of two commits.
1c36188 HEAD@{5}: rebase -i (squash): updating HEAD
7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD
```

`@{n}` 규칙을 사용하면 예전에 가리키던 것을 확인할 수 있다. 다음 명령은 HEAD가 5번 전에 가리키던 것을 알려준다.

```bash
git show HEAD@{5}
```

레프로그의 일은 모두 로컬에서 일어난 일이다. 내 레프로그가 동료의 저장소에 있을 수 없다. 이제 막 클론한 저장소는 레프로그가 하나도 없다.

#### 조상으로 가리키기

이름 끝에 `^`(캐럿) 기호를 붙이면 깃은 해당 커밋의 부모를 찾는다.

```bash
git show HEAD^
```

`^` 뒤에 숫자도 사용할 수 있다. 예를 들어 `d921970^2` 는 `d921970`의 '두 번째 부모'를 의미한다.

조상을 표현하는 방법으로 `~`(물결) 기호도 있다. `HEAD~2`는 명령을 실행할 시점의 '첫 번째 부모의 첫 번째 부모' , 즉 조부모를 가리킨다.

```bash
git show HEAD~2
```

두 기호를 같이 사용할 수도 있다.

```bash
git show HEAD~3^2
```

### 범위로 커밋 가리키기

#### 점 2개

점 2개(`..`)를 사용하면 한 브랜치에 관련되고 다른 브랜치에 관련되지 않은 커밋을 찾을 수 있다. 예를 들어 다음 명령은 `main`에 없고 `experiment`에 있는 커밋을 보여준다.

```bash
git log master..experiment
```

머지나 푸시 전에 무엇이 변경됐는지 확인할 때 유용하다.

```bash
git log origin/master..HEAD
```

세 개 이상의 브랜치를 확인하고 싶다면 브랜치 앞에 붙이는 `^`를 활용하면 된다. 다음 명령 세 가지는 모두 같다.

```bash
git log refA..refB
git log ^refA refB
```

다음 명령은 `refA`나 `refB`에는 있지만 `refC`에는 없는 커밋을 보여준다.

```bash
git log refA refB ^refC
```

#### 점 3개

점 2개(`...`)는 두 레프가 공통으로 가지는 것을 제외하고 각자 가지고 있는 커밋만 보여준다. 다음 명령은 `main`과 `experiment`의 공통 부분을 제외한 커밋을 보여준다.

```bash
git log main...experiment
```

`--left-right` 옵션을 추가하면 각 커밋이 어느 브랜치에 속하는지도 보여준다.

## 대화형 명령

대화형 명령을 사용하면 스크립트를 통해 커밋할 파일을 고르고 수정된 파일의 일부분만 커밋할 수도 있다.

`git add` 명령에 `-i`(`--interactive`) 플래그를 주면 대화형 모드로 들어간다.

```bash
$ git add -i
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb

*** Commands ***
  1: status     2: update      3: revert     4: add untracked
  5: patch      6: diff        7: quit       8: help
What now>
```

파일의 일부분만 스테이징 구역에 추가하는 것도 가능하다. 여기서 `patch` 명령을 사용하면 되는데, 이는 `git add -p`와 `git reset -p` 명령과 동일하다.

## 스태싱과 클리닝

작업하던 것을 커밋하지 않고 나중에 다시 돌아와서 작업을 이어가고 싶을 때 `git stash`라는 명령을 사용할 수 있다. 스태시 명령을 사용하면 작업 디렉터리에서 수정한 파일들만 저장한다.

스태시에는 스택 구조이다. `git stash` 명령을 수행할 때마다 위(`stash@{0}`)에 쌓인다.

```bash
$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert "added file_size"
stash@{2}: WIP on master: 21d80a5 added number to log
```

저장된 스태시를 다시 적용하려면 다음 명령을 사용한다. 이름이 없으면 깃은 가장 최근의 스태시를 적용한다.

```bash
git stash apply stash@{2}
```

저장된 스태시를 다시 적용할 때 다른 브랜치에 적용하는 것도 가능하다. 작업 디렉터리가 깨끗하지 않아도 된다. 충돌이 있으면 알려준다.

## 검색

`git grep` 명령을 사용하여 커밋 트리나 작업 디렉터리의 내용을 문자열이나 정규표현식을 이용해 쉽게 찾을 수 있다.

`git log`에서는 `-S` 옵션을 사용하여 어떤 변수가 언제 바뀌었는지 확인할 수 있다. `-L` 옵션을 사용하면 어떤 함수나 한 라인의 히스토리를 볼 수 있다.

## 히스토리 재작성하기

히스토리를 재작성하는 것은 아직 공유하지 않은 히스토리에 대해서만 해야 한다.

### 마지막 커밋을 수정하기

커밋 메시지를 수정하고 싶다면 다음 명령을 사용한다.

```bash
git commit --amend
```

이때 스테이징 영역에 파일이 있다면 커밋 자체가 수정된다.

### 커밋 여러 개 수정하기

다음 명령은 마지막 3개의 커밋을 수정한다.

```bash
git rebase -i HEAD~3
```

출력되는 커밋 순서는 `log` 명령과 정반대이다. 제일 위에 있는 것이 가장 오래된 것이다.

이 명령을 사용하면 메시지를 수정하거나, 커밋 순서를 바꾸거나, 커밋을 합치거나, 커밋을 분리할 수 있다.

앞의 대화형 리베이스가 삽이라면 `filter-branch`는 포크레인이다. 모든 커밋에서 어떤 파일을 제거하고 싶을 때 유용하다.
