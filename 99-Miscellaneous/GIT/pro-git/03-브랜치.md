# 브랜치

## 브랜치란 무엇인가

브랜치를 사용하면 코드를 통째로 복사하고 나서 원래 코드와는 상관없이 독립적으로 개발을 진행할 수 있게 된다.

**깃의 브랜치는 커밋 사이를 가볍게 이동할 수 있는 어떤 포인터 같은 것이다.**

![갈라지는-브랜치](https://github.com/autroshot/studyroom/assets/95019875/4ca9546c-aedd-4cfb-bc37-71c4516f42d1)

새로 브랜치를 하나 만드는 것은 41바이트 크기의 파일을(40자와 줄 바꿈 문자) 하나 만드는 것에 불과하다. 따라서 만들기도 쉽고 지우기도 쉽다.

## 브랜치와 머지의 기초

머지는 빨리감기(fast forward)와 3방향(3-way) 머지로 나뉜다.

- 빨리감기: A 브랜치에서 다른 B 브랜치를 머지할 때 B 브랜치가 A 브랜치 이후의 커밋을 가리키고 있으면, 그저 A 브랜치가 B 브랜치와 동일한 커밋을 가리키도록 이동시킬 뿐이다.

  ![master-브랜치와-hotfix-브랜치를-머지하기-전](https://github.com/autroshot/studyroom/assets/95019875/31b4e5fa-bc28-44d1-ac46-d1f10fa7deda)

  ![master-브랜치와-hotfix-브랜치를-머지한-결과](https://github.com/autroshot/studyroom/assets/95019875/0ae5b35a-0432-45ed-8fe0-714624a3c77b)

- 3방향 머지: 빨리감기 머지가 불가능한 경우에 3방향 머지를 사용한다. 깃은 각 브랜치가 가리키는 커밋 두 개와 공통 조상 하나를 사용하여 3방향 머지를 한다. 머지의 결과를 별도의 커밋으로 생성된다.

  ![master-브랜치와-iss53-브랜치를-머지하기-전](https://github.com/autroshot/studyroom/assets/95019875/e27cf0ac-7455-457b-a188-a411438a2c8d)

  ![master-브랜치와-iss53-브랜치를-머지한-결과](https://github.com/autroshot/studyroom/assets/95019875/b914fd4b-6503-4aeb-aade-5c77cff0b5fa)

## 리모트 브랜치

**리모트 트래킹 브랜치**는 리모트 브랜치를 추적하는 레퍼런스이며 브랜치다. 리모트 트래킹 브랜치는 로컬에 있지만 임의로 움직일 수 없다. 리모트 서버에 연결할 때마다 리모트의 브랜치 업데이트 내용에 따라서 자동으로 갱신될 뿐이다.

리모트 트래킹 브랜치의 이름은 `<remote>/<branch>` 형식으로 되어 있다.

로컬과 서버의 커밋 히스토리는 독립적이다. 리모트 서버로부터 저장소 정보를 동기화하려면 `git fetch` 명령을 사용한다.

```bash
git fetch <remote>
```

로컬의 브랜치를 서버로 전송하려면 쓰기 권한이 있는 리모트 저장소에 푸시해야 한다. 로컬 저장소의 브랜치는 자동으로 리모트 저장소로 전송되지 않는다. 명시적으로 브랜치를 푸시해야 정보가 전송된다. 따라서 리모트 저장소에 전송하지 않고 로컬 브랜치에만 두는 비공개 브랜치를 만들 수 있다.

```bash
git push <remote> <branch>
```

리모트 트래킹 브랜치를 로컬 브랜치로 체크아웃하면 자동으로 **트래킹 브랜치**가 만들어진다(트래킹 하는 대상 브랜치를 **업스트림 브랜치**라고 부른다). 트래킹 브랜치는 리모트 브랜치와 직접적인 연결고리가 있는 로컬 브랜치이다.

추적 브랜치가 현재 어떻게 설정되어 있는지 확인하고 싶다면 다음 명령을 실행한다.

```bash
git branch -vv
```

`git pull` 명령은 대부분 `git fetch` 명령을 실행하고 나서 자동으로 `git merge` 명령을 수행하는 것뿐이다. 일반적으로 `fetch` 와 `merge` 명령을 명시적으로 사용하는 것이 `pull` 명령으로 한 번에 두 작업을 하는 것보다 낫다.

## 리베이스하기

한 브랜치에서 변경된 사항을 다른 브랜치에 적용할 수 있다.

![master-브랜치와-expriment-브랜치를-리베이스하기-전](https://github.com/autroshot/studyroom/assets/95019875/b7ad85e8-1330-4e80-9f8a-7d29ce3adf6a)

![master-브랜치와-expriment-브랜치를-리베이스한-결과](https://github.com/autroshot/studyroom/assets/95019875/74e32110-4ffc-444f-89b5-b303fd15861a)

머지든 리베이스든 둘 다 합치는 관점에서는 서로 다를 게 없다. 하지만 리베이스가 좀 더 깨끗한 히스토리를 만든다. 리베이스한 브랜치의 기록을 살펴보면 히스토리가 선형이다. 일을 병렬로 동시에 진행해도 리베이스하고 나면 모든 작업이 차례대로 수행된 것처럼 보인다.

리베이스 후에 머지할 때는 빨리감기만 하면 된다.

리베이스에서는 브랜치의 변경사항을 순서대로 다른 브랜치에 적용하면서 합치고, 머지에서는 두 브랜치의 최종결과만을 가지고 합친다.
