# 관계 쿼리

프리즈마 클라이언트의 주요 기능은 둘 이상의 모델 간의 관계를 쿼리하는 기능입니다. 관계 쿼리에는 다음이 포함됩니다.

- `select`와 `include`를 통한 중첩 읽기(가끔 열렬한 로딩으로도 부름)
- 트랜잭션 보장이 포함 된 중첩 쓰기
- 관련 레코드 필터링하기

프리즈마 클라이언트에는 관계를 넘나들 수 있는 유연한 API도 있습니다.

## 중첩 읽기

중첩 읽기를 사용하면 사용자 및 해당 사용자의 게시물과 같은 데이터베이스의 여러 테이블에서 관련 데이터를 읽을 수 있습니다.

중첩 읽기는 다음을 포함합니다.

- `include`를 사용해 쿼리 응답에 사용자의 게시물이나 프로필과 같은 관련 레코드를 포함합니다.
- 중첩 `select`를 사용해 관련 레코드의 특정 필드를 포함합니다. `include` 내부에 `select`를 중첩할 수도 있습니다.

다음 예시에서는 단일 사용자와 해당 사용자의 게시물을 반환합니다.

```js
const getUser = await prisma.user.findUnique({
  where: {
    id: 19,
  },
  include: {
    posts: true,
  },
})
```

결과:

```js
{
  id: 19,
  name: null,
  email: 'emma@prisma.io',
  profileViews: 0,
  role: 'USER',
  coinflips: [],
  posts: [
    {
      id: 20,
      title: 'My first post',
      published: true,
      authorId: 19,
      comments: null,
      views: 0,
      likes: 0
    },
    {
      id: 21,
      title: 'How to make cookies',
      published: true,
      authorId: 19,
      comments: null,
      views: 0,
      likes: 0
    }
  ]
}
```

### 특정 관계의 모든 필드 포함하기

다음 예시에서는 `title` 필드에 `cookies` 단어가 포함된 모든 게시물과 각 게시물의 작성자를 반환합니다. 결과에는 모든 작성자 필드가 포함됩니다.

```js
const getPosts = await prisma.post.findMany({
  where: {
    title: {
      contains: 'cookies',
    },
  },
  include: {
    author: true, // Return all fields
  },
})
```

결과:

```js
[
  {
    id: 17,
    title: 'How to make cookies',
    published: true,
    authorId: 16,
    comments: null,
    views: 0,
    likes: 0,
    author: {
      id: 16,
      name: null,
      email: 'orla@prisma.io',
      profileViews: 0,
      role: 'USER',
      coinflips: [],
    },
  },
  {
    id: 21,
    title: 'How to make cookies',
    published: true,
    authorId: 19,
    comments: null,
    views: 0,
    likes: 0,
    author: {
      id: 19,
      name: null,
      email: 'emma@prisma.io',
      profileViews: 0,
      role: 'USER',
      coinflips: [],
    },
  },
]
```

### 깊이 중첩된 관계 포함하기

관계의 관계를 포함하도록 `include` 옵션을 중첩할 수 있습니다.

다음 예시는 사용자의 게시물과 각 게시물의 카테고리를 반환합니다.

```js
const user = await prisma.user.findMany({
  include: {
    posts: {
      include: {
        categories: true,
      },
    },
  },
})
```

결과:

```js
{
    "id": 40,
    "name": "Yvette",
    "email": "yvette@prisma.io",
    "profileViews": 0,
    "role": "USER",
    "coinflips": [],
    "testing": [],
    "city": null,
    "country": "Sweden",
    "posts": [
        {
            "id": 66,
            "title": "How to make an omelette",
            "published": true,
            "authorId": 40,
            "comments": null,
            "views": 0,
            "likes": 0,
            "categories": [
                {
                    "id": 3,
                    "name": "Easy cooking"
                }
            ]
        },
        {
            "id": 67,
            "title": "How to eat an omelette",
            "published": true,
            "authorId": 40,
            "comments": null,
            "views": 0,
            "likes": 0,
            "categories": []
        }
    ]
}
```

### 특정 관계 필드 선택하기

중첩 `select`를 사용하여 반환할 관계 필드의 하위 집합을 선택할 수 있습니다.

예를 들어 다음 쿼리는 사용자의 `name`과 각 관련 게시물의 `title`를 반환합니다.

```js
const getUser = await prisma.user.findUnique({
  where: {
    id: 19,
  },
  select: {
    name: true,
    posts: {
      select: {
        title: true,
      },
    },
  },
})
```

결과:

```js
{
  name: "Elsa",
  posts: [ { title: 'My first post' }, { title: 'How to make cookies' } ]
}
```

`include` 내부에 `select`를 중첩할 수도 있습니다.

다음 예시에서는 각 게시물의 모든 `User` 필드와 `title` 필드를 반환합니다.

```js
const getUser = await prisma.user.findUnique({
  where: {
    id: 1,
  },
  // select: { name: true } <-- 불가능
  include: {
    posts: {
      select: {
        title: true,
      },
    },
  },
})
```

결과:

```js
{
  "id": 1,
  "name": null,
  "email": "martina@prisma.io",
  "profileViews": 0,
  "role": "USER",
  "coinflips": [],
  "posts": [
    {
      "title": "How to grow salad"
    },
    {
      "title": "How to ride a horse"
    }
  ]
}
```

`select`와 `include`는 같은 수준에서는 사용할 수 없습니다. 즉, 사용자의 게시물을 `include`하고 각 게시물의 제목을 `select`하면, 사용자의 `email`만 `select`할 수 없습니다.

```js
// The following query returns an exception
const getUser = await prisma.user.findUnique({
  where: {
    id: 19,
  },
|  select: { // 불가능합니다.
    email:  true
  }
|  include: { // 불가능합니다.
    posts: {
      select: {
        title: true
      }
    }
  },
})
```

결과:

```js
Invalid `prisma.user.findUnique()` invocation:

{
  where: {
    id: 19
  },
  select: {
  ~~~~~~
    email: true
  },
  include: {
  ~~~~~~~
    posts: {
      select: {
        title: true
      }
    }
  }
}


Please either use `include` or `select`, but not both at the same time.
```

대신 중첩 `select` 옵션을 사용합니다.

```js
const getUser = await prisma.user.findUnique({
  where: {
    id: 19,
  },
  select: {
    // 이것은 잘 동작합니다.
    email: true,
    posts: {
      select: {
        title: true,
      },
    },
  },
})
```

### 관계 카운트

2.20.0 이상에서는 필드와 함께 관계 카운트를 `include`하거나 `select`할 수 있습니다. (예: 사용자의 게시물 수)

### 관계 목록 필터링하기

`select`를 사용해 관련 레코드(예: 사용자의 게시물)에서 데이터의 하위 집합을 반환할 때 해당 관계 목록을 필터링하고 정렬할 수 있습니다.

예를 들어 `prisma.io` 이메일 주소로 모든 사용자를 쿼리하고 게시된 게시물의 제목을 선택할 수 있습니다.

`email`에 `prisma.io`가 포함된 모든 `User` 레코드를 반환하고 아직 게시되지 않은 모든 `Post` 레코드의 `title`을 선택합니다.

```js
const result = await prisma.user.findMany({
  where: {
    email: {
      contains: 'prisma.io',
    },
  },
  select: {
    posts: {
      where: {
        published: false,
      },
      orderBy: {
        title: 'asc',
      },
      select: {
        title: true,
      },
    },
  },
})
```

`post` 모델의 속성을 사용하여 동일한 쿼리를 작성할 수 있습니다.

```js
const result = await prisma.post.findMany({
  where: {
    published: false,
    User: {
      email: {
        contains: 'prisma.io',
      },
    },
  },
  select: {
    title: true,
  },
})
```

## 중첩 쓰기

중첩 쓰기를 사용하면 단일 트랜잭션으로 데이터베이스에 관계형 데이터를 쓸 수 있습니다.

예를 들어 다음 중첩 쓰기는 하나의 `User`와 두 개의 관련 `Post` 레코드를 생성합니다.

```js
const createUserAndPost = await prisma.user.create({
  data: {
    email: 'elsa@prisma.io',
    name: 'Elsa Prisma',
    posts: {
      create: [
        { title: 'How to make an omelette' },
        { title: 'How to eat an omelette' },
      ],
    },
  },
})
```

중첩 쓰기는 다음과 같습니다.

- 단일 프리즈마 클라이언트 쿼리에서 여러 테이블의 데이터 생성, 업데이트, 삭제에 대한 트랜잭션 보장을 제공합니다. 쿼리의 일부가 실패하면(예: 사용자 생성은 성공하지만 게시물 생성은 실패) 프리즈마 클라이언트는 모든 변경 사항을 롤백시킵니다.
- 데이터 모델에서 지원하는 모든 수준의 중첩을 지원합니다.
- 모델의 생성 또는 업데이트 쿼리를 사용할 때 관계 필드에 사용할 수 있습니다. 다음 섹션에서는 쿼리별로 사용할 수 있는 중첩 쓰기 옵션을 보여줍니다.

### 관련 레코드 생성하기

레코드와 하나 이상의 관련 레코드를 동시에 생성할 수 있습니다.

다음 쿼리는 하나의 `User` 레코드와 두 개의 관련 `Post` 레코드를 생성합니다.

```js
const user = await prisma.user.create({
  data: {
    email: 'elsa@prisma.io',
    name: 'Elsa Prisma',
    posts: {
      create: [
        { title: 'How to make an omelette' },
        { title: 'How to eat an omelette' },
      ],
    },
  },
  include: {
    posts: true, // Include all posts in the returned object
  },
})
```

결과:

```js
{
  id: 29,
  name: 'Elsa',
  email: 'elsa@prisma.io',
  profileViews: 0,
  role: 'USER',
  coinflips: [],
  posts: [
    {
      id: 22,
      title: 'How to make an omelette',
      published: true,
      authorId: 29,
      comments: null,
      views: 0,
      likes: 0
    },
    {
      id: 23,
      title: 'How to eat an omelette',
      published: true,
      authorId: 29,
      comments: null,
      views: 0,
      likes: 0
    }
  ]
}
```

### 단일 레코드와 여러 관련 레코드 생성하기

단일 레코드와 여러 관련 레코드를 생성하거나 업데이트하는 두 가지 방법이 있다(예: 여러 게시물이 있는 사용자)

- 중첩 `create` 쿼리 사용
- 중첩 `createMany` 쿼리 사용

두 방법에는 장단점이 있습니다.

| 특징                             | `create` | `createMany` | 메모                                                         |
| :------------------------------- | :------- | :----------- | :----------------------------------------------------------- |
| 한 번에 하나의 레코드를 생성     | ✔        | ✘            | 잠재적으로 성능이 떨어집니다.                                |
| 하나의 쿼리에서 모든 레코드 생성 | ✘        | ✔            | 잠재적으로 더 성능이 좋습니다.                               |
| 중첩 추가 관계 지원              | ✔        | ✘ *          | 예를 들어 하나의 쿼리에서 하나의 사용자, 여러 게시물, 게시물당 여러 댓글을 생성할 수 있습니다. * 일대일 관계에서 외래 키를 직접 설정할 수 있습니다. (예: `{ authorId: 9 }`) |
| 중복 레코드 건너뛰기 지원        | ✘        | ✔            | `skipDuplicates` 쿼리 옵션을 사용합니다.                     |
| 일대다 관계 지원                 | ✔        | ✔            | 예를 들어 하나의 사용자와 여러 게시물을 만들 수 있습니다. (한 사용자가 여러 게시물을 가짐) |
| 다대다 관계 지원                 | ✔        | ✘            | 예를 들어 하나의 게시물과 여러 카테고리를 만들 수 있습니다. (하나의 게시물에 여러 카테고리가 있을 수 있고 한 카테고리에 여러 게시물이 있을 수 있음) |

다음 쿼리는 중첩 `create`을 사용해 다음을 생성합니다.

- 사용자 1명
- 게시물 2개
- 게시물 카테고리 1개

이 예시에서는 중첩 `include`를 사용하여 모든 게시물과 게시물 카테고리를 포함합니다.

```js
const user = await prisma.user.create({
  data: {
    email: 'yvette@prisma.io',
    name: 'Yvette',
    posts: {
      create: [
        {
          title: 'How to make an omelette',
          categories: {
            create: {
              name: 'Easy cooking',
            },
          },
        },
        { title: 'How to eat an omelette' },
      ],
    },
  },
  include: {
    // posts를 포함합니다.
    posts: {
      include: {
        categories: true, // 게시물 categories를 포함합니다.
      },
    },
  },
})
```

결과:

```js
{
    "id": 40,
    "name": "Yvette",
    "email": "yvette@prisma.io",
    "profileViews": 0,
    "role": "USER",
    "coinflips": [],
    "testing": [],
    "city": null,
    "country": "Sweden",
    "posts": [
        {
            "id": 66,
            "title": "How to make an omelette",
            "published": true,
            "authorId": 40,
            "comments": null,
            "views": 0,
            "likes": 0,
            "categories": [
                {
                    "id": 3,
                    "name": "Easy cooking"
                }
            ]
        },
        {
            "id": 67,
            "title": "How to eat an omelette",
            "published": true,
            "authorId": 40,
            "comments": null,
            "views": 0,
            "likes": 0,
            "categories": []
        }
    ]
}
```

다음 쿼리는 중첩 `createMany`를 이용해 다음을 생성합니다.

- 사용자 1명
- 게시물 2개

이 예시에서는 중첩 `include`를 사용하여 모든 게시물을 포함합니다. `createMany` 쿼리 내부에 `create` 또는 `createMany`를 추가로 중첩하는 것은 불가능합니다. 즉, 사용자, 게시물, 게시물 카테고리를 동시에 생성할 수는 없습니다.

```js
const user = await prisma.user.create({
  data: {
    email: 'saanvi@prisma.io',
    posts: {
      createMany: {
        data: [{ title: 'My first post' }, { title: 'My second post' }],
      },
    },
  },
  include: {
    posts: true,
  },
})
```

결과:

```js
{
    "id": 43,
    "name": null,
    "email": "saanvi@prisma.io",
    "profileViews": 0,
    "role": "USER",
    "coinflips": [],
    "testing": [],
    "city": null,
    "country": "India",
    "posts": [
        {
            "id": 70,
            "title": "My first post",
            "published": true,
            "authorId": 43,
            "comments": null,
            "views": 0,
            "likes": 0
        },
        {
            "id": 71,
            "title": "My second post",
            "published": true,
            "authorId": 43,
            "comments": null,
            "views": 0,
            "likes": 0
        }
    ]
}
```

### 여러 레코드 및 여러 관련 레코드 생성하기

`createMany` 쿼리에서 관계에 접근할 수 없습니다. 즉, 단일 중첩 쓰기에서 여러 사용자와 여러 게시물을 만들 수 없습니다. 

다음은 불가능합니다.

```js
const createMany = await prisma.user.createMany({
  data: [
    {
      name: 'Yewande',
      email: 'yewande@prisma.io',
      posts: {
        // 게시물을 생성하는 것은 불가능합니다.
      },
    },
    {
      name: 'Noor',
      email: 'noor@prisma.io',
      posts: {
        // 게시물을 생성하는 것은 불가능합니다.
      },
    },
  ],
})
```

### 기존 레코드 연결하기

다음 쿼리는 새 `User` 레코드를 `create`하고 해당 레코드를 기존 게시물 3개에 `connect`합니다.

```js
const user = await prisma.user.create({
  data: {
    email: 'vlad@prisma.io',
    posts: {
      connect: [{ id: 8 }, { id: 9 }, { id: 10 }],
    },
  },
  include: {
    posts: true, // 반환 객체에 모든 게시물을 포함합니다.
  },
})
```

결과:

```js
{
  id: 27,
  name: null,
  email: 'vlad@prisma.io',
  profileViews: 0,
  role: 'USER',
  coinflips: [],
  posts: [
    {
      id: 10,
      title: 'An existing post',
      published: true,
      authorId: 27,
      comments: {},
      views: 0,
      likes: 0
    }
  ]
}
```

> **참고**
>
> 프리즈마 클라이언트는 `connect: [{ id: 8 }, { id: 9 }, { id: 10 }]`의 게시물 레코드를 하나라도 찾을 수 없는 경우 예외를 발생시킵니다.

기존의 레코드를 새로운 사용자나 기존의 사용자에 `connect`할 수 없습니다.

아래의 쿼리는 다음과 같습니다.

1. 기존 게시물(`id: 11`)을 기존 사용자(`id: 9`)에게 연결
2. 새 관련 게시물(`title: "My new post title"`) 추가

```js
const getUser = await prisma.user.update({
  where: {
    id: 9
  },
  data: {
    posts: {
|      connect: {
|        id: 11
|      },
      create: {
        title: "My new post title"
      }
    }
  }
})
```

### 레코드 연결하거나 생성하기

관련 레코드가 이미 존재하거나 존재하지 않을 경우 `connectOrCreate`를 이용해 관련 레코드를 연결합니다.

- 이메일 주소가 `viola@prisma.io`인 `User`를 연결하거나
- 사용자가 아직 없으면 이메일 주소가 `viola@prisma.io`인 `User`를 새로 생성합니다.

```js
const createPost = await prisma.post.create({
  data: {
    title: 'How to make croissants',
    author: {
      connectOrCreate: {
        where: {
          email: 'viola@prisma.io',
        },
        create: {
          email: 'viola@prisma.io',
          name: 'Viola',
        },
      },
    },
  },
  include: {
    author: true,
  },
})
```

결과:

```js
{
  id: 26,
  title: 'How to make croissants',
  published: true,
  authorId: 43,
  views: 0,
  likes: 0,
  author: {
    id: 43,
    name: 'Viola',
    email: 'viola@prisma.io',
    profileViews: 0,
    role: 'USER',
    coinflips: []
  }
}
```

### 관련 레코드 연결 끊기

레코드 목록 중 하나(예: 특정 블로그 게시물)를 `disconnect`하려면 연결을 끊을 레코드의 ID나 고유 식별자를 건네줍니다.

```js
const updatePost = await prisma.user.update({
  where: {
    id: 16,
  },
  data: {
    posts: {
      disconnect: [{ id: 12 }, { id: 19 }],
    },
  },
  select: {
    posts: true,
  },
})
```

결과:

```js
{
  id: 16,
  name: null,
  email: 'orla@prisma.io',
  profileViews: 0,
  role: 'USER',
  coinflips: [],
  posts: []
}
```

하나의 레코드(예: 게시물 작성자)를 `disconnect`하려면 `disconnect: true`를 사용합니다.

```js
const updatePost = await prisma.post.update({
  where: {
    id: 23,
  },
  data: {
    author: {
      disconnect: true,
    },
  },
  include: {
    author: true,
  },
})
```

결과:

```js
{
  id: 23,
  title: 'How to eat an omelette',
  published: true,
  authorId: null,
  comments: null,
  views: 0,
  likes: 0,
  author: null
}
```

### 모든 관련 레코드 연결 끊기

일대다 관계(하나의 사용자에게 많은 게시물이 있음)의 모든 관련 레코드를 `disconnect`하려면 다음과 같이 관계에 빈 목록을 `set`합니다.

```js
const updateUser = await prisma.user.update({
  where: {
    id: 16
  },
  data: {
    posts: {
|      set: []
    }
  },
  include: {
    posts: true
  }
})
```

결과:

```js
{
  id: 16,
  name: null,
  email: 'orla@prisma.io',
  profileViews: 0,
  role: 'USER',
  coinflips: [],
  posts: []
}
```

### 모든 관련 레코드 삭제하기

모든 관련 `Post` 레코드를 삭제합니다.

```js
const update = await prisma.user.update({
  where: {
    id: 11,
  },
  data: {
    posts: {
      deleteMany: {},
    },
  },
})
```

### 특정 관련 레코드 삭제하기

게시되지 않은 모든 게시물을 삭제하여 사용자를 업데이트합니다.

```js
const update = await prisma.user.update({
  where: {
    id: 11,
  },
  data: {
    posts: {
      deleteMany: {
        published: false,
      },
    },
  },
})
```

특정 게시물을 삭제하여 사용자를 업데이트합니다.

```js
const update = await prisma.user.update({
  where: {
    id: 6,
  },
  data: {
    posts: {
      deleteMany: [{ id: 7 }],
    },
  },
})
```

### 모든 관련 레코드(또는 필터) 업데이트하기

중첩 `updateMany`을 사용하여 특정 사용자의 모든 관련 레코드를 업데이트 할 수 있습니다.

다음 쿼리는 특정 사용자의 모든 게시물 게시를 취소합니다.

```js
const update = await prisma.user.update({
  where: {
    id: 6,
  },
  data: {
    posts: {
      updateMany: {
        where: {
          published: true,
        },
        data: {
          published: false,
        },
      },
    },
  },
})
```

### 특정 관련 레코드 업데이트하기

```js
const update = await prisma.user.update({
  where: {
    id: 6,
  },
  data: {
    posts: {
      update: {
        where: {
          id: 9,
        },
        data: {
          title: 'My updated title',
        },
      },
    },
  },
})
```

### 관련 레코드 업데이트하거나 생성하기

다음 쿼리는 중첩 `upsert`를 사용하여 해당 사용자가 존재하는 경우 `"bob@prisma.io"`를 업데이트하고, 존재하지 않는 경우 사용자를 생성합니다.

```js
const update = await prisma.post.update({
  where: {
    id: 6,
  },
  data: {
    author: {
      upsert: {
        create: {
          email: 'bob@prisma.io',
          name: 'Bob the New User',
        },
        update: {
          email: 'bob@prisma.io',
          name: 'Bob the existing user',
        },
      },
    },
  },
})
```

### 기존 레코드에 새 관련 레코드 추가하기

`update` 내부에 중첩 `create`나 `createMany`를 사용해 새 관련 레코드를 기존 레코드에 추가할 수 있습니다.

다음 쿼리는 `id: 9`인 사용자에게 두 개의 게시물을 추가합니다.

```js
const user = await prisma.user.update({
  where: {
    id: 9,
  },
  data: {
    posts: {
      createMany: {
        data: [{ title: 'My first post' }, { title: 'My second post' }],
      },
    },
  },
})
```

## 관계 필터

### -대다 관계 필터링

프리즈마 클라이언트는 관계의 -대다 측면에서 관련 레코드의 속성으로 레코드를 필터링하는 `some`, `every`, `none` 옵션을 제공합니다. 예를 들어 게시물 속성을 기반으로 사용자를 필터링할 수 있습니다.

예를 들어:

| 요구 사항                                                    | 사용할 쿼리 옵션               |
| :----------------------------------------------------------- | :----------------------------- |
| 게시되지 않은 `Post` 레코드가 하나 이상 있는 모든 `User` 목록을 원합니다. | `some` 게시물이 게시되지 않음  |
| 게시되지 않은 `Post` 레코드가 없는 모든 `User` 목록을 원합니다. | `none` 게시물이 게시되지 않음  |
| 게시되지 않은 `Post` 레코드만 있는 모든 `User` 목록을 원합니다. | `every` 게시물이 게시되지 않음 |

예를 들어 다음 쿼리는다음 기준을 충족하는  `User` 결과를 반환합니다.

- 조회수가 100회를 넘는 게시물이 없음
- 모든 게시물에 좋아요가 50개 이하

```js
const users = await prisma.user.findMany({
  where: {
    posts: {
      none: {
        views: {
          gt: 100,
        },
      },
      every: {
        likes: {
          lte: 50,
        },
      },
    },
  },
})
```

### -대일 관계 필터링

프리즈마 클라이언트는 관계의 -대일 측면에서 관련 레코드의 속성으로 레코드를 필터링하는 `is`, `isNot` 옵션을 제공합니다. 예를 들어 작성자의 속성을 기반으로 게시물을 필터링할 수 있습니다.

예를 들어 다음 쿼리는 다음 기준을 충족하는 `Post` 레코드를 반환합니다.

- 작성자 이름은 Bob이 아님
- 작성자는 40세 이상

```js
const users = await prisma.post.findMany({
  where: {
    author: {
      isNot: {
        name: "Bob"
      },
      is: {
        age: {
          gt: 40
        }
      }
    }
  }
})
```

### 관련 레코드가 있는지 여부로 필터링

[관계 카운트로 필터링](https://github.com/prisma/prisma/issues/3821)하는 것은 아직 지원되지 않습니다. 그러나 레코드에 관련 레코드가 있는지 여부를 필터링할 수 있습니다.

예를 들어 다음 쿼리는 `none`을 사용해 게시물이 없는 모든 사용자를 반환합니다.

```js
const usersWithZeroPosts = await prisma.user.findMany({
  where: {
    posts: {
      none: {},
    },
  },
})
```

다음 쿼리는 하나 이상의 게시물이 있는 모든 사용자를 반환합니다.

```js
const usersWithSomePosts = await prisma.user.findMany({
  where: {
    posts: {
      some: {},
    },
  },
})
```

## 유연한 API

유연한(fluent) API를 사용하면 함수 호출을 통해 모델의 관계를 유연하게 탐색할 수 있습니다. 마지막 함수 호출은 전체 쿼리의 반환 타입을 결정합니다. (각 유형 주석은 코드 스니펫 아래에 추가되어 명시적임)

이 쿼리는 특정 `User`를 기준으로 모든 `Post` 레코드를 반환합니다.

```js
const postsByUser: Post[] = await prisma.user
  .findUnique({ where: { email: 'alice@prisma.io' } })
  .posts()
```

이는 다음 `findMany` 쿼리와 동일합니다.

```js
const postsByUser = await prisma.post.findMany({
  where: { author: { email: 'alice@prisma.io' } },
})
```

위 쿼리 간의 주요 차이점은, 유연한 API 호출은 두 개의 개별 데이터베이스 쿼리로 변환되는 반면 다른 하나는 단일 쿼리만 생성한다는 것입니다. ([GitHub 이슈](https://github.com/prisma/prisma/issues/1984) 참조)

이 요청은 특정 게시물의 모든 카테고리를 반환합니다.

```js
const categoriesOfPost: Category[] = await prisma.post
  .findUnique({ where: { id: 1 } })
  .categories()
```

원하는 만큼 쿼리를 체이닝할 수 있습니다.

이 예시에서 연결은 `Profile`에서 시작하여 `User`, `Post`로 이동합니다.

```js
const posts: Post[] = await prisma.profile
  .findUnique({ where: { id: 1 } })
  .user()
  .posts()
```

체이닝에 대한 유일한 요구 사항은 이전 함수 호출이 **단일 객체**(예: `findUnique` 쿼리 또는 `profile.user()` 같은 -대일 관계에서 반환됨)만 반환해야 한다는 것입니다.

`findMany`는 단일 객체가 아닌 목록을 반환 하기 때문에 다음 쿼리는 불가능합니다.

```js
// 이 쿼리는 올바르지 않습니다.
const posts = await prisma.user.findMany().posts()
```

