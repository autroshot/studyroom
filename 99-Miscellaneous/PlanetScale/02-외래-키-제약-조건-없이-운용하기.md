# 외래 키 제약 조건 없이 운용하기

## 개요

**외래 키**는 부모-자식 관계에서 두 테이블 간의 논리적 행 연결이다. 상위 테이블의 행은 하위 테이블의 하나 이상의 행에서 참조할 수 있다. 외래 키는 일반적으로 대부분의 쿼리에서 `JOIN` 테이블을 지정하는 방법을 제안한다. 테이블은 특별한 경우에 자신을 참조할 수도 있다.

**`FOREIGN KEY` 제약 조건**은 외래 키 관계의 무결성(참조 무결성)을 강제하는 구현인 데이터베이스 구조이다. 즉, 부모 테이블에 해당 행이 있을 때만 자식 테이블이 부모 테이블을 참조할 수 있도록 한다. 또한 제약 조건은 **고아 행**이 존재하는 것을 방지할 수 있다.

**플래닛스케일은 `FOREIGN KEY` 제약 조건을 지원하지 않는다.** 이는 몇 가지 기술적 이유 때문이다.

관계형 모델을 사용하고 한 테이블에서 다른 테이블로 행을 가리키는 방식으로 테이블을 연결하는 것이 좋다. `CONSTRAINT ... FOREIGN KEY` 정의는 스키마에서 허용되지 않는, 데이터베이스 수준에서의 시행일 뿐이다.

## 외래 키 제약 조건의 유형과 동작 방식

다음과 같은 간단한 부모-자식 테이블 관계가 있다고 가정해 보겠다.

```sql
CREATE TABLE parent_table (
  id INT NOT NULL,
  PRIMARY KEY (id)
);

CREATE TABLE child_table (
  id INT NOT NULL,
  parent_id INT,
  PRIMARY KEY (id),
  KEY parent_id_idx (parent_id),
  CONSTRAINT `child_parent_fk` FOREIGN KEY (parent_id) REFERENCES parent_table(id) ON DELETE NO ACTION
);
```

`FOREIGN KEY` 제약 조건은 행 삭제(`ON DELETE`)와 행 업데이트(`ON UPDATE`)에 사용할 수 있다. 이 문서에서는 둘 중 더 영향력이 있는 `ON DELETE`를 다룰 것이다. 하지만 이 논의는 `ON UPDATE` 제약 조건과도 관련이 있다.

외래 키는 다음의 세 가지 유형의 행동을 추가로 지원한다.

### ON DELETE CASCADE

가장 탐욕스럽고 야심찬 행동 유형이다. 상위 테이블에서 행을 `DELETE`하면 하위 테이블의 모든 참조 행은 동일한 트랜잭션 내에서 삭제된다. 이 작업은 부모의 모든 자식은 물론 자식의 자식에 대해서도 재귀적으로 실행된다.

`ON DELETE CASCADE`는 위험하고 자원을 소모하는 행동이다. 하나의 행을 `DELETE`하려 하지만 복수의 테이블에서 수백, 수천 개 이상의 행을 삭제하게 된다. 단순한 트랜잭션처럼 보였던 것이 과도한 락킹, MVCC 오버헤드의 증가, 복제 지연에 영향 등을 포함하는 대규모 작업으로 바뀐다.

가장 큰 위험은 예상치 못한 데이터 손실 가능성이다. 순진한 개발자는 `DELETE FROM parent_table WHERE id=3`이 기껏해야 하나의 행을 삭제할 거라 생각하지만, 실제로는 암묵적인 `DELETE`를 실행하는 `REPLACE INTO` 쿼리와 같은 예기치 못한 동작으로 귀결되고 데이터의 대량 파괴로 이어진다.

`ON DELETE CASCADE`을 사용하는 것은 논란의 여지가 있다. 주의해서 사용할 필요가 있다. 대신 `NO ACTION`을 사용하는 것을 고려할 수 있다.

### ON DELETE SET NULL

이 설정을 사용하면 상위 테이블에서의 `DELETE`(예: `DELETE FROM parent_table WHERE id=3`)가 하위 테이블의 일치하는 행의 참조 열(예: `child_table`의 `parent_id` 열)을 `NULL`로 변경한다. 결국 외래 키 제약 조건이 전혀 없는 것과 비슷하게 고아 행이 되는 것이다.

한 가지 장점은 고아 행을 쉽게 식별할 수 있다는 것이다. 즉, 고아 행만 상위 참조 열에 대해 `NULL`을 갖게 된다.

`CASCADE`와 마찬가지로 상위 테이블에서 행을 하나 삭제하면 하위 테이블에서 여러 행이 업데이트될 수 있다. 이것은 다시 큰 트랜잭션, 과도한 락킹, 복제 지연을 유발할 수 있다.

### ON DELETE NO ACTION

외래 키의 가장 중요한 기능으로, 부모 행을 참조하는 자식 행이 존재하는 경우 부모에 대한 `DELETE`가 실패한다. 상위 행을 `DELETE`하려면 앱이나 사용자는 먼저 모든 하위 참조 행을 `DELETE`해야 한다. 하위 참조 행이 다시 다른 테이블에서 참조된다면, 행을 재귀적으로 `DELETE`해야 한다.

이 행동 유형은 앱이 데이터에 대해 더 강력한 소유권을 갖게 만든다. `ON DELETE NO ACTION`으로 작동하도록 만들어진 앱은 테이블 간의 참조 관계를 알고 유기적으로 진화하며 참조 무결성을 충족하는 올바른 순서로 테이블을 순회하는 `DELETE`/`UPDATE` 흐름을 갖게 된다.

## 외래 키 제약 조건이 없는 스키마는 어떤 모습일까?

`CONSTRAINT`절만 빠진 동일한 모습을 가진다.

```sql
CREATE TABLE parent_table (
  id INT NOT NULL,
  PRIMARY KEY (id)
);

CREATE TABLE child_table (
  id INT NOT NULL,
  parent_id INT,
  PRIMARY KEY (id),
  KEY parent_id_idx (parent_id)
);
```

> **팁**
>
> 각 외래 키 제약 조건에는 연결 양쪽에서 참조된 열을 포함하는 인덱스가 필요하다. 인덱스 `parent_id_idx`는 제약 조건에 필요하다. 테이블에서 데이터를 검색하는 데 사용하는 쿼리 유형에 따라 제약 조건이 없는 테이블에서 해당 키를 삭제할 수도 있다.

## 외래 키 제약 조건이 없는 앱 개발하기

`ON DELETE NO ACTION` 설정에서의 앱의 동작 방식을 기억할 필요가 있다. 앱은 테이블의 종속성을 알고 `DELETE`/`UPDATE`의 반복 순서를 올바르게 처리한다.

이 시점에서 `CONSTRAINT`을 빼면 어떻게 될까?

앱은 변경되지 않는다. 이미 적절한 순서로 적절한 작업을 실행하고 있다. `DELETE FROM parent_table WHERE id=3`을 실행하는 작업은 하위 테이블의 `DELETE` 작업을 성공시킨다. 이 동작 방식을 강제하는 데이터베이스의 안전 보장을 잃었음에도 완벽하게 관리가 된다.

마찬가지로 제약이 없는 스키마로 성장하는 앱은`DELETE`와 `UPDATE`를 처리하는 시나리오를 유기적으로 학습한다. 작업 순서가 강제되지 않으므로 사실상 어느 정도의 자유가 주어진다. 이는 앱이 동일한 트랜잭션에서 각 상위 행 삭제에 대해 수천 개의 종속 행의 `DELETE`를 강제하지 않기 때문에 장점이 된다. 앱은 삭제를 연기할 수 있게 되는데 이에 대한 자세한 내용은 뒤에서 다룰 것이다.

참조 무결성은 많은 논리적 데이터 무결성 제약 조건 중 하나에 불과하다. 데이터베이스가 적용할 수 있는 방법일 뿐이다. 규모가 큰 앱은 데이터베이스가 인식하지 못하는 규칙을 사용하여 데이터 무결성을 유지한다.

## 고아 행 정리하기

`ON DELETE SET NULL` 제약 조건을 다시 살펴보겠다. `NULL`로 설정된 자식 행은 어떻게 될까? 일반적으로는 그대로 둬도 문제가 거의 없다.

예를 들어 `SELECT` 쿼리는 `WHERE parent_id IS NOT NULL`을 이용할 수 있다. 더 나은 방법은 자식 행을 각각의 부모 행과 `JOIN`하는 것이다. 상위 행이 존재하지 않으므로 이러한 `JOIN`이 포함된 쿼리는 비어 있는 값을 반환한다.

결국에는 고아 행이 쌓이고 그 공간을 되찾고 싶을 것이다.

`FOREIGN KEY` 제약 조건이 없어도 상황은 동일하다. 종속된 하위 행을 삭제하지 않고 상위 행을 `DELETE`하는 것이 가능하다. 각각의 (삭제된) 상위 행과 `JOIN`된 하위 행은 비어 있다. `IS NOT NULL`을 이용할 수는 없지만 해당 행을 식별하는 것은 여전히 쉽다. 마찬가지로 해당 행을 잠시 동안 내버려둬도 문제가 되지 않는다.

마찬가지로 고아 행은 결국 쌓인다.

상위 테이블의 행이나 하위 집합의 행을 `DELETE`하지만 오프라인 일괄 처리를 위해 다른 테이블은 그대로 두는 것이 일반적이다.

트래픽이 적은 시간과 같은 편리한 시간에 앱이나 일괄 작업이 분리된 행을 제거한다.

다음은 단순화된 쿼리 예시이다.

```sql
DELETE FROM child_table LEFT JOIN parent_table ON (child_table.parent_id=parent_table.id) WHERE parent_table.id IS NULL
```

단일 `DELETE`문은 대규모 작업일 가능성이 높으므로 지양해야 한다. 좋은 방법은 명령문을 여러 개의 작은 범위의 명령문으로 나누는 것이다. 한 번에 100개 행씩 삭제하는 것이 그 예이다.

