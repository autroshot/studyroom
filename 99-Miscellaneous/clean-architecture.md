# 클린 아키텍처

> 아키텍처는 구현과 측정을 통해 증명해야 하는 가설이다.
>
> \- 톰 길브

> 빨리 가는 유일한 방법은 제대로 가는 것이다.
>
> \- 로버트 C. 마틴

아키텍처 규칙은 시스템에 종속되지 않는다.

코드는 할당문, 조건문, 반복문으로 구성된다.

프로그래밍의 역사가 50년이 넘어가지만 본질은 변하지 않았다. 코드는 여전히 순차(sequence), 분기(selection), 반복(iteration)의 집합체이다.

이 책은 세월이 흘러도 변치 않는 규칙에 관한 것이다.

## 1부 소개

### 1장 설계와 아키텍처란?

소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는데 투입되는 인력을 최소화하는데 있다.

### 2장 두 가지 가치에 대한 이야기

모든 소프트웨어 시스템은 행위(behavior)와 구조(structure)라는 두 가치를 제공한다.

행위(또는 기능)는 이해관계자의 요구사항이다.

소프트웨어(software)는 부드러워야(soft) 한다.

변경사항을 적용하는 데 드는 어려움은 변경되는 범위(scope)에 비례해야 하며, 변경사항의 형태(shape)와는 관련이 없어야 한다.

아이젠하워 매트릭스에서 우선순위를 매기면 다음과 같다.

1. 긴급하고 중요함
2. 긴급하지 않지만 중요함 - 아키텍처
3. 긴급하지만 중요하지 않음 - 행위
4. 긴급하지 않고 중요하지 않음

개발자는 아키텍처를 위해 투쟁해야 한다.

## 2부 벽돌부터 시작하기: 프로그래밍 패러다임

### 3장 패러다임 개요

- 구조적 프로그래밍 - 제어흐름의 직접적인 전환에 대한 규칙

- 객체 지향 프로그래밍 - 제어흐름의 간접적인 전환에 대한 규칙

- 함수형 프로그래밍 - 할당문에 대한 규칙

패러다임은 무엇을 해야 할지를 말하기보다는 **무엇을 해서는 안 되는지**를 말해준다.

### 4장 구조적 프로그래밍

모든 프로그램을 순차, 분기, 반복이라는 세 가지 구조만으로 표현할 수 있다.

구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었다. 구조적 프로그래밍은 프로그래밍에서 반증 가능한 단위를 만들어낸다.

과학은 반증은 가능하지만 증명은 불가능하다. 이 점에서 소프트웨어는 과학과 같다.

테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다.

반증 가능하다는 것은 테스트 가능하다는 것을 의미한다.

### 5장 객체 지향 프로그래밍

객체 지향(Object-Oriented)이 무엇인가에 대한 다양한 설명이 있다.

- 데이터와 함수의 조합
- 실제 세계를 모델링하는 새로운 방법
- 캡슐화, 상속, 다형성

소프트웨어 아키텍트 관점에서 객체 지향은 **다형성**을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다. 그 결과 모듈에 대해 독립성을 보장할 수 있다.

### 6장 함수형 프로그래밍

함수형 프로그래밍에서는 변수가 변경되지 않는다.

변수의 가변성을 경계하는 이유는 경합(race) 조건, 교착(deadlock) 조건, 동시 업데이트(concurrent update) 때문이다.

불변성과 관련하여 가장 주요한 타협 중 하나는 애플리케이션을 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다. 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 한다.

이벤트 소싱(event sourcing) - 상태가 아닌 트랜잭션을 저장하는 전략이다. 애플리케이션은 CRUD가 아니라 CR만 수행한다. 소스 코드 버전 관리 시스템이 이 방식으로 동작한다.

## 3부 설계 원칙

SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 다음과 같도록 만드는 데 있다.

- 변경에 유연하다.
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

------

- SRP(Single Responsibility Principle, 단일 책임 원칙) - 각 소프트웨어 모듈은 변경의 이유가 단 하나여야 한다.

- OCP(Open-Closed Principle, 개방-폐쇄 원칙) - 기존 코드를 수정하기보다 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다.

- LSP(Liskov Substitution Principle, 리스코프 치환 원칙) - 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다.

- ISP(Interface Segregation Principle, 인터페이스 분리 원칙) - 사용하지 않은 것에 의존하지 않아야 한다.

- DIP(Dependency Inversion Principle, 의존성 역전 원칙) - 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다.

### 7장 SRP: 단일 책임 원칙

모든 모듈이 하나의 일만 해야 한다는 것으로 잘못 이해하곤 한다.

**단일 모듈은 변경의 이유가 하나여야 한다.**

이는 하나의 모듈은 하나의 액터에 대해서만 책임져야 한다는 뜻이다. 액터는 사용자 또는 이해관계자이다.

퍼사드(facade) 패턴 - 하위 시스템을 보다 쉽게 사용할 수 있게 해주는 고급 인터페이스. 퍼사드는 건물의 정면을 의미하며, 퍼사드 패턴은 일련의 저수준 인터페이스들을 하나의 고수준 인터페이스로 묶어서 보여준다.

SRP는 메서드와 클래스 수준의 원칙이다.

### 8장 OCP: 개방-폐쇄 원칙

**소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.**

OCP를 위해서는 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.

### 9장 LSP: 리스코프 치환 원칙

처음에는 상속을 사용하도록 가이드하는 방법 정도였으나, 이후에는 인터페이스와 구현체에도 적용되는 광범위한 소프트웨어 설계 원칙으로 변했다.

자바에서는 인터페이스 하나와 이를 구현하는 여러 개의 클래스로 구성된다. 루비에서는 동일한 메서드 시그니처를 공유하는 여러 개의 클래스로 구성된다.

치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 별도 메커니즘을 많이 추가해야 한다.

### 10장 ISP: 인터페이스 분리 원칙

불필요한 짐을 실은 무언가에 의존하면 예상치 못한 문제에 빠질 수 있다.

### 11장 DIP: 의존성 역전 원칙

안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻이다. 구체적인 코딩 실천법은 다음과 같다.

- 변동성이 큰 구체 클래스를 참조하지 않는다.
- 변동성이 큰 구체 클래스로부터 파생하지 않는다.
- 구체 함수를 오버라이드하지 않는다.
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 않는다.

## 4부 컴포넌트 원칙

SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명해준다.

### 12장 컴포넌트

**컴포넌트는 배포 단위다.**

컴파일형 언어에서 컴포넌트는 바이너리 파일의 결합체다. 인터프리터형 언어의 경우는 소스 파일의 결합체다.

컴퓨터 속도의 발전으로 컴포넌트 플러그인 아키텍처를 쉽게 사용할 수 있게 되었다.

링킹 로더(linking loader): 프로그램을 로드하는 동시에 링크까지 수행하는 로더

### 13장 컴포넌트 응집도

어떤 클래스를 어느 컴포넌트에 포함시켜야 할까? 다음은 컴포넌트 응집도와 관련된 세 가지 원칙이다.

- REP(Reuse/Release Equivalence Principle, 재사용·릴리스 등가 원칙): 재사용 단위는 릴리스 단위와 같다.
- CCP(Common Closure Principle, 공통 폐쇄 원칙): 동일한 이유로 동일한 시점에 변경되는 클래스만 같은 컴포넌트로 묶어라. 컴포넌트 수준의 SRP이다.
- CRP(Common Reuse Principle, 공통 재사용 원칙): 컴포넌트 사용자들은 필요하지 않은 것에 의존하게 강요하지 마라. 같이 사용되는 클래스와 모듈만 같은 컴포넌트에 있어야 한다.

REP와 CCP는 포함 원칙, CRP는 배제 원칙이다.

### 14장 컴포넌트 결합

다음 세 가지 원칙은 컴포넌트 사이의 관계를 설명한다.

- ADP(Acyclic Dependencies Principle, 의존성 비순환 원칙): 컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안 된다. 숙취 증후군을 피할 수 있다.

  > 숙취 증후군(the morning after syndrome): 무언가를 작동하게 만들어 놓고 퇴근했는데, 이튿날 출근해 보면 돌아가지 않는다. 여러 개발자가 동일한 소스 파일을 수정하는 환경에서 발생한다.
  >

  컴포넌트 구조는 하향식으로 설계될 수 없다. 시스템이 변경될 때 함께 진화한다.

  컴포넌트 의존성 다이어그램은 앱의 기능을 기술하는 일과는 거의 관련이 없다.

- SDP(Stable Dependencies Principle, 안정된 의존성 원칙): 더 안정된 쪽에 의존하라.

  많은 컴포넌트가 의존하는 컴포넌트가 안정된 컴포넌트이다. 반면 많은 컴포넌트에 의존하는 컴포넌트는 불안정한 컴포넌트이다.

- SAP(Stable Abstractions Principle, 안정된 추상화 원칙): 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.

## 5부 아키텍처